import {
  require_pull
} from "./chunk-LHNWUKTC.js";
import {
  useContentManagerContext,
  useDocument
} from "./chunk-Q4XEIOVX.js";
import {
  useFetchClient
} from "./chunk-RHCZFMI5.js";
import {
  require_isEmpty
} from "./chunk-K3XB5YBV.js";
import {
  require_last
} from "./chunk-ARLCOMEO.js";
import {
  require_isEqual
} from "./chunk-XFGW4SSF.js";
import {
  require_get
} from "./chunk-7ZIO4JFY.js";
import {
  require_baseGetTag,
  require_isArray,
  require_isObjectLike
} from "./chunk-4DJLTZKA.js";
import {
  Accordion,
  Badge,
  Box,
  Button,
  Divider,
  EmptyStateLayout,
  Flex,
  IconButton,
  Modal,
  ProgressBar,
  Status,
  TextButton,
  Typography,
  __assign,
  __extends,
  __rest,
  __spreadArray,
  require_hoist_non_react_statics_cjs
} from "./chunk-ECYKTK4E.js";
import {
  ForwardRef$$,
  ForwardRef$2H,
  ForwardRef$3L,
  ForwardRef$4L,
  ForwardRef$4b,
  ForwardRef$5,
  ForwardRef$5l
} from "./chunk-UECOSIBE.js";
import {
  require_jsx_runtime
} from "./chunk-LMPM4PM5.js";
import {
  require_react
} from "./chunk-D3I3COXH.js";
import {
  __commonJS,
  __publicField,
  __toESM
} from "./chunk-LK32TJAX.js";

// node_modules/lodash/isNull.js
var require_isNull = __commonJS({
  "node_modules/lodash/isNull.js"(exports2, module) {
    function isNull2(value) {
      return value === null;
    }
    module.exports = isNull2;
  }
});

// node_modules/lodash/isNumber.js
var require_isNumber = __commonJS({
  "node_modules/lodash/isNumber.js"(exports2, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var numberTag = "[object Number]";
    function isNumber2(value) {
      return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
    }
    module.exports = isNumber2;
  }
});

// node_modules/showdown/dist/showdown.js
var require_showdown = __commonJS({
  "node_modules/showdown/dist/showdown.js"(exports2, module) {
    (function() {
      function getDefaultOpts(simple) {
        "use strict";
        var defaultOptions2 = {
          omitExtraWLInCodeBlocks: {
            defaultValue: false,
            describe: "Omit the default extra whiteline added to code blocks",
            type: "boolean"
          },
          noHeaderId: {
            defaultValue: false,
            describe: "Turn on/off generated header id",
            type: "boolean"
          },
          prefixHeaderId: {
            defaultValue: false,
            describe: "Add a prefix to the generated header ids. Passing a string will prefix that string to the header id. Setting to true will add a generic 'section-' prefix",
            type: "string"
          },
          rawPrefixHeaderId: {
            defaultValue: false,
            describe: 'Setting this option to true will prevent showdown from modifying the prefix. This might result in malformed IDs (if, for instance, the " char is used in the prefix)',
            type: "boolean"
          },
          ghCompatibleHeaderId: {
            defaultValue: false,
            describe: "Generate header ids compatible with github style (spaces are replaced with dashes, a bunch of non alphanumeric chars are removed)",
            type: "boolean"
          },
          rawHeaderId: {
            defaultValue: false,
            describe: `Remove only spaces, ' and " from generated header ids (including prefixes), replacing them with dashes (-). WARNING: This might result in malformed ids`,
            type: "boolean"
          },
          headerLevelStart: {
            defaultValue: false,
            describe: "The header blocks level start",
            type: "integer"
          },
          parseImgDimensions: {
            defaultValue: false,
            describe: "Turn on/off image dimension parsing",
            type: "boolean"
          },
          simplifiedAutoLink: {
            defaultValue: false,
            describe: "Turn on/off GFM autolink style",
            type: "boolean"
          },
          excludeTrailingPunctuationFromURLs: {
            defaultValue: false,
            describe: "Excludes trailing punctuation from links generated with autoLinking",
            type: "boolean"
          },
          literalMidWordUnderscores: {
            defaultValue: false,
            describe: "Parse midword underscores as literal underscores",
            type: "boolean"
          },
          literalMidWordAsterisks: {
            defaultValue: false,
            describe: "Parse midword asterisks as literal asterisks",
            type: "boolean"
          },
          strikethrough: {
            defaultValue: false,
            describe: "Turn on/off strikethrough support",
            type: "boolean"
          },
          tables: {
            defaultValue: false,
            describe: "Turn on/off tables support",
            type: "boolean"
          },
          tablesHeaderId: {
            defaultValue: false,
            describe: "Add an id to table headers",
            type: "boolean"
          },
          ghCodeBlocks: {
            defaultValue: true,
            describe: "Turn on/off GFM fenced code blocks support",
            type: "boolean"
          },
          tasklists: {
            defaultValue: false,
            describe: "Turn on/off GFM tasklist support",
            type: "boolean"
          },
          smoothLivePreview: {
            defaultValue: false,
            describe: "Prevents weird effects in live previews due to incomplete input",
            type: "boolean"
          },
          smartIndentationFix: {
            defaultValue: false,
            describe: "Tries to smartly fix indentation in es6 strings",
            type: "boolean"
          },
          disableForced4SpacesIndentedSublists: {
            defaultValue: false,
            describe: "Disables the requirement of indenting nested sublists by 4 spaces",
            type: "boolean"
          },
          simpleLineBreaks: {
            defaultValue: false,
            describe: "Parses simple line breaks as <br> (GFM Style)",
            type: "boolean"
          },
          requireSpaceBeforeHeadingText: {
            defaultValue: false,
            describe: "Makes adding a space between `#` and the header text mandatory (GFM Style)",
            type: "boolean"
          },
          ghMentions: {
            defaultValue: false,
            describe: "Enables github @mentions",
            type: "boolean"
          },
          ghMentionsLink: {
            defaultValue: "https://github.com/{u}",
            describe: "Changes the link generated by @mentions. Only applies if ghMentions option is enabled.",
            type: "string"
          },
          encodeEmails: {
            defaultValue: true,
            describe: "Encode e-mail addresses through the use of Character Entities, transforming ASCII e-mail addresses into its equivalent decimal entities",
            type: "boolean"
          },
          openLinksInNewWindow: {
            defaultValue: false,
            describe: "Open all links in new windows",
            type: "boolean"
          },
          backslashEscapesHTMLTags: {
            defaultValue: false,
            describe: "Support for HTML Tag escaping. ex: <div>foo</div>",
            type: "boolean"
          },
          emoji: {
            defaultValue: false,
            describe: "Enable emoji support. Ex: `this is a :smile: emoji`",
            type: "boolean"
          },
          underline: {
            defaultValue: false,
            describe: "Enable support for underline. Syntax is double or triple underscores: `__underline word__`. With this option enabled, underscores no longer parses into `<em>` and `<strong>`",
            type: "boolean"
          },
          ellipsis: {
            defaultValue: true,
            describe: "Replaces three dots with the ellipsis unicode character",
            type: "boolean"
          },
          completeHTMLDocument: {
            defaultValue: false,
            describe: "Outputs a complete html document, including `<html>`, `<head>` and `<body>` tags",
            type: "boolean"
          },
          metadata: {
            defaultValue: false,
            describe: "Enable support for document metadata (defined at the top of the document between `«««` and `»»»` or between `---` and `---`).",
            type: "boolean"
          },
          splitAdjacentBlockquotes: {
            defaultValue: false,
            describe: "Split adjacent blockquote blocks",
            type: "boolean"
          }
        };
        if (simple === false) {
          return JSON.parse(JSON.stringify(defaultOptions2));
        }
        var ret = {};
        for (var opt in defaultOptions2) {
          if (defaultOptions2.hasOwnProperty(opt)) {
            ret[opt] = defaultOptions2[opt].defaultValue;
          }
        }
        return ret;
      }
      function allOptionsOn() {
        "use strict";
        var options = getDefaultOpts(true), ret = {};
        for (var opt in options) {
          if (options.hasOwnProperty(opt)) {
            ret[opt] = true;
          }
        }
        return ret;
      }
      var showdown2 = {}, parsers2 = {}, extensions = {}, globalOptions = getDefaultOpts(true), setFlavor = "vanilla", flavor = {
        github: {
          omitExtraWLInCodeBlocks: true,
          simplifiedAutoLink: true,
          excludeTrailingPunctuationFromURLs: true,
          literalMidWordUnderscores: true,
          strikethrough: true,
          tables: true,
          tablesHeaderId: true,
          ghCodeBlocks: true,
          tasklists: true,
          disableForced4SpacesIndentedSublists: true,
          simpleLineBreaks: true,
          requireSpaceBeforeHeadingText: true,
          ghCompatibleHeaderId: true,
          ghMentions: true,
          backslashEscapesHTMLTags: true,
          emoji: true,
          splitAdjacentBlockquotes: true
        },
        original: {
          noHeaderId: true,
          ghCodeBlocks: false
        },
        ghost: {
          omitExtraWLInCodeBlocks: true,
          parseImgDimensions: true,
          simplifiedAutoLink: true,
          excludeTrailingPunctuationFromURLs: true,
          literalMidWordUnderscores: true,
          strikethrough: true,
          tables: true,
          tablesHeaderId: true,
          ghCodeBlocks: true,
          tasklists: true,
          smoothLivePreview: true,
          simpleLineBreaks: true,
          requireSpaceBeforeHeadingText: true,
          ghMentions: false,
          encodeEmails: true
        },
        vanilla: getDefaultOpts(true),
        allOn: allOptionsOn()
      };
      showdown2.helper = {};
      showdown2.extensions = {};
      showdown2.setOption = function(key, value) {
        "use strict";
        globalOptions[key] = value;
        return this;
      };
      showdown2.getOption = function(key) {
        "use strict";
        return globalOptions[key];
      };
      showdown2.getOptions = function() {
        "use strict";
        return globalOptions;
      };
      showdown2.resetOptions = function() {
        "use strict";
        globalOptions = getDefaultOpts(true);
      };
      showdown2.setFlavor = function(name2) {
        "use strict";
        if (!flavor.hasOwnProperty(name2)) {
          throw Error(name2 + " flavor was not found");
        }
        showdown2.resetOptions();
        var preset = flavor[name2];
        setFlavor = name2;
        for (var option in preset) {
          if (preset.hasOwnProperty(option)) {
            globalOptions[option] = preset[option];
          }
        }
      };
      showdown2.getFlavor = function() {
        "use strict";
        return setFlavor;
      };
      showdown2.getFlavorOptions = function(name2) {
        "use strict";
        if (flavor.hasOwnProperty(name2)) {
          return flavor[name2];
        }
      };
      showdown2.getDefaultOptions = function(simple) {
        "use strict";
        return getDefaultOpts(simple);
      };
      showdown2.subParser = function(name2, func) {
        "use strict";
        if (showdown2.helper.isString(name2)) {
          if (typeof func !== "undefined") {
            parsers2[name2] = func;
          } else {
            if (parsers2.hasOwnProperty(name2)) {
              return parsers2[name2];
            } else {
              throw Error("SubParser named " + name2 + " not registered!");
            }
          }
        }
      };
      showdown2.extension = function(name2, ext) {
        "use strict";
        if (!showdown2.helper.isString(name2)) {
          throw Error("Extension 'name' must be a string");
        }
        name2 = showdown2.helper.stdExtName(name2);
        if (showdown2.helper.isUndefined(ext)) {
          if (!extensions.hasOwnProperty(name2)) {
            throw Error("Extension named " + name2 + " is not registered!");
          }
          return extensions[name2];
        } else {
          if (typeof ext === "function") {
            ext = ext();
          }
          if (!showdown2.helper.isArray(ext)) {
            ext = [ext];
          }
          var validExtension = validate(ext, name2);
          if (validExtension.valid) {
            extensions[name2] = ext;
          } else {
            throw Error(validExtension.error);
          }
        }
      };
      showdown2.getAllExtensions = function() {
        "use strict";
        return extensions;
      };
      showdown2.removeExtension = function(name2) {
        "use strict";
        delete extensions[name2];
      };
      showdown2.resetExtensions = function() {
        "use strict";
        extensions = {};
      };
      function validate(extension, name2) {
        "use strict";
        var errMsg = name2 ? "Error in " + name2 + " extension->" : "Error in unnamed extension", ret = {
          valid: true,
          error: ""
        };
        if (!showdown2.helper.isArray(extension)) {
          extension = [extension];
        }
        for (var i = 0; i < extension.length; ++i) {
          var baseMsg = errMsg + " sub-extension " + i + ": ", ext = extension[i];
          if (typeof ext !== "object") {
            ret.valid = false;
            ret.error = baseMsg + "must be an object, but " + typeof ext + " given";
            return ret;
          }
          if (!showdown2.helper.isString(ext.type)) {
            ret.valid = false;
            ret.error = baseMsg + 'property "type" must be a string, but ' + typeof ext.type + " given";
            return ret;
          }
          var type2 = ext.type = ext.type.toLowerCase();
          if (type2 === "language") {
            type2 = ext.type = "lang";
          }
          if (type2 === "html") {
            type2 = ext.type = "output";
          }
          if (type2 !== "lang" && type2 !== "output" && type2 !== "listener") {
            ret.valid = false;
            ret.error = baseMsg + "type " + type2 + ' is not recognized. Valid values: "lang/language", "output/html" or "listener"';
            return ret;
          }
          if (type2 === "listener") {
            if (showdown2.helper.isUndefined(ext.listeners)) {
              ret.valid = false;
              ret.error = baseMsg + '. Extensions of type "listener" must have a property called "listeners"';
              return ret;
            }
          } else {
            if (showdown2.helper.isUndefined(ext.filter) && showdown2.helper.isUndefined(ext.regex)) {
              ret.valid = false;
              ret.error = baseMsg + type2 + ' extensions must define either a "regex" property or a "filter" method';
              return ret;
            }
          }
          if (ext.listeners) {
            if (typeof ext.listeners !== "object") {
              ret.valid = false;
              ret.error = baseMsg + '"listeners" property must be an object but ' + typeof ext.listeners + " given";
              return ret;
            }
            for (var ln in ext.listeners) {
              if (ext.listeners.hasOwnProperty(ln)) {
                if (typeof ext.listeners[ln] !== "function") {
                  ret.valid = false;
                  ret.error = baseMsg + '"listeners" property must be an hash of [event name]: [callback]. listeners.' + ln + " must be a function but " + typeof ext.listeners[ln] + " given";
                  return ret;
                }
              }
            }
          }
          if (ext.filter) {
            if (typeof ext.filter !== "function") {
              ret.valid = false;
              ret.error = baseMsg + '"filter" must be a function, but ' + typeof ext.filter + " given";
              return ret;
            }
          } else if (ext.regex) {
            if (showdown2.helper.isString(ext.regex)) {
              ext.regex = new RegExp(ext.regex, "g");
            }
            if (!(ext.regex instanceof RegExp)) {
              ret.valid = false;
              ret.error = baseMsg + '"regex" property must either be a string or a RegExp object, but ' + typeof ext.regex + " given";
              return ret;
            }
            if (showdown2.helper.isUndefined(ext.replace)) {
              ret.valid = false;
              ret.error = baseMsg + '"regex" extensions must implement a replace string or function';
              return ret;
            }
          }
        }
        return ret;
      }
      showdown2.validateExtension = function(ext) {
        "use strict";
        var validateExtension = validate(ext, null);
        if (!validateExtension.valid) {
          console.warn(validateExtension.error);
          return false;
        }
        return true;
      };
      if (!showdown2.hasOwnProperty("helper")) {
        showdown2.helper = {};
      }
      showdown2.helper.isString = function(a) {
        "use strict";
        return typeof a === "string" || a instanceof String;
      };
      showdown2.helper.isFunction = function(a) {
        "use strict";
        var getType = {};
        return a && getType.toString.call(a) === "[object Function]";
      };
      showdown2.helper.isArray = function(a) {
        "use strict";
        return Array.isArray(a);
      };
      showdown2.helper.isUndefined = function(value) {
        "use strict";
        return typeof value === "undefined";
      };
      showdown2.helper.forEach = function(obj, callback) {
        "use strict";
        if (showdown2.helper.isUndefined(obj)) {
          throw new Error("obj param is required");
        }
        if (showdown2.helper.isUndefined(callback)) {
          throw new Error("callback param is required");
        }
        if (!showdown2.helper.isFunction(callback)) {
          throw new Error("callback param must be a function/closure");
        }
        if (typeof obj.forEach === "function") {
          obj.forEach(callback);
        } else if (showdown2.helper.isArray(obj)) {
          for (var i = 0; i < obj.length; i++) {
            callback(obj[i], i, obj);
          }
        } else if (typeof obj === "object") {
          for (var prop in obj) {
            if (obj.hasOwnProperty(prop)) {
              callback(obj[prop], prop, obj);
            }
          }
        } else {
          throw new Error("obj does not seem to be an array or an iterable object");
        }
      };
      showdown2.helper.stdExtName = function(s) {
        "use strict";
        return s.replace(/[_?*+\/\\.^-]/g, "").replace(/\s/g, "").toLowerCase();
      };
      function escapeCharactersCallback(wholeMatch, m1) {
        "use strict";
        var charCodeToEscape = m1.charCodeAt(0);
        return "¨E" + charCodeToEscape + "E";
      }
      showdown2.helper.escapeCharactersCallback = escapeCharactersCallback;
      showdown2.helper.escapeCharacters = function(text, charsToEscape, afterBackslash) {
        "use strict";
        var regexString = "([" + charsToEscape.replace(/([\[\]\\])/g, "\\$1") + "])";
        if (afterBackslash) {
          regexString = "\\\\" + regexString;
        }
        var regex = new RegExp(regexString, "g");
        text = text.replace(regex, escapeCharactersCallback);
        return text;
      };
      showdown2.helper.unescapeHTMLEntities = function(txt) {
        "use strict";
        return txt.replace(/&quot;/g, '"').replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&");
      };
      var rgxFindMatchPos = function(str, left, right, flags) {
        "use strict";
        var f = flags || "", g = f.indexOf("g") > -1, x = new RegExp(left + "|" + right, "g" + f.replace(/g/g, "")), l = new RegExp(left, f.replace(/g/g, "")), pos = [], t, s, m, start, end;
        do {
          t = 0;
          while (m = x.exec(str)) {
            if (l.test(m[0])) {
              if (!t++) {
                s = x.lastIndex;
                start = s - m[0].length;
              }
            } else if (t) {
              if (!--t) {
                end = m.index + m[0].length;
                var obj = {
                  left: { start, end: s },
                  match: { start: s, end: m.index },
                  right: { start: m.index, end },
                  wholeMatch: { start, end }
                };
                pos.push(obj);
                if (!g) {
                  return pos;
                }
              }
            }
          }
        } while (t && (x.lastIndex = s));
        return pos;
      };
      showdown2.helper.matchRecursiveRegExp = function(str, left, right, flags) {
        "use strict";
        var matchPos = rgxFindMatchPos(str, left, right, flags), results = [];
        for (var i = 0; i < matchPos.length; ++i) {
          results.push([
            str.slice(matchPos[i].wholeMatch.start, matchPos[i].wholeMatch.end),
            str.slice(matchPos[i].match.start, matchPos[i].match.end),
            str.slice(matchPos[i].left.start, matchPos[i].left.end),
            str.slice(matchPos[i].right.start, matchPos[i].right.end)
          ]);
        }
        return results;
      };
      showdown2.helper.replaceRecursiveRegExp = function(str, replacement, left, right, flags) {
        "use strict";
        if (!showdown2.helper.isFunction(replacement)) {
          var repStr = replacement;
          replacement = function() {
            return repStr;
          };
        }
        var matchPos = rgxFindMatchPos(str, left, right, flags), finalStr = str, lng = matchPos.length;
        if (lng > 0) {
          var bits = [];
          if (matchPos[0].wholeMatch.start !== 0) {
            bits.push(str.slice(0, matchPos[0].wholeMatch.start));
          }
          for (var i = 0; i < lng; ++i) {
            bits.push(
              replacement(
                str.slice(matchPos[i].wholeMatch.start, matchPos[i].wholeMatch.end),
                str.slice(matchPos[i].match.start, matchPos[i].match.end),
                str.slice(matchPos[i].left.start, matchPos[i].left.end),
                str.slice(matchPos[i].right.start, matchPos[i].right.end)
              )
            );
            if (i < lng - 1) {
              bits.push(str.slice(matchPos[i].wholeMatch.end, matchPos[i + 1].wholeMatch.start));
            }
          }
          if (matchPos[lng - 1].wholeMatch.end < str.length) {
            bits.push(str.slice(matchPos[lng - 1].wholeMatch.end));
          }
          finalStr = bits.join("");
        }
        return finalStr;
      };
      showdown2.helper.regexIndexOf = function(str, regex, fromIndex) {
        "use strict";
        if (!showdown2.helper.isString(str)) {
          throw "InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string";
        }
        if (regex instanceof RegExp === false) {
          throw "InvalidArgumentError: second parameter of showdown.helper.regexIndexOf function must be an instance of RegExp";
        }
        var indexOf = str.substring(fromIndex || 0).search(regex);
        return indexOf >= 0 ? indexOf + (fromIndex || 0) : indexOf;
      };
      showdown2.helper.splitAtIndex = function(str, index2) {
        "use strict";
        if (!showdown2.helper.isString(str)) {
          throw "InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string";
        }
        return [str.substring(0, index2), str.substring(index2)];
      };
      showdown2.helper.encodeEmailAddress = function(mail) {
        "use strict";
        var encode = [
          function(ch) {
            return "&#" + ch.charCodeAt(0) + ";";
          },
          function(ch) {
            return "&#x" + ch.charCodeAt(0).toString(16) + ";";
          },
          function(ch) {
            return ch;
          }
        ];
        mail = mail.replace(/./g, function(ch) {
          if (ch === "@") {
            ch = encode[Math.floor(Math.random() * 2)](ch);
          } else {
            var r = Math.random();
            ch = r > 0.9 ? encode[2](ch) : r > 0.45 ? encode[1](ch) : encode[0](ch);
          }
          return ch;
        });
        return mail;
      };
      showdown2.helper.padEnd = function padEnd(str, targetLength, padString) {
        "use strict";
        targetLength = targetLength >> 0;
        padString = String(padString || " ");
        if (str.length > targetLength) {
          return String(str);
        } else {
          targetLength = targetLength - str.length;
          if (targetLength > padString.length) {
            padString += padString.repeat(targetLength / padString.length);
          }
          return String(str) + padString.slice(0, targetLength);
        }
      };
      if (typeof console === "undefined") {
        console = {
          warn: function(msg) {
            "use strict";
            alert(msg);
          },
          log: function(msg) {
            "use strict";
            alert(msg);
          },
          error: function(msg) {
            "use strict";
            throw msg;
          }
        };
      }
      showdown2.helper.regexes = {
        asteriskDashAndColon: /([*_:~])/g
      };
      showdown2.helper.emojis = {
        "+1": "👍",
        "-1": "👎",
        "100": "💯",
        "1234": "🔢",
        "1st_place_medal": "🥇",
        "2nd_place_medal": "🥈",
        "3rd_place_medal": "🥉",
        "8ball": "🎱",
        "a": "🅰️",
        "ab": "🆎",
        "abc": "🔤",
        "abcd": "🔡",
        "accept": "🉑",
        "aerial_tramway": "🚡",
        "airplane": "✈️",
        "alarm_clock": "⏰",
        "alembic": "⚗️",
        "alien": "👽",
        "ambulance": "🚑",
        "amphora": "🏺",
        "anchor": "⚓️",
        "angel": "👼",
        "anger": "💢",
        "angry": "😠",
        "anguished": "😧",
        "ant": "🐜",
        "apple": "🍎",
        "aquarius": "♒️",
        "aries": "♈️",
        "arrow_backward": "◀️",
        "arrow_double_down": "⏬",
        "arrow_double_up": "⏫",
        "arrow_down": "⬇️",
        "arrow_down_small": "🔽",
        "arrow_forward": "▶️",
        "arrow_heading_down": "⤵️",
        "arrow_heading_up": "⤴️",
        "arrow_left": "⬅️",
        "arrow_lower_left": "↙️",
        "arrow_lower_right": "↘️",
        "arrow_right": "➡️",
        "arrow_right_hook": "↪️",
        "arrow_up": "⬆️",
        "arrow_up_down": "↕️",
        "arrow_up_small": "🔼",
        "arrow_upper_left": "↖️",
        "arrow_upper_right": "↗️",
        "arrows_clockwise": "🔃",
        "arrows_counterclockwise": "🔄",
        "art": "🎨",
        "articulated_lorry": "🚛",
        "artificial_satellite": "🛰",
        "astonished": "😲",
        "athletic_shoe": "👟",
        "atm": "🏧",
        "atom_symbol": "⚛️",
        "avocado": "🥑",
        "b": "🅱️",
        "baby": "👶",
        "baby_bottle": "🍼",
        "baby_chick": "🐤",
        "baby_symbol": "🚼",
        "back": "🔙",
        "bacon": "🥓",
        "badminton": "🏸",
        "baggage_claim": "🛄",
        "baguette_bread": "🥖",
        "balance_scale": "⚖️",
        "balloon": "🎈",
        "ballot_box": "🗳",
        "ballot_box_with_check": "☑️",
        "bamboo": "🎍",
        "banana": "🍌",
        "bangbang": "‼️",
        "bank": "🏦",
        "bar_chart": "📊",
        "barber": "💈",
        "baseball": "⚾️",
        "basketball": "🏀",
        "basketball_man": "⛹️",
        "basketball_woman": "⛹️&zwj;♀️",
        "bat": "🦇",
        "bath": "🛀",
        "bathtub": "🛁",
        "battery": "🔋",
        "beach_umbrella": "🏖",
        "bear": "🐻",
        "bed": "🛏",
        "bee": "🐝",
        "beer": "🍺",
        "beers": "🍻",
        "beetle": "🐞",
        "beginner": "🔰",
        "bell": "🔔",
        "bellhop_bell": "🛎",
        "bento": "🍱",
        "biking_man": "🚴",
        "bike": "🚲",
        "biking_woman": "🚴&zwj;♀️",
        "bikini": "👙",
        "biohazard": "☣️",
        "bird": "🐦",
        "birthday": "🎂",
        "black_circle": "⚫️",
        "black_flag": "🏴",
        "black_heart": "🖤",
        "black_joker": "🃏",
        "black_large_square": "⬛️",
        "black_medium_small_square": "◾️",
        "black_medium_square": "◼️",
        "black_nib": "✒️",
        "black_small_square": "▪️",
        "black_square_button": "🔲",
        "blonde_man": "👱",
        "blonde_woman": "👱&zwj;♀️",
        "blossom": "🌼",
        "blowfish": "🐡",
        "blue_book": "📘",
        "blue_car": "🚙",
        "blue_heart": "💙",
        "blush": "😊",
        "boar": "🐗",
        "boat": "⛵️",
        "bomb": "💣",
        "book": "📖",
        "bookmark": "🔖",
        "bookmark_tabs": "📑",
        "books": "📚",
        "boom": "💥",
        "boot": "👢",
        "bouquet": "💐",
        "bowing_man": "🙇",
        "bow_and_arrow": "🏹",
        "bowing_woman": "🙇&zwj;♀️",
        "bowling": "🎳",
        "boxing_glove": "🥊",
        "boy": "👦",
        "bread": "🍞",
        "bride_with_veil": "👰",
        "bridge_at_night": "🌉",
        "briefcase": "💼",
        "broken_heart": "💔",
        "bug": "🐛",
        "building_construction": "🏗",
        "bulb": "💡",
        "bullettrain_front": "🚅",
        "bullettrain_side": "🚄",
        "burrito": "🌯",
        "bus": "🚌",
        "business_suit_levitating": "🕴",
        "busstop": "🚏",
        "bust_in_silhouette": "👤",
        "busts_in_silhouette": "👥",
        "butterfly": "🦋",
        "cactus": "🌵",
        "cake": "🍰",
        "calendar": "📆",
        "call_me_hand": "🤙",
        "calling": "📲",
        "camel": "🐫",
        "camera": "📷",
        "camera_flash": "📸",
        "camping": "🏕",
        "cancer": "♋️",
        "candle": "🕯",
        "candy": "🍬",
        "canoe": "🛶",
        "capital_abcd": "🔠",
        "capricorn": "♑️",
        "car": "🚗",
        "card_file_box": "🗃",
        "card_index": "📇",
        "card_index_dividers": "🗂",
        "carousel_horse": "🎠",
        "carrot": "🥕",
        "cat": "🐱",
        "cat2": "🐈",
        "cd": "💿",
        "chains": "⛓",
        "champagne": "🍾",
        "chart": "💹",
        "chart_with_downwards_trend": "📉",
        "chart_with_upwards_trend": "📈",
        "checkered_flag": "🏁",
        "cheese": "🧀",
        "cherries": "🍒",
        "cherry_blossom": "🌸",
        "chestnut": "🌰",
        "chicken": "🐔",
        "children_crossing": "🚸",
        "chipmunk": "🐿",
        "chocolate_bar": "🍫",
        "christmas_tree": "🎄",
        "church": "⛪️",
        "cinema": "🎦",
        "circus_tent": "🎪",
        "city_sunrise": "🌇",
        "city_sunset": "🌆",
        "cityscape": "🏙",
        "cl": "🆑",
        "clamp": "🗜",
        "clap": "👏",
        "clapper": "🎬",
        "classical_building": "🏛",
        "clinking_glasses": "🥂",
        "clipboard": "📋",
        "clock1": "🕐",
        "clock10": "🕙",
        "clock1030": "🕥",
        "clock11": "🕚",
        "clock1130": "🕦",
        "clock12": "🕛",
        "clock1230": "🕧",
        "clock130": "🕜",
        "clock2": "🕑",
        "clock230": "🕝",
        "clock3": "🕒",
        "clock330": "🕞",
        "clock4": "🕓",
        "clock430": "🕟",
        "clock5": "🕔",
        "clock530": "🕠",
        "clock6": "🕕",
        "clock630": "🕡",
        "clock7": "🕖",
        "clock730": "🕢",
        "clock8": "🕗",
        "clock830": "🕣",
        "clock9": "🕘",
        "clock930": "🕤",
        "closed_book": "📕",
        "closed_lock_with_key": "🔐",
        "closed_umbrella": "🌂",
        "cloud": "☁️",
        "cloud_with_lightning": "🌩",
        "cloud_with_lightning_and_rain": "⛈",
        "cloud_with_rain": "🌧",
        "cloud_with_snow": "🌨",
        "clown_face": "🤡",
        "clubs": "♣️",
        "cocktail": "🍸",
        "coffee": "☕️",
        "coffin": "⚰️",
        "cold_sweat": "😰",
        "comet": "☄️",
        "computer": "💻",
        "computer_mouse": "🖱",
        "confetti_ball": "🎊",
        "confounded": "😖",
        "confused": "😕",
        "congratulations": "㊗️",
        "construction": "🚧",
        "construction_worker_man": "👷",
        "construction_worker_woman": "👷&zwj;♀️",
        "control_knobs": "🎛",
        "convenience_store": "🏪",
        "cookie": "🍪",
        "cool": "🆒",
        "policeman": "👮",
        "copyright": "©️",
        "corn": "🌽",
        "couch_and_lamp": "🛋",
        "couple": "👫",
        "couple_with_heart_woman_man": "💑",
        "couple_with_heart_man_man": "👨&zwj;❤️&zwj;👨",
        "couple_with_heart_woman_woman": "👩&zwj;❤️&zwj;👩",
        "couplekiss_man_man": "👨&zwj;❤️&zwj;💋&zwj;👨",
        "couplekiss_man_woman": "💏",
        "couplekiss_woman_woman": "👩&zwj;❤️&zwj;💋&zwj;👩",
        "cow": "🐮",
        "cow2": "🐄",
        "cowboy_hat_face": "🤠",
        "crab": "🦀",
        "crayon": "🖍",
        "credit_card": "💳",
        "crescent_moon": "🌙",
        "cricket": "🏏",
        "crocodile": "🐊",
        "croissant": "🥐",
        "crossed_fingers": "🤞",
        "crossed_flags": "🎌",
        "crossed_swords": "⚔️",
        "crown": "👑",
        "cry": "😢",
        "crying_cat_face": "😿",
        "crystal_ball": "🔮",
        "cucumber": "🥒",
        "cupid": "💘",
        "curly_loop": "➰",
        "currency_exchange": "💱",
        "curry": "🍛",
        "custard": "🍮",
        "customs": "🛃",
        "cyclone": "🌀",
        "dagger": "🗡",
        "dancer": "💃",
        "dancing_women": "👯",
        "dancing_men": "👯&zwj;♂️",
        "dango": "🍡",
        "dark_sunglasses": "🕶",
        "dart": "🎯",
        "dash": "💨",
        "date": "📅",
        "deciduous_tree": "🌳",
        "deer": "🦌",
        "department_store": "🏬",
        "derelict_house": "🏚",
        "desert": "🏜",
        "desert_island": "🏝",
        "desktop_computer": "🖥",
        "male_detective": "🕵️",
        "diamond_shape_with_a_dot_inside": "💠",
        "diamonds": "♦️",
        "disappointed": "😞",
        "disappointed_relieved": "😥",
        "dizzy": "💫",
        "dizzy_face": "😵",
        "do_not_litter": "🚯",
        "dog": "🐶",
        "dog2": "🐕",
        "dollar": "💵",
        "dolls": "🎎",
        "dolphin": "🐬",
        "door": "🚪",
        "doughnut": "🍩",
        "dove": "🕊",
        "dragon": "🐉",
        "dragon_face": "🐲",
        "dress": "👗",
        "dromedary_camel": "🐪",
        "drooling_face": "🤤",
        "droplet": "💧",
        "drum": "🥁",
        "duck": "🦆",
        "dvd": "📀",
        "e-mail": "📧",
        "eagle": "🦅",
        "ear": "👂",
        "ear_of_rice": "🌾",
        "earth_africa": "🌍",
        "earth_americas": "🌎",
        "earth_asia": "🌏",
        "egg": "🥚",
        "eggplant": "🍆",
        "eight_pointed_black_star": "✴️",
        "eight_spoked_asterisk": "✳️",
        "electric_plug": "🔌",
        "elephant": "🐘",
        "email": "✉️",
        "end": "🔚",
        "envelope_with_arrow": "📩",
        "euro": "💶",
        "european_castle": "🏰",
        "european_post_office": "🏤",
        "evergreen_tree": "🌲",
        "exclamation": "❗️",
        "expressionless": "😑",
        "eye": "👁",
        "eye_speech_bubble": "👁&zwj;🗨",
        "eyeglasses": "👓",
        "eyes": "👀",
        "face_with_head_bandage": "🤕",
        "face_with_thermometer": "🤒",
        "fist_oncoming": "👊",
        "factory": "🏭",
        "fallen_leaf": "🍂",
        "family_man_woman_boy": "👪",
        "family_man_boy": "👨&zwj;👦",
        "family_man_boy_boy": "👨&zwj;👦&zwj;👦",
        "family_man_girl": "👨&zwj;👧",
        "family_man_girl_boy": "👨&zwj;👧&zwj;👦",
        "family_man_girl_girl": "👨&zwj;👧&zwj;👧",
        "family_man_man_boy": "👨&zwj;👨&zwj;👦",
        "family_man_man_boy_boy": "👨&zwj;👨&zwj;👦&zwj;👦",
        "family_man_man_girl": "👨&zwj;👨&zwj;👧",
        "family_man_man_girl_boy": "👨&zwj;👨&zwj;👧&zwj;👦",
        "family_man_man_girl_girl": "👨&zwj;👨&zwj;👧&zwj;👧",
        "family_man_woman_boy_boy": "👨&zwj;👩&zwj;👦&zwj;👦",
        "family_man_woman_girl": "👨&zwj;👩&zwj;👧",
        "family_man_woman_girl_boy": "👨&zwj;👩&zwj;👧&zwj;👦",
        "family_man_woman_girl_girl": "👨&zwj;👩&zwj;👧&zwj;👧",
        "family_woman_boy": "👩&zwj;👦",
        "family_woman_boy_boy": "👩&zwj;👦&zwj;👦",
        "family_woman_girl": "👩&zwj;👧",
        "family_woman_girl_boy": "👩&zwj;👧&zwj;👦",
        "family_woman_girl_girl": "👩&zwj;👧&zwj;👧",
        "family_woman_woman_boy": "👩&zwj;👩&zwj;👦",
        "family_woman_woman_boy_boy": "👩&zwj;👩&zwj;👦&zwj;👦",
        "family_woman_woman_girl": "👩&zwj;👩&zwj;👧",
        "family_woman_woman_girl_boy": "👩&zwj;👩&zwj;👧&zwj;👦",
        "family_woman_woman_girl_girl": "👩&zwj;👩&zwj;👧&zwj;👧",
        "fast_forward": "⏩",
        "fax": "📠",
        "fearful": "😨",
        "feet": "🐾",
        "female_detective": "🕵️&zwj;♀️",
        "ferris_wheel": "🎡",
        "ferry": "⛴",
        "field_hockey": "🏑",
        "file_cabinet": "🗄",
        "file_folder": "📁",
        "film_projector": "📽",
        "film_strip": "🎞",
        "fire": "🔥",
        "fire_engine": "🚒",
        "fireworks": "🎆",
        "first_quarter_moon": "🌓",
        "first_quarter_moon_with_face": "🌛",
        "fish": "🐟",
        "fish_cake": "🍥",
        "fishing_pole_and_fish": "🎣",
        "fist_raised": "✊",
        "fist_left": "🤛",
        "fist_right": "🤜",
        "flags": "🎏",
        "flashlight": "🔦",
        "fleur_de_lis": "⚜️",
        "flight_arrival": "🛬",
        "flight_departure": "🛫",
        "floppy_disk": "💾",
        "flower_playing_cards": "🎴",
        "flushed": "😳",
        "fog": "🌫",
        "foggy": "🌁",
        "football": "🏈",
        "footprints": "👣",
        "fork_and_knife": "🍴",
        "fountain": "⛲️",
        "fountain_pen": "🖋",
        "four_leaf_clover": "🍀",
        "fox_face": "🦊",
        "framed_picture": "🖼",
        "free": "🆓",
        "fried_egg": "🍳",
        "fried_shrimp": "🍤",
        "fries": "🍟",
        "frog": "🐸",
        "frowning": "😦",
        "frowning_face": "☹️",
        "frowning_man": "🙍&zwj;♂️",
        "frowning_woman": "🙍",
        "middle_finger": "🖕",
        "fuelpump": "⛽️",
        "full_moon": "🌕",
        "full_moon_with_face": "🌝",
        "funeral_urn": "⚱️",
        "game_die": "🎲",
        "gear": "⚙️",
        "gem": "💎",
        "gemini": "♊️",
        "ghost": "👻",
        "gift": "🎁",
        "gift_heart": "💝",
        "girl": "👧",
        "globe_with_meridians": "🌐",
        "goal_net": "🥅",
        "goat": "🐐",
        "golf": "⛳️",
        "golfing_man": "🏌️",
        "golfing_woman": "🏌️&zwj;♀️",
        "gorilla": "🦍",
        "grapes": "🍇",
        "green_apple": "🍏",
        "green_book": "📗",
        "green_heart": "💚",
        "green_salad": "🥗",
        "grey_exclamation": "❕",
        "grey_question": "❔",
        "grimacing": "😬",
        "grin": "😁",
        "grinning": "😀",
        "guardsman": "💂",
        "guardswoman": "💂&zwj;♀️",
        "guitar": "🎸",
        "gun": "🔫",
        "haircut_woman": "💇",
        "haircut_man": "💇&zwj;♂️",
        "hamburger": "🍔",
        "hammer": "🔨",
        "hammer_and_pick": "⚒",
        "hammer_and_wrench": "🛠",
        "hamster": "🐹",
        "hand": "✋",
        "handbag": "👜",
        "handshake": "🤝",
        "hankey": "💩",
        "hatched_chick": "🐥",
        "hatching_chick": "🐣",
        "headphones": "🎧",
        "hear_no_evil": "🙉",
        "heart": "❤️",
        "heart_decoration": "💟",
        "heart_eyes": "😍",
        "heart_eyes_cat": "😻",
        "heartbeat": "💓",
        "heartpulse": "💗",
        "hearts": "♥️",
        "heavy_check_mark": "✔️",
        "heavy_division_sign": "➗",
        "heavy_dollar_sign": "💲",
        "heavy_heart_exclamation": "❣️",
        "heavy_minus_sign": "➖",
        "heavy_multiplication_x": "✖️",
        "heavy_plus_sign": "➕",
        "helicopter": "🚁",
        "herb": "🌿",
        "hibiscus": "🌺",
        "high_brightness": "🔆",
        "high_heel": "👠",
        "hocho": "🔪",
        "hole": "🕳",
        "honey_pot": "🍯",
        "horse": "🐴",
        "horse_racing": "🏇",
        "hospital": "🏥",
        "hot_pepper": "🌶",
        "hotdog": "🌭",
        "hotel": "🏨",
        "hotsprings": "♨️",
        "hourglass": "⌛️",
        "hourglass_flowing_sand": "⏳",
        "house": "🏠",
        "house_with_garden": "🏡",
        "houses": "🏘",
        "hugs": "🤗",
        "hushed": "😯",
        "ice_cream": "🍨",
        "ice_hockey": "🏒",
        "ice_skate": "⛸",
        "icecream": "🍦",
        "id": "🆔",
        "ideograph_advantage": "🉐",
        "imp": "👿",
        "inbox_tray": "📥",
        "incoming_envelope": "📨",
        "tipping_hand_woman": "💁",
        "information_source": "ℹ️",
        "innocent": "😇",
        "interrobang": "⁉️",
        "iphone": "📱",
        "izakaya_lantern": "🏮",
        "jack_o_lantern": "🎃",
        "japan": "🗾",
        "japanese_castle": "🏯",
        "japanese_goblin": "👺",
        "japanese_ogre": "👹",
        "jeans": "👖",
        "joy": "😂",
        "joy_cat": "😹",
        "joystick": "🕹",
        "kaaba": "🕋",
        "key": "🔑",
        "keyboard": "⌨️",
        "keycap_ten": "🔟",
        "kick_scooter": "🛴",
        "kimono": "👘",
        "kiss": "💋",
        "kissing": "😗",
        "kissing_cat": "😽",
        "kissing_closed_eyes": "😚",
        "kissing_heart": "😘",
        "kissing_smiling_eyes": "😙",
        "kiwi_fruit": "🥝",
        "koala": "🐨",
        "koko": "🈁",
        "label": "🏷",
        "large_blue_circle": "🔵",
        "large_blue_diamond": "🔷",
        "large_orange_diamond": "🔶",
        "last_quarter_moon": "🌗",
        "last_quarter_moon_with_face": "🌜",
        "latin_cross": "✝️",
        "laughing": "😆",
        "leaves": "🍃",
        "ledger": "📒",
        "left_luggage": "🛅",
        "left_right_arrow": "↔️",
        "leftwards_arrow_with_hook": "↩️",
        "lemon": "🍋",
        "leo": "♌️",
        "leopard": "🐆",
        "level_slider": "🎚",
        "libra": "♎️",
        "light_rail": "🚈",
        "link": "🔗",
        "lion": "🦁",
        "lips": "👄",
        "lipstick": "💄",
        "lizard": "🦎",
        "lock": "🔒",
        "lock_with_ink_pen": "🔏",
        "lollipop": "🍭",
        "loop": "➿",
        "loud_sound": "🔊",
        "loudspeaker": "📢",
        "love_hotel": "🏩",
        "love_letter": "💌",
        "low_brightness": "🔅",
        "lying_face": "🤥",
        "m": "Ⓜ️",
        "mag": "🔍",
        "mag_right": "🔎",
        "mahjong": "🀄️",
        "mailbox": "📫",
        "mailbox_closed": "📪",
        "mailbox_with_mail": "📬",
        "mailbox_with_no_mail": "📭",
        "man": "👨",
        "man_artist": "👨&zwj;🎨",
        "man_astronaut": "👨&zwj;🚀",
        "man_cartwheeling": "🤸&zwj;♂️",
        "man_cook": "👨&zwj;🍳",
        "man_dancing": "🕺",
        "man_facepalming": "🤦&zwj;♂️",
        "man_factory_worker": "👨&zwj;🏭",
        "man_farmer": "👨&zwj;🌾",
        "man_firefighter": "👨&zwj;🚒",
        "man_health_worker": "👨&zwj;⚕️",
        "man_in_tuxedo": "🤵",
        "man_judge": "👨&zwj;⚖️",
        "man_juggling": "🤹&zwj;♂️",
        "man_mechanic": "👨&zwj;🔧",
        "man_office_worker": "👨&zwj;💼",
        "man_pilot": "👨&zwj;✈️",
        "man_playing_handball": "🤾&zwj;♂️",
        "man_playing_water_polo": "🤽&zwj;♂️",
        "man_scientist": "👨&zwj;🔬",
        "man_shrugging": "🤷&zwj;♂️",
        "man_singer": "👨&zwj;🎤",
        "man_student": "👨&zwj;🎓",
        "man_teacher": "👨&zwj;🏫",
        "man_technologist": "👨&zwj;💻",
        "man_with_gua_pi_mao": "👲",
        "man_with_turban": "👳",
        "tangerine": "🍊",
        "mans_shoe": "👞",
        "mantelpiece_clock": "🕰",
        "maple_leaf": "🍁",
        "martial_arts_uniform": "🥋",
        "mask": "😷",
        "massage_woman": "💆",
        "massage_man": "💆&zwj;♂️",
        "meat_on_bone": "🍖",
        "medal_military": "🎖",
        "medal_sports": "🏅",
        "mega": "📣",
        "melon": "🍈",
        "memo": "📝",
        "men_wrestling": "🤼&zwj;♂️",
        "menorah": "🕎",
        "mens": "🚹",
        "metal": "🤘",
        "metro": "🚇",
        "microphone": "🎤",
        "microscope": "🔬",
        "milk_glass": "🥛",
        "milky_way": "🌌",
        "minibus": "🚐",
        "minidisc": "💽",
        "mobile_phone_off": "📴",
        "money_mouth_face": "🤑",
        "money_with_wings": "💸",
        "moneybag": "💰",
        "monkey": "🐒",
        "monkey_face": "🐵",
        "monorail": "🚝",
        "moon": "🌔",
        "mortar_board": "🎓",
        "mosque": "🕌",
        "motor_boat": "🛥",
        "motor_scooter": "🛵",
        "motorcycle": "🏍",
        "motorway": "🛣",
        "mount_fuji": "🗻",
        "mountain": "⛰",
        "mountain_biking_man": "🚵",
        "mountain_biking_woman": "🚵&zwj;♀️",
        "mountain_cableway": "🚠",
        "mountain_railway": "🚞",
        "mountain_snow": "🏔",
        "mouse": "🐭",
        "mouse2": "🐁",
        "movie_camera": "🎥",
        "moyai": "🗿",
        "mrs_claus": "🤶",
        "muscle": "💪",
        "mushroom": "🍄",
        "musical_keyboard": "🎹",
        "musical_note": "🎵",
        "musical_score": "🎼",
        "mute": "🔇",
        "nail_care": "💅",
        "name_badge": "📛",
        "national_park": "🏞",
        "nauseated_face": "🤢",
        "necktie": "👔",
        "negative_squared_cross_mark": "❎",
        "nerd_face": "🤓",
        "neutral_face": "😐",
        "new": "🆕",
        "new_moon": "🌑",
        "new_moon_with_face": "🌚",
        "newspaper": "📰",
        "newspaper_roll": "🗞",
        "next_track_button": "⏭",
        "ng": "🆖",
        "no_good_man": "🙅&zwj;♂️",
        "no_good_woman": "🙅",
        "night_with_stars": "🌃",
        "no_bell": "🔕",
        "no_bicycles": "🚳",
        "no_entry": "⛔️",
        "no_entry_sign": "🚫",
        "no_mobile_phones": "📵",
        "no_mouth": "😶",
        "no_pedestrians": "🚷",
        "no_smoking": "🚭",
        "non-potable_water": "🚱",
        "nose": "👃",
        "notebook": "📓",
        "notebook_with_decorative_cover": "📔",
        "notes": "🎶",
        "nut_and_bolt": "🔩",
        "o": "⭕️",
        "o2": "🅾️",
        "ocean": "🌊",
        "octopus": "🐙",
        "oden": "🍢",
        "office": "🏢",
        "oil_drum": "🛢",
        "ok": "🆗",
        "ok_hand": "👌",
        "ok_man": "🙆&zwj;♂️",
        "ok_woman": "🙆",
        "old_key": "🗝",
        "older_man": "👴",
        "older_woman": "👵",
        "om": "🕉",
        "on": "🔛",
        "oncoming_automobile": "🚘",
        "oncoming_bus": "🚍",
        "oncoming_police_car": "🚔",
        "oncoming_taxi": "🚖",
        "open_file_folder": "📂",
        "open_hands": "👐",
        "open_mouth": "😮",
        "open_umbrella": "☂️",
        "ophiuchus": "⛎",
        "orange_book": "📙",
        "orthodox_cross": "☦️",
        "outbox_tray": "📤",
        "owl": "🦉",
        "ox": "🐂",
        "package": "📦",
        "page_facing_up": "📄",
        "page_with_curl": "📃",
        "pager": "📟",
        "paintbrush": "🖌",
        "palm_tree": "🌴",
        "pancakes": "🥞",
        "panda_face": "🐼",
        "paperclip": "📎",
        "paperclips": "🖇",
        "parasol_on_ground": "⛱",
        "parking": "🅿️",
        "part_alternation_mark": "〽️",
        "partly_sunny": "⛅️",
        "passenger_ship": "🛳",
        "passport_control": "🛂",
        "pause_button": "⏸",
        "peace_symbol": "☮️",
        "peach": "🍑",
        "peanuts": "🥜",
        "pear": "🍐",
        "pen": "🖊",
        "pencil2": "✏️",
        "penguin": "🐧",
        "pensive": "😔",
        "performing_arts": "🎭",
        "persevere": "😣",
        "person_fencing": "🤺",
        "pouting_woman": "🙎",
        "phone": "☎️",
        "pick": "⛏",
        "pig": "🐷",
        "pig2": "🐖",
        "pig_nose": "🐽",
        "pill": "💊",
        "pineapple": "🍍",
        "ping_pong": "🏓",
        "pisces": "♓️",
        "pizza": "🍕",
        "place_of_worship": "🛐",
        "plate_with_cutlery": "🍽",
        "play_or_pause_button": "⏯",
        "point_down": "👇",
        "point_left": "👈",
        "point_right": "👉",
        "point_up": "☝️",
        "point_up_2": "👆",
        "police_car": "🚓",
        "policewoman": "👮&zwj;♀️",
        "poodle": "🐩",
        "popcorn": "🍿",
        "post_office": "🏣",
        "postal_horn": "📯",
        "postbox": "📮",
        "potable_water": "🚰",
        "potato": "🥔",
        "pouch": "👝",
        "poultry_leg": "🍗",
        "pound": "💷",
        "rage": "😡",
        "pouting_cat": "😾",
        "pouting_man": "🙎&zwj;♂️",
        "pray": "🙏",
        "prayer_beads": "📿",
        "pregnant_woman": "🤰",
        "previous_track_button": "⏮",
        "prince": "🤴",
        "princess": "👸",
        "printer": "🖨",
        "purple_heart": "💜",
        "purse": "👛",
        "pushpin": "📌",
        "put_litter_in_its_place": "🚮",
        "question": "❓",
        "rabbit": "🐰",
        "rabbit2": "🐇",
        "racehorse": "🐎",
        "racing_car": "🏎",
        "radio": "📻",
        "radio_button": "🔘",
        "radioactive": "☢️",
        "railway_car": "🚃",
        "railway_track": "🛤",
        "rainbow": "🌈",
        "rainbow_flag": "🏳️&zwj;🌈",
        "raised_back_of_hand": "🤚",
        "raised_hand_with_fingers_splayed": "🖐",
        "raised_hands": "🙌",
        "raising_hand_woman": "🙋",
        "raising_hand_man": "🙋&zwj;♂️",
        "ram": "🐏",
        "ramen": "🍜",
        "rat": "🐀",
        "record_button": "⏺",
        "recycle": "♻️",
        "red_circle": "🔴",
        "registered": "®️",
        "relaxed": "☺️",
        "relieved": "😌",
        "reminder_ribbon": "🎗",
        "repeat": "🔁",
        "repeat_one": "🔂",
        "rescue_worker_helmet": "⛑",
        "restroom": "🚻",
        "revolving_hearts": "💞",
        "rewind": "⏪",
        "rhinoceros": "🦏",
        "ribbon": "🎀",
        "rice": "🍚",
        "rice_ball": "🍙",
        "rice_cracker": "🍘",
        "rice_scene": "🎑",
        "right_anger_bubble": "🗯",
        "ring": "💍",
        "robot": "🤖",
        "rocket": "🚀",
        "rofl": "🤣",
        "roll_eyes": "🙄",
        "roller_coaster": "🎢",
        "rooster": "🐓",
        "rose": "🌹",
        "rosette": "🏵",
        "rotating_light": "🚨",
        "round_pushpin": "📍",
        "rowing_man": "🚣",
        "rowing_woman": "🚣&zwj;♀️",
        "rugby_football": "🏉",
        "running_man": "🏃",
        "running_shirt_with_sash": "🎽",
        "running_woman": "🏃&zwj;♀️",
        "sa": "🈂️",
        "sagittarius": "♐️",
        "sake": "🍶",
        "sandal": "👡",
        "santa": "🎅",
        "satellite": "📡",
        "saxophone": "🎷",
        "school": "🏫",
        "school_satchel": "🎒",
        "scissors": "✂️",
        "scorpion": "🦂",
        "scorpius": "♏️",
        "scream": "😱",
        "scream_cat": "🙀",
        "scroll": "📜",
        "seat": "💺",
        "secret": "㊙️",
        "see_no_evil": "🙈",
        "seedling": "🌱",
        "selfie": "🤳",
        "shallow_pan_of_food": "🥘",
        "shamrock": "☘️",
        "shark": "🦈",
        "shaved_ice": "🍧",
        "sheep": "🐑",
        "shell": "🐚",
        "shield": "🛡",
        "shinto_shrine": "⛩",
        "ship": "🚢",
        "shirt": "👕",
        "shopping": "🛍",
        "shopping_cart": "🛒",
        "shower": "🚿",
        "shrimp": "🦐",
        "signal_strength": "📶",
        "six_pointed_star": "🔯",
        "ski": "🎿",
        "skier": "⛷",
        "skull": "💀",
        "skull_and_crossbones": "☠️",
        "sleeping": "😴",
        "sleeping_bed": "🛌",
        "sleepy": "😪",
        "slightly_frowning_face": "🙁",
        "slightly_smiling_face": "🙂",
        "slot_machine": "🎰",
        "small_airplane": "🛩",
        "small_blue_diamond": "🔹",
        "small_orange_diamond": "🔸",
        "small_red_triangle": "🔺",
        "small_red_triangle_down": "🔻",
        "smile": "😄",
        "smile_cat": "😸",
        "smiley": "😃",
        "smiley_cat": "😺",
        "smiling_imp": "😈",
        "smirk": "😏",
        "smirk_cat": "😼",
        "smoking": "🚬",
        "snail": "🐌",
        "snake": "🐍",
        "sneezing_face": "🤧",
        "snowboarder": "🏂",
        "snowflake": "❄️",
        "snowman": "⛄️",
        "snowman_with_snow": "☃️",
        "sob": "😭",
        "soccer": "⚽️",
        "soon": "🔜",
        "sos": "🆘",
        "sound": "🔉",
        "space_invader": "👾",
        "spades": "♠️",
        "spaghetti": "🍝",
        "sparkle": "❇️",
        "sparkler": "🎇",
        "sparkles": "✨",
        "sparkling_heart": "💖",
        "speak_no_evil": "🙊",
        "speaker": "🔈",
        "speaking_head": "🗣",
        "speech_balloon": "💬",
        "speedboat": "🚤",
        "spider": "🕷",
        "spider_web": "🕸",
        "spiral_calendar": "🗓",
        "spiral_notepad": "🗒",
        "spoon": "🥄",
        "squid": "🦑",
        "stadium": "🏟",
        "star": "⭐️",
        "star2": "🌟",
        "star_and_crescent": "☪️",
        "star_of_david": "✡️",
        "stars": "🌠",
        "station": "🚉",
        "statue_of_liberty": "🗽",
        "steam_locomotive": "🚂",
        "stew": "🍲",
        "stop_button": "⏹",
        "stop_sign": "🛑",
        "stopwatch": "⏱",
        "straight_ruler": "📏",
        "strawberry": "🍓",
        "stuck_out_tongue": "😛",
        "stuck_out_tongue_closed_eyes": "😝",
        "stuck_out_tongue_winking_eye": "😜",
        "studio_microphone": "🎙",
        "stuffed_flatbread": "🥙",
        "sun_behind_large_cloud": "🌥",
        "sun_behind_rain_cloud": "🌦",
        "sun_behind_small_cloud": "🌤",
        "sun_with_face": "🌞",
        "sunflower": "🌻",
        "sunglasses": "😎",
        "sunny": "☀️",
        "sunrise": "🌅",
        "sunrise_over_mountains": "🌄",
        "surfing_man": "🏄",
        "surfing_woman": "🏄&zwj;♀️",
        "sushi": "🍣",
        "suspension_railway": "🚟",
        "sweat": "😓",
        "sweat_drops": "💦",
        "sweat_smile": "😅",
        "sweet_potato": "🍠",
        "swimming_man": "🏊",
        "swimming_woman": "🏊&zwj;♀️",
        "symbols": "🔣",
        "synagogue": "🕍",
        "syringe": "💉",
        "taco": "🌮",
        "tada": "🎉",
        "tanabata_tree": "🎋",
        "taurus": "♉️",
        "taxi": "🚕",
        "tea": "🍵",
        "telephone_receiver": "📞",
        "telescope": "🔭",
        "tennis": "🎾",
        "tent": "⛺️",
        "thermometer": "🌡",
        "thinking": "🤔",
        "thought_balloon": "💭",
        "ticket": "🎫",
        "tickets": "🎟",
        "tiger": "🐯",
        "tiger2": "🐅",
        "timer_clock": "⏲",
        "tipping_hand_man": "💁&zwj;♂️",
        "tired_face": "😫",
        "tm": "™️",
        "toilet": "🚽",
        "tokyo_tower": "🗼",
        "tomato": "🍅",
        "tongue": "👅",
        "top": "🔝",
        "tophat": "🎩",
        "tornado": "🌪",
        "trackball": "🖲",
        "tractor": "🚜",
        "traffic_light": "🚥",
        "train": "🚋",
        "train2": "🚆",
        "tram": "🚊",
        "triangular_flag_on_post": "🚩",
        "triangular_ruler": "📐",
        "trident": "🔱",
        "triumph": "😤",
        "trolleybus": "🚎",
        "trophy": "🏆",
        "tropical_drink": "🍹",
        "tropical_fish": "🐠",
        "truck": "🚚",
        "trumpet": "🎺",
        "tulip": "🌷",
        "tumbler_glass": "🥃",
        "turkey": "🦃",
        "turtle": "🐢",
        "tv": "📺",
        "twisted_rightwards_arrows": "🔀",
        "two_hearts": "💕",
        "two_men_holding_hands": "👬",
        "two_women_holding_hands": "👭",
        "u5272": "🈹",
        "u5408": "🈴",
        "u55b6": "🈺",
        "u6307": "🈯️",
        "u6708": "🈷️",
        "u6709": "🈶",
        "u6e80": "🈵",
        "u7121": "🈚️",
        "u7533": "🈸",
        "u7981": "🈲",
        "u7a7a": "🈳",
        "umbrella": "☔️",
        "unamused": "😒",
        "underage": "🔞",
        "unicorn": "🦄",
        "unlock": "🔓",
        "up": "🆙",
        "upside_down_face": "🙃",
        "v": "✌️",
        "vertical_traffic_light": "🚦",
        "vhs": "📼",
        "vibration_mode": "📳",
        "video_camera": "📹",
        "video_game": "🎮",
        "violin": "🎻",
        "virgo": "♍️",
        "volcano": "🌋",
        "volleyball": "🏐",
        "vs": "🆚",
        "vulcan_salute": "🖖",
        "walking_man": "🚶",
        "walking_woman": "🚶&zwj;♀️",
        "waning_crescent_moon": "🌘",
        "waning_gibbous_moon": "🌖",
        "warning": "⚠️",
        "wastebasket": "🗑",
        "watch": "⌚️",
        "water_buffalo": "🐃",
        "watermelon": "🍉",
        "wave": "👋",
        "wavy_dash": "〰️",
        "waxing_crescent_moon": "🌒",
        "wc": "🚾",
        "weary": "😩",
        "wedding": "💒",
        "weight_lifting_man": "🏋️",
        "weight_lifting_woman": "🏋️&zwj;♀️",
        "whale": "🐳",
        "whale2": "🐋",
        "wheel_of_dharma": "☸️",
        "wheelchair": "♿️",
        "white_check_mark": "✅",
        "white_circle": "⚪️",
        "white_flag": "🏳️",
        "white_flower": "💮",
        "white_large_square": "⬜️",
        "white_medium_small_square": "◽️",
        "white_medium_square": "◻️",
        "white_small_square": "▫️",
        "white_square_button": "🔳",
        "wilted_flower": "🥀",
        "wind_chime": "🎐",
        "wind_face": "🌬",
        "wine_glass": "🍷",
        "wink": "😉",
        "wolf": "🐺",
        "woman": "👩",
        "woman_artist": "👩&zwj;🎨",
        "woman_astronaut": "👩&zwj;🚀",
        "woman_cartwheeling": "🤸&zwj;♀️",
        "woman_cook": "👩&zwj;🍳",
        "woman_facepalming": "🤦&zwj;♀️",
        "woman_factory_worker": "👩&zwj;🏭",
        "woman_farmer": "👩&zwj;🌾",
        "woman_firefighter": "👩&zwj;🚒",
        "woman_health_worker": "👩&zwj;⚕️",
        "woman_judge": "👩&zwj;⚖️",
        "woman_juggling": "🤹&zwj;♀️",
        "woman_mechanic": "👩&zwj;🔧",
        "woman_office_worker": "👩&zwj;💼",
        "woman_pilot": "👩&zwj;✈️",
        "woman_playing_handball": "🤾&zwj;♀️",
        "woman_playing_water_polo": "🤽&zwj;♀️",
        "woman_scientist": "👩&zwj;🔬",
        "woman_shrugging": "🤷&zwj;♀️",
        "woman_singer": "👩&zwj;🎤",
        "woman_student": "👩&zwj;🎓",
        "woman_teacher": "👩&zwj;🏫",
        "woman_technologist": "👩&zwj;💻",
        "woman_with_turban": "👳&zwj;♀️",
        "womans_clothes": "👚",
        "womans_hat": "👒",
        "women_wrestling": "🤼&zwj;♀️",
        "womens": "🚺",
        "world_map": "🗺",
        "worried": "😟",
        "wrench": "🔧",
        "writing_hand": "✍️",
        "x": "❌",
        "yellow_heart": "💛",
        "yen": "💴",
        "yin_yang": "☯️",
        "yum": "😋",
        "zap": "⚡️",
        "zipper_mouth_face": "🤐",
        "zzz": "💤",
        /* special emojis :P */
        "octocat": '<img alt=":octocat:" height="20" width="20" align="absmiddle" src="https://assets-cdn.github.com/images/icons/emoji/octocat.png">',
        "showdown": `<span style="font-family: 'Anonymous Pro', monospace; text-decoration: underline; text-decoration-style: dashed; text-decoration-color: #3e8b8a;text-underline-position: under;">S</span>`
      };
      showdown2.Converter = function(converterOptions) {
        "use strict";
        var options = {}, langExtensions = [], outputModifiers = [], listeners = {}, setConvFlavor = setFlavor, metadata = {
          parsed: {},
          raw: "",
          format: ""
        };
        _constructor();
        function _constructor() {
          converterOptions = converterOptions || {};
          for (var gOpt in globalOptions) {
            if (globalOptions.hasOwnProperty(gOpt)) {
              options[gOpt] = globalOptions[gOpt];
            }
          }
          if (typeof converterOptions === "object") {
            for (var opt in converterOptions) {
              if (converterOptions.hasOwnProperty(opt)) {
                options[opt] = converterOptions[opt];
              }
            }
          } else {
            throw Error("Converter expects the passed parameter to be an object, but " + typeof converterOptions + " was passed instead.");
          }
          if (options.extensions) {
            showdown2.helper.forEach(options.extensions, _parseExtension);
          }
        }
        function _parseExtension(ext, name2) {
          name2 = name2 || null;
          if (showdown2.helper.isString(ext)) {
            ext = showdown2.helper.stdExtName(ext);
            name2 = ext;
            if (showdown2.extensions[ext]) {
              console.warn("DEPRECATION WARNING: " + ext + " is an old extension that uses a deprecated loading method.Please inform the developer that the extension should be updated!");
              legacyExtensionLoading(showdown2.extensions[ext], ext);
              return;
            } else if (!showdown2.helper.isUndefined(extensions[ext])) {
              ext = extensions[ext];
            } else {
              throw Error('Extension "' + ext + '" could not be loaded. It was either not found or is not a valid extension.');
            }
          }
          if (typeof ext === "function") {
            ext = ext();
          }
          if (!showdown2.helper.isArray(ext)) {
            ext = [ext];
          }
          var validExt = validate(ext, name2);
          if (!validExt.valid) {
            throw Error(validExt.error);
          }
          for (var i = 0; i < ext.length; ++i) {
            switch (ext[i].type) {
              case "lang":
                langExtensions.push(ext[i]);
                break;
              case "output":
                outputModifiers.push(ext[i]);
                break;
            }
            if (ext[i].hasOwnProperty("listeners")) {
              for (var ln in ext[i].listeners) {
                if (ext[i].listeners.hasOwnProperty(ln)) {
                  listen(ln, ext[i].listeners[ln]);
                }
              }
            }
          }
        }
        function legacyExtensionLoading(ext, name2) {
          if (typeof ext === "function") {
            ext = ext(new showdown2.Converter());
          }
          if (!showdown2.helper.isArray(ext)) {
            ext = [ext];
          }
          var valid = validate(ext, name2);
          if (!valid.valid) {
            throw Error(valid.error);
          }
          for (var i = 0; i < ext.length; ++i) {
            switch (ext[i].type) {
              case "lang":
                langExtensions.push(ext[i]);
                break;
              case "output":
                outputModifiers.push(ext[i]);
                break;
              default:
                throw Error("Extension loader error: Type unrecognized!!!");
            }
          }
        }
        function listen(name2, callback) {
          if (!showdown2.helper.isString(name2)) {
            throw Error("Invalid argument in converter.listen() method: name must be a string, but " + typeof name2 + " given");
          }
          if (typeof callback !== "function") {
            throw Error("Invalid argument in converter.listen() method: callback must be a function, but " + typeof callback + " given");
          }
          if (!listeners.hasOwnProperty(name2)) {
            listeners[name2] = [];
          }
          listeners[name2].push(callback);
        }
        function rTrimInputText(text) {
          var rsp = text.match(/^\s*/)[0].length, rgx = new RegExp("^\\s{0," + rsp + "}", "gm");
          return text.replace(rgx, "");
        }
        this._dispatch = function dispatch(evtName, text, options2, globals) {
          if (listeners.hasOwnProperty(evtName)) {
            for (var ei = 0; ei < listeners[evtName].length; ++ei) {
              var nText = listeners[evtName][ei](evtName, text, this, options2, globals);
              if (nText && typeof nText !== "undefined") {
                text = nText;
              }
            }
          }
          return text;
        };
        this.listen = function(name2, callback) {
          listen(name2, callback);
          return this;
        };
        this.makeHtml = function(text) {
          if (!text) {
            return text;
          }
          var globals = {
            gHtmlBlocks: [],
            gHtmlMdBlocks: [],
            gHtmlSpans: [],
            gUrls: {},
            gTitles: {},
            gDimensions: {},
            gListLevel: 0,
            hashLinkCounts: {},
            langExtensions,
            outputModifiers,
            converter: this,
            ghCodeBlocks: [],
            metadata: {
              parsed: {},
              raw: "",
              format: ""
            }
          };
          text = text.replace(/¨/g, "¨T");
          text = text.replace(/\$/g, "¨D");
          text = text.replace(/\r\n/g, "\n");
          text = text.replace(/\r/g, "\n");
          text = text.replace(/\u00A0/g, "&nbsp;");
          if (options.smartIndentationFix) {
            text = rTrimInputText(text);
          }
          text = "\n\n" + text + "\n\n";
          text = showdown2.subParser("detab")(text, options, globals);
          text = text.replace(/^[ \t]+$/mg, "");
          showdown2.helper.forEach(langExtensions, function(ext) {
            text = showdown2.subParser("runExtension")(ext, text, options, globals);
          });
          text = showdown2.subParser("metadata")(text, options, globals);
          text = showdown2.subParser("hashPreCodeTags")(text, options, globals);
          text = showdown2.subParser("githubCodeBlocks")(text, options, globals);
          text = showdown2.subParser("hashHTMLBlocks")(text, options, globals);
          text = showdown2.subParser("hashCodeTags")(text, options, globals);
          text = showdown2.subParser("stripLinkDefinitions")(text, options, globals);
          text = showdown2.subParser("blockGamut")(text, options, globals);
          text = showdown2.subParser("unhashHTMLSpans")(text, options, globals);
          text = showdown2.subParser("unescapeSpecialChars")(text, options, globals);
          text = text.replace(/¨D/g, "$$");
          text = text.replace(/¨T/g, "¨");
          text = showdown2.subParser("completeHTMLDocument")(text, options, globals);
          showdown2.helper.forEach(outputModifiers, function(ext) {
            text = showdown2.subParser("runExtension")(ext, text, options, globals);
          });
          metadata = globals.metadata;
          return text;
        };
        this.makeMarkdown = this.makeMd = function(src, HTMLParser) {
          src = src.replace(/\r\n/g, "\n");
          src = src.replace(/\r/g, "\n");
          src = src.replace(/>[ \t]+</, ">¨NBSP;<");
          if (!HTMLParser) {
            if (window && window.document) {
              HTMLParser = window.document;
            } else {
              throw new Error("HTMLParser is undefined. If in a webworker or nodejs environment, you need to provide a WHATWG DOM and HTML such as JSDOM");
            }
          }
          var doc = HTMLParser.createElement("div");
          doc.innerHTML = src;
          var globals = {
            preList: substitutePreCodeTags(doc)
          };
          clean(doc);
          var nodes = doc.childNodes, mdDoc = "";
          for (var i = 0; i < nodes.length; i++) {
            mdDoc += showdown2.subParser("makeMarkdown.node")(nodes[i], globals);
          }
          function clean(node) {
            for (var n = 0; n < node.childNodes.length; ++n) {
              var child = node.childNodes[n];
              if (child.nodeType === 3) {
                if (!/\S/.test(child.nodeValue) && !/^[ ]+$/.test(child.nodeValue)) {
                  node.removeChild(child);
                  --n;
                } else {
                  child.nodeValue = child.nodeValue.split("\n").join(" ");
                  child.nodeValue = child.nodeValue.replace(/(\s)+/g, "$1");
                }
              } else if (child.nodeType === 1) {
                clean(child);
              }
            }
          }
          function substitutePreCodeTags(doc2) {
            var pres = doc2.querySelectorAll("pre"), presPH = [];
            for (var i2 = 0; i2 < pres.length; ++i2) {
              if (pres[i2].childElementCount === 1 && pres[i2].firstChild.tagName.toLowerCase() === "code") {
                var content = pres[i2].firstChild.innerHTML.trim(), language = pres[i2].firstChild.getAttribute("data-language") || "";
                if (language === "") {
                  var classes = pres[i2].firstChild.className.split(" ");
                  for (var c = 0; c < classes.length; ++c) {
                    var matches = classes[c].match(/^language-(.+)$/);
                    if (matches !== null) {
                      language = matches[1];
                      break;
                    }
                  }
                }
                content = showdown2.helper.unescapeHTMLEntities(content);
                presPH.push(content);
                pres[i2].outerHTML = '<precode language="' + language + '" precodenum="' + i2.toString() + '"></precode>';
              } else {
                presPH.push(pres[i2].innerHTML);
                pres[i2].innerHTML = "";
                pres[i2].setAttribute("prenum", i2.toString());
              }
            }
            return presPH;
          }
          return mdDoc;
        };
        this.setOption = function(key, value) {
          options[key] = value;
        };
        this.getOption = function(key) {
          return options[key];
        };
        this.getOptions = function() {
          return options;
        };
        this.addExtension = function(extension, name2) {
          name2 = name2 || null;
          _parseExtension(extension, name2);
        };
        this.useExtension = function(extensionName) {
          _parseExtension(extensionName);
        };
        this.setFlavor = function(name2) {
          if (!flavor.hasOwnProperty(name2)) {
            throw Error(name2 + " flavor was not found");
          }
          var preset = flavor[name2];
          setConvFlavor = name2;
          for (var option in preset) {
            if (preset.hasOwnProperty(option)) {
              options[option] = preset[option];
            }
          }
        };
        this.getFlavor = function() {
          return setConvFlavor;
        };
        this.removeExtension = function(extension) {
          if (!showdown2.helper.isArray(extension)) {
            extension = [extension];
          }
          for (var a = 0; a < extension.length; ++a) {
            var ext = extension[a];
            for (var i = 0; i < langExtensions.length; ++i) {
              if (langExtensions[i] === ext) {
                langExtensions.splice(i, 1);
              }
            }
            for (var ii = 0; ii < outputModifiers.length; ++ii) {
              if (outputModifiers[ii] === ext) {
                outputModifiers.splice(ii, 1);
              }
            }
          }
        };
        this.getAllExtensions = function() {
          return {
            language: langExtensions,
            output: outputModifiers
          };
        };
        this.getMetadata = function(raw) {
          if (raw) {
            return metadata.raw;
          } else {
            return metadata.parsed;
          }
        };
        this.getMetadataFormat = function() {
          return metadata.format;
        };
        this._setMetadataPair = function(key, value) {
          metadata.parsed[key] = value;
        };
        this._setMetadataFormat = function(format2) {
          metadata.format = format2;
        };
        this._setMetadataRaw = function(raw) {
          metadata.raw = raw;
        };
      };
      showdown2.subParser("anchors", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("anchors.before", text, options, globals);
        var writeAnchorTag = function(wholeMatch, linkText, linkId, url, m5, m6, title) {
          if (showdown2.helper.isUndefined(title)) {
            title = "";
          }
          linkId = linkId.toLowerCase();
          if (wholeMatch.search(/\(<?\s*>? ?(['"].*['"])?\)$/m) > -1) {
            url = "";
          } else if (!url) {
            if (!linkId) {
              linkId = linkText.toLowerCase().replace(/ ?\n/g, " ");
            }
            url = "#" + linkId;
            if (!showdown2.helper.isUndefined(globals.gUrls[linkId])) {
              url = globals.gUrls[linkId];
              if (!showdown2.helper.isUndefined(globals.gTitles[linkId])) {
                title = globals.gTitles[linkId];
              }
            } else {
              return wholeMatch;
            }
          }
          url = url.replace(showdown2.helper.regexes.asteriskDashAndColon, showdown2.helper.escapeCharactersCallback);
          var result = '<a href="' + url + '"';
          if (title !== "" && title !== null) {
            title = title.replace(/"/g, "&quot;");
            title = title.replace(showdown2.helper.regexes.asteriskDashAndColon, showdown2.helper.escapeCharactersCallback);
            result += ' title="' + title + '"';
          }
          if (options.openLinksInNewWindow && !/^#/.test(url)) {
            result += ' rel="noopener noreferrer" target="¨E95Eblank"';
          }
          result += ">" + linkText + "</a>";
          return result;
        };
        text = text.replace(/\[((?:\[[^\]]*]|[^\[\]])*)] ?(?:\n *)?\[(.*?)]()()()()/g, writeAnchorTag);
        text = text.replace(
          /\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<([^>]*)>(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g,
          writeAnchorTag
        );
        text = text.replace(
          /\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g,
          writeAnchorTag
        );
        text = text.replace(/\[([^\[\]]+)]()()()()()/g, writeAnchorTag);
        if (options.ghMentions) {
          text = text.replace(/(^|\s)(\\)?(@([a-z\d]+(?:[a-z\d.-]+?[a-z\d]+)*))/gmi, function(wm, st, escape, mentions, username) {
            if (escape === "\\") {
              return st + mentions;
            }
            if (!showdown2.helper.isString(options.ghMentionsLink)) {
              throw new Error("ghMentionsLink option must be a string");
            }
            var lnk = options.ghMentionsLink.replace(/\{u}/g, username), target = "";
            if (options.openLinksInNewWindow) {
              target = ' rel="noopener noreferrer" target="¨E95Eblank"';
            }
            return st + '<a href="' + lnk + '"' + target + ">" + mentions + "</a>";
          });
        }
        text = globals.converter._dispatch("anchors.after", text, options, globals);
        return text;
      });
      var simpleURLRegex = /([*~_]+|\b)(((https?|ftp|dict):\/\/|www\.)[^'">\s]+?\.[^'">\s]+?)()(\1)?(?=\s|$)(?!["<>])/gi, simpleURLRegex2 = /([*~_]+|\b)(((https?|ftp|dict):\/\/|www\.)[^'">\s]+\.[^'">\s]+?)([.!?,()\[\]])?(\1)?(?=\s|$)(?!["<>])/gi, delimUrlRegex = /()<(((https?|ftp|dict):\/\/|www\.)[^'">\s]+)()>()/gi, simpleMailRegex = /(^|\s)(?:mailto:)?([A-Za-z0-9!#$%&'*+-/=?^_`{|}~.]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)(?=$|\s)/gmi, delimMailRegex = /<()(?:mailto:)?([-.\w]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)>/gi, replaceLink = function(options) {
        "use strict";
        return function(wm, leadingMagicChars, link, m2, m3, trailingPunctuation, trailingMagicChars) {
          link = link.replace(showdown2.helper.regexes.asteriskDashAndColon, showdown2.helper.escapeCharactersCallback);
          var lnkTxt = link, append = "", target = "", lmc = leadingMagicChars || "", tmc = trailingMagicChars || "";
          if (/^www\./i.test(link)) {
            link = link.replace(/^www\./i, "http://www.");
          }
          if (options.excludeTrailingPunctuationFromURLs && trailingPunctuation) {
            append = trailingPunctuation;
          }
          if (options.openLinksInNewWindow) {
            target = ' rel="noopener noreferrer" target="¨E95Eblank"';
          }
          return lmc + '<a href="' + link + '"' + target + ">" + lnkTxt + "</a>" + append + tmc;
        };
      }, replaceMail = function(options, globals) {
        "use strict";
        return function(wholeMatch, b, mail) {
          var href = "mailto:";
          b = b || "";
          mail = showdown2.subParser("unescapeSpecialChars")(mail, options, globals);
          if (options.encodeEmails) {
            href = showdown2.helper.encodeEmailAddress(href + mail);
            mail = showdown2.helper.encodeEmailAddress(mail);
          } else {
            href = href + mail;
          }
          return b + '<a href="' + href + '">' + mail + "</a>";
        };
      };
      showdown2.subParser("autoLinks", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("autoLinks.before", text, options, globals);
        text = text.replace(delimUrlRegex, replaceLink(options));
        text = text.replace(delimMailRegex, replaceMail(options, globals));
        text = globals.converter._dispatch("autoLinks.after", text, options, globals);
        return text;
      });
      showdown2.subParser("simplifiedAutoLinks", function(text, options, globals) {
        "use strict";
        if (!options.simplifiedAutoLink) {
          return text;
        }
        text = globals.converter._dispatch("simplifiedAutoLinks.before", text, options, globals);
        if (options.excludeTrailingPunctuationFromURLs) {
          text = text.replace(simpleURLRegex2, replaceLink(options));
        } else {
          text = text.replace(simpleURLRegex, replaceLink(options));
        }
        text = text.replace(simpleMailRegex, replaceMail(options, globals));
        text = globals.converter._dispatch("simplifiedAutoLinks.after", text, options, globals);
        return text;
      });
      showdown2.subParser("blockGamut", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("blockGamut.before", text, options, globals);
        text = showdown2.subParser("blockQuotes")(text, options, globals);
        text = showdown2.subParser("headers")(text, options, globals);
        text = showdown2.subParser("horizontalRule")(text, options, globals);
        text = showdown2.subParser("lists")(text, options, globals);
        text = showdown2.subParser("codeBlocks")(text, options, globals);
        text = showdown2.subParser("tables")(text, options, globals);
        text = showdown2.subParser("hashHTMLBlocks")(text, options, globals);
        text = showdown2.subParser("paragraphs")(text, options, globals);
        text = globals.converter._dispatch("blockGamut.after", text, options, globals);
        return text;
      });
      showdown2.subParser("blockQuotes", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("blockQuotes.before", text, options, globals);
        text = text + "\n\n";
        var rgx = /(^ {0,3}>[ \t]?.+\n(.+\n)*\n*)+/gm;
        if (options.splitAdjacentBlockquotes) {
          rgx = /^ {0,3}>[\s\S]*?(?:\n\n)/gm;
        }
        text = text.replace(rgx, function(bq) {
          bq = bq.replace(/^[ \t]*>[ \t]?/gm, "");
          bq = bq.replace(/¨0/g, "");
          bq = bq.replace(/^[ \t]+$/gm, "");
          bq = showdown2.subParser("githubCodeBlocks")(bq, options, globals);
          bq = showdown2.subParser("blockGamut")(bq, options, globals);
          bq = bq.replace(/(^|\n)/g, "$1  ");
          bq = bq.replace(/(\s*<pre>[^\r]+?<\/pre>)/gm, function(wholeMatch, m1) {
            var pre = m1;
            pre = pre.replace(/^  /mg, "¨0");
            pre = pre.replace(/¨0/g, "");
            return pre;
          });
          return showdown2.subParser("hashBlock")("<blockquote>\n" + bq + "\n</blockquote>", options, globals);
        });
        text = globals.converter._dispatch("blockQuotes.after", text, options, globals);
        return text;
      });
      showdown2.subParser("codeBlocks", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("codeBlocks.before", text, options, globals);
        text += "¨0";
        var pattern = /(?:\n\n|^)((?:(?:[ ]{4}|\t).*\n+)+)(\n*[ ]{0,3}[^ \t\n]|(?=¨0))/g;
        text = text.replace(pattern, function(wholeMatch, m1, m2) {
          var codeblock = m1, nextChar = m2, end = "\n";
          codeblock = showdown2.subParser("outdent")(codeblock, options, globals);
          codeblock = showdown2.subParser("encodeCode")(codeblock, options, globals);
          codeblock = showdown2.subParser("detab")(codeblock, options, globals);
          codeblock = codeblock.replace(/^\n+/g, "");
          codeblock = codeblock.replace(/\n+$/g, "");
          if (options.omitExtraWLInCodeBlocks) {
            end = "";
          }
          codeblock = "<pre><code>" + codeblock + end + "</code></pre>";
          return showdown2.subParser("hashBlock")(codeblock, options, globals) + nextChar;
        });
        text = text.replace(/¨0/, "");
        text = globals.converter._dispatch("codeBlocks.after", text, options, globals);
        return text;
      });
      showdown2.subParser("codeSpans", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("codeSpans.before", text, options, globals);
        if (typeof text === "undefined") {
          text = "";
        }
        text = text.replace(
          /(^|[^\\])(`+)([^\r]*?[^`])\2(?!`)/gm,
          function(wholeMatch, m1, m2, m3) {
            var c = m3;
            c = c.replace(/^([ \t]*)/g, "");
            c = c.replace(/[ \t]*$/g, "");
            c = showdown2.subParser("encodeCode")(c, options, globals);
            c = m1 + "<code>" + c + "</code>";
            c = showdown2.subParser("hashHTMLSpans")(c, options, globals);
            return c;
          }
        );
        text = globals.converter._dispatch("codeSpans.after", text, options, globals);
        return text;
      });
      showdown2.subParser("completeHTMLDocument", function(text, options, globals) {
        "use strict";
        if (!options.completeHTMLDocument) {
          return text;
        }
        text = globals.converter._dispatch("completeHTMLDocument.before", text, options, globals);
        var doctype = "html", doctypeParsed = "<!DOCTYPE HTML>\n", title = "", charset = '<meta charset="utf-8">\n', lang = "", metadata = "";
        if (typeof globals.metadata.parsed.doctype !== "undefined") {
          doctypeParsed = "<!DOCTYPE " + globals.metadata.parsed.doctype + ">\n";
          doctype = globals.metadata.parsed.doctype.toString().toLowerCase();
          if (doctype === "html" || doctype === "html5") {
            charset = '<meta charset="utf-8">';
          }
        }
        for (var meta in globals.metadata.parsed) {
          if (globals.metadata.parsed.hasOwnProperty(meta)) {
            switch (meta.toLowerCase()) {
              case "doctype":
                break;
              case "title":
                title = "<title>" + globals.metadata.parsed.title + "</title>\n";
                break;
              case "charset":
                if (doctype === "html" || doctype === "html5") {
                  charset = '<meta charset="' + globals.metadata.parsed.charset + '">\n';
                } else {
                  charset = '<meta name="charset" content="' + globals.metadata.parsed.charset + '">\n';
                }
                break;
              case "language":
              case "lang":
                lang = ' lang="' + globals.metadata.parsed[meta] + '"';
                metadata += '<meta name="' + meta + '" content="' + globals.metadata.parsed[meta] + '">\n';
                break;
              default:
                metadata += '<meta name="' + meta + '" content="' + globals.metadata.parsed[meta] + '">\n';
            }
          }
        }
        text = doctypeParsed + "<html" + lang + ">\n<head>\n" + title + charset + metadata + "</head>\n<body>\n" + text.trim() + "\n</body>\n</html>";
        text = globals.converter._dispatch("completeHTMLDocument.after", text, options, globals);
        return text;
      });
      showdown2.subParser("detab", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("detab.before", text, options, globals);
        text = text.replace(/\t(?=\t)/g, "    ");
        text = text.replace(/\t/g, "¨A¨B");
        text = text.replace(/¨B(.+?)¨A/g, function(wholeMatch, m1) {
          var leadingText = m1, numSpaces = 4 - leadingText.length % 4;
          for (var i = 0; i < numSpaces; i++) {
            leadingText += " ";
          }
          return leadingText;
        });
        text = text.replace(/¨A/g, "    ");
        text = text.replace(/¨B/g, "");
        text = globals.converter._dispatch("detab.after", text, options, globals);
        return text;
      });
      showdown2.subParser("ellipsis", function(text, options, globals) {
        "use strict";
        if (!options.ellipsis) {
          return text;
        }
        text = globals.converter._dispatch("ellipsis.before", text, options, globals);
        text = text.replace(/\.\.\./g, "…");
        text = globals.converter._dispatch("ellipsis.after", text, options, globals);
        return text;
      });
      showdown2.subParser("emoji", function(text, options, globals) {
        "use strict";
        if (!options.emoji) {
          return text;
        }
        text = globals.converter._dispatch("emoji.before", text, options, globals);
        var emojiRgx = /:([\S]+?):/g;
        text = text.replace(emojiRgx, function(wm, emojiCode) {
          if (showdown2.helper.emojis.hasOwnProperty(emojiCode)) {
            return showdown2.helper.emojis[emojiCode];
          }
          return wm;
        });
        text = globals.converter._dispatch("emoji.after", text, options, globals);
        return text;
      });
      showdown2.subParser("encodeAmpsAndAngles", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("encodeAmpsAndAngles.before", text, options, globals);
        text = text.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\w+);)/g, "&amp;");
        text = text.replace(/<(?![a-z\/?$!])/gi, "&lt;");
        text = text.replace(/</g, "&lt;");
        text = text.replace(/>/g, "&gt;");
        text = globals.converter._dispatch("encodeAmpsAndAngles.after", text, options, globals);
        return text;
      });
      showdown2.subParser("encodeBackslashEscapes", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("encodeBackslashEscapes.before", text, options, globals);
        text = text.replace(/\\(\\)/g, showdown2.helper.escapeCharactersCallback);
        text = text.replace(/\\([`*_{}\[\]()>#+.!~=|:-])/g, showdown2.helper.escapeCharactersCallback);
        text = globals.converter._dispatch("encodeBackslashEscapes.after", text, options, globals);
        return text;
      });
      showdown2.subParser("encodeCode", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("encodeCode.before", text, options, globals);
        text = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/([*_{}\[\]\\=~-])/g, showdown2.helper.escapeCharactersCallback);
        text = globals.converter._dispatch("encodeCode.after", text, options, globals);
        return text;
      });
      showdown2.subParser("escapeSpecialCharsWithinTagAttributes", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("escapeSpecialCharsWithinTagAttributes.before", text, options, globals);
        var tags = /<\/?[a-z\d_:-]+(?:[\s]+[\s\S]+?)?>/gi, comments = /<!(--(?:(?:[^>-]|-[^>])(?:[^-]|-[^-])*)--)>/gi;
        text = text.replace(tags, function(wholeMatch) {
          return wholeMatch.replace(/(.)<\/?code>(?=.)/g, "$1`").replace(/([\\`*_~=|])/g, showdown2.helper.escapeCharactersCallback);
        });
        text = text.replace(comments, function(wholeMatch) {
          return wholeMatch.replace(/([\\`*_~=|])/g, showdown2.helper.escapeCharactersCallback);
        });
        text = globals.converter._dispatch("escapeSpecialCharsWithinTagAttributes.after", text, options, globals);
        return text;
      });
      showdown2.subParser("githubCodeBlocks", function(text, options, globals) {
        "use strict";
        if (!options.ghCodeBlocks) {
          return text;
        }
        text = globals.converter._dispatch("githubCodeBlocks.before", text, options, globals);
        text += "¨0";
        text = text.replace(/(?:^|\n)(?: {0,3})(```+|~~~+)(?: *)([^\s`~]*)\n([\s\S]*?)\n(?: {0,3})\1/g, function(wholeMatch, delim, language, codeblock) {
          var end = options.omitExtraWLInCodeBlocks ? "" : "\n";
          codeblock = showdown2.subParser("encodeCode")(codeblock, options, globals);
          codeblock = showdown2.subParser("detab")(codeblock, options, globals);
          codeblock = codeblock.replace(/^\n+/g, "");
          codeblock = codeblock.replace(/\n+$/g, "");
          codeblock = "<pre><code" + (language ? ' class="' + language + " language-" + language + '"' : "") + ">" + codeblock + end + "</code></pre>";
          codeblock = showdown2.subParser("hashBlock")(codeblock, options, globals);
          return "\n\n¨G" + (globals.ghCodeBlocks.push({ text: wholeMatch, codeblock }) - 1) + "G\n\n";
        });
        text = text.replace(/¨0/, "");
        return globals.converter._dispatch("githubCodeBlocks.after", text, options, globals);
      });
      showdown2.subParser("hashBlock", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("hashBlock.before", text, options, globals);
        text = text.replace(/(^\n+|\n+$)/g, "");
        text = "\n\n¨K" + (globals.gHtmlBlocks.push(text) - 1) + "K\n\n";
        text = globals.converter._dispatch("hashBlock.after", text, options, globals);
        return text;
      });
      showdown2.subParser("hashCodeTags", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("hashCodeTags.before", text, options, globals);
        var repFunc = function(wholeMatch, match2, left, right) {
          var codeblock = left + showdown2.subParser("encodeCode")(match2, options, globals) + right;
          return "¨C" + (globals.gHtmlSpans.push(codeblock) - 1) + "C";
        };
        text = showdown2.helper.replaceRecursiveRegExp(text, repFunc, "<code\\b[^>]*>", "</code>", "gim");
        text = globals.converter._dispatch("hashCodeTags.after", text, options, globals);
        return text;
      });
      showdown2.subParser("hashElement", function(text, options, globals) {
        "use strict";
        return function(wholeMatch, m1) {
          var blockText = m1;
          blockText = blockText.replace(/\n\n/g, "\n");
          blockText = blockText.replace(/^\n/, "");
          blockText = blockText.replace(/\n+$/g, "");
          blockText = "\n\n¨K" + (globals.gHtmlBlocks.push(blockText) - 1) + "K\n\n";
          return blockText;
        };
      });
      showdown2.subParser("hashHTMLBlocks", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("hashHTMLBlocks.before", text, options, globals);
        var blockTags = [
          "pre",
          "div",
          "h1",
          "h2",
          "h3",
          "h4",
          "h5",
          "h6",
          "blockquote",
          "table",
          "dl",
          "ol",
          "ul",
          "script",
          "noscript",
          "form",
          "fieldset",
          "iframe",
          "math",
          "style",
          "section",
          "header",
          "footer",
          "nav",
          "article",
          "aside",
          "address",
          "audio",
          "canvas",
          "figure",
          "hgroup",
          "output",
          "video",
          "p"
        ], repFunc = function(wholeMatch, match2, left, right) {
          var txt = wholeMatch;
          if (left.search(/\bmarkdown\b/) !== -1) {
            txt = left + globals.converter.makeHtml(match2) + right;
          }
          return "\n\n¨K" + (globals.gHtmlBlocks.push(txt) - 1) + "K\n\n";
        };
        if (options.backslashEscapesHTMLTags) {
          text = text.replace(/\\<(\/?[^>]+?)>/g, function(wm, inside) {
            return "&lt;" + inside + "&gt;";
          });
        }
        for (var i = 0; i < blockTags.length; ++i) {
          var opTagPos, rgx1 = new RegExp("^ {0,3}(<" + blockTags[i] + "\\b[^>]*>)", "im"), patLeft = "<" + blockTags[i] + "\\b[^>]*>", patRight = "</" + blockTags[i] + ">";
          while ((opTagPos = showdown2.helper.regexIndexOf(text, rgx1)) !== -1) {
            var subTexts = showdown2.helper.splitAtIndex(text, opTagPos), newSubText1 = showdown2.helper.replaceRecursiveRegExp(subTexts[1], repFunc, patLeft, patRight, "im");
            if (newSubText1 === subTexts[1]) {
              break;
            }
            text = subTexts[0].concat(newSubText1);
          }
        }
        text = text.replace(
          /(\n {0,3}(<(hr)\b([^<>])*?\/?>)[ \t]*(?=\n{2,}))/g,
          showdown2.subParser("hashElement")(text, options, globals)
        );
        text = showdown2.helper.replaceRecursiveRegExp(text, function(txt) {
          return "\n\n¨K" + (globals.gHtmlBlocks.push(txt) - 1) + "K\n\n";
        }, "^ {0,3}<!--", "-->", "gm");
        text = text.replace(
          /(?:\n\n)( {0,3}(?:<([?%])[^\r]*?\2>)[ \t]*(?=\n{2,}))/g,
          showdown2.subParser("hashElement")(text, options, globals)
        );
        text = globals.converter._dispatch("hashHTMLBlocks.after", text, options, globals);
        return text;
      });
      showdown2.subParser("hashHTMLSpans", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("hashHTMLSpans.before", text, options, globals);
        function hashHTMLSpan(html) {
          return "¨C" + (globals.gHtmlSpans.push(html) - 1) + "C";
        }
        text = text.replace(/<[^>]+?\/>/gi, function(wm) {
          return hashHTMLSpan(wm);
        });
        text = text.replace(/<([^>]+?)>[\s\S]*?<\/\1>/g, function(wm) {
          return hashHTMLSpan(wm);
        });
        text = text.replace(/<([^>]+?)\s[^>]+?>[\s\S]*?<\/\1>/g, function(wm) {
          return hashHTMLSpan(wm);
        });
        text = text.replace(/<[^>]+?>/gi, function(wm) {
          return hashHTMLSpan(wm);
        });
        text = globals.converter._dispatch("hashHTMLSpans.after", text, options, globals);
        return text;
      });
      showdown2.subParser("unhashHTMLSpans", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("unhashHTMLSpans.before", text, options, globals);
        for (var i = 0; i < globals.gHtmlSpans.length; ++i) {
          var repText = globals.gHtmlSpans[i], limit = 0;
          while (/¨C(\d+)C/.test(repText)) {
            var num = RegExp.$1;
            repText = repText.replace("¨C" + num + "C", globals.gHtmlSpans[num]);
            if (limit === 10) {
              console.error("maximum nesting of 10 spans reached!!!");
              break;
            }
            ++limit;
          }
          text = text.replace("¨C" + i + "C", repText);
        }
        text = globals.converter._dispatch("unhashHTMLSpans.after", text, options, globals);
        return text;
      });
      showdown2.subParser("hashPreCodeTags", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("hashPreCodeTags.before", text, options, globals);
        var repFunc = function(wholeMatch, match2, left, right) {
          var codeblock = left + showdown2.subParser("encodeCode")(match2, options, globals) + right;
          return "\n\n¨G" + (globals.ghCodeBlocks.push({ text: wholeMatch, codeblock }) - 1) + "G\n\n";
        };
        text = showdown2.helper.replaceRecursiveRegExp(text, repFunc, "^ {0,3}<pre\\b[^>]*>\\s*<code\\b[^>]*>", "^ {0,3}</code>\\s*</pre>", "gim");
        text = globals.converter._dispatch("hashPreCodeTags.after", text, options, globals);
        return text;
      });
      showdown2.subParser("headers", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("headers.before", text, options, globals);
        var headerLevelStart = isNaN(parseInt(options.headerLevelStart)) ? 1 : parseInt(options.headerLevelStart), setextRegexH1 = options.smoothLivePreview ? /^(.+)[ \t]*\n={2,}[ \t]*\n+/gm : /^(.+)[ \t]*\n=+[ \t]*\n+/gm, setextRegexH2 = options.smoothLivePreview ? /^(.+)[ \t]*\n-{2,}[ \t]*\n+/gm : /^(.+)[ \t]*\n-+[ \t]*\n+/gm;
        text = text.replace(setextRegexH1, function(wholeMatch, m1) {
          var spanGamut = showdown2.subParser("spanGamut")(m1, options, globals), hID = options.noHeaderId ? "" : ' id="' + headerId(m1) + '"', hLevel = headerLevelStart, hashBlock = "<h" + hLevel + hID + ">" + spanGamut + "</h" + hLevel + ">";
          return showdown2.subParser("hashBlock")(hashBlock, options, globals);
        });
        text = text.replace(setextRegexH2, function(matchFound, m1) {
          var spanGamut = showdown2.subParser("spanGamut")(m1, options, globals), hID = options.noHeaderId ? "" : ' id="' + headerId(m1) + '"', hLevel = headerLevelStart + 1, hashBlock = "<h" + hLevel + hID + ">" + spanGamut + "</h" + hLevel + ">";
          return showdown2.subParser("hashBlock")(hashBlock, options, globals);
        });
        var atxStyle = options.requireSpaceBeforeHeadingText ? /^(#{1,6})[ \t]+(.+?)[ \t]*#*\n+/gm : /^(#{1,6})[ \t]*(.+?)[ \t]*#*\n+/gm;
        text = text.replace(atxStyle, function(wholeMatch, m1, m2) {
          var hText = m2;
          if (options.customizedHeaderId) {
            hText = m2.replace(/\s?\{([^{]+?)}\s*$/, "");
          }
          var span = showdown2.subParser("spanGamut")(hText, options, globals), hID = options.noHeaderId ? "" : ' id="' + headerId(m2) + '"', hLevel = headerLevelStart - 1 + m1.length, header = "<h" + hLevel + hID + ">" + span + "</h" + hLevel + ">";
          return showdown2.subParser("hashBlock")(header, options, globals);
        });
        function headerId(m) {
          var title, prefix;
          if (options.customizedHeaderId) {
            var match2 = m.match(/\{([^{]+?)}\s*$/);
            if (match2 && match2[1]) {
              m = match2[1];
            }
          }
          title = m;
          if (showdown2.helper.isString(options.prefixHeaderId)) {
            prefix = options.prefixHeaderId;
          } else if (options.prefixHeaderId === true) {
            prefix = "section-";
          } else {
            prefix = "";
          }
          if (!options.rawPrefixHeaderId) {
            title = prefix + title;
          }
          if (options.ghCompatibleHeaderId) {
            title = title.replace(/ /g, "-").replace(/&amp;/g, "").replace(/¨T/g, "").replace(/¨D/g, "").replace(/[&+$,\/:;=?@"#{}|^¨~\[\]`\\*)(%.!'<>]/g, "").toLowerCase();
          } else if (options.rawHeaderId) {
            title = title.replace(/ /g, "-").replace(/&amp;/g, "&").replace(/¨T/g, "¨").replace(/¨D/g, "$").replace(/["']/g, "-").toLowerCase();
          } else {
            title = title.replace(/[^\w]/g, "").toLowerCase();
          }
          if (options.rawPrefixHeaderId) {
            title = prefix + title;
          }
          if (globals.hashLinkCounts[title]) {
            title = title + "-" + globals.hashLinkCounts[title]++;
          } else {
            globals.hashLinkCounts[title] = 1;
          }
          return title;
        }
        text = globals.converter._dispatch("headers.after", text, options, globals);
        return text;
      });
      showdown2.subParser("horizontalRule", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("horizontalRule.before", text, options, globals);
        var key = showdown2.subParser("hashBlock")("<hr />", options, globals);
        text = text.replace(/^ {0,2}( ?-){3,}[ \t]*$/gm, key);
        text = text.replace(/^ {0,2}( ?\*){3,}[ \t]*$/gm, key);
        text = text.replace(/^ {0,2}( ?_){3,}[ \t]*$/gm, key);
        text = globals.converter._dispatch("horizontalRule.after", text, options, globals);
        return text;
      });
      showdown2.subParser("images", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("images.before", text, options, globals);
        var inlineRegExp = /!\[([^\]]*?)][ \t]*()\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g, crazyRegExp = /!\[([^\]]*?)][ \t]*()\([ \t]?<([^>]*)>(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(?:(["'])([^"]*?)\6))?[ \t]?\)/g, base64RegExp = /!\[([^\]]*?)][ \t]*()\([ \t]?<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g, referenceRegExp = /!\[([^\]]*?)] ?(?:\n *)?\[([\s\S]*?)]()()()()()/g, refShortcutRegExp = /!\[([^\[\]]+)]()()()()()/g;
        function writeImageTagBase64(wholeMatch, altText, linkId, url, width, height, m5, title) {
          url = url.replace(/\s/g, "");
          return writeImageTag(wholeMatch, altText, linkId, url, width, height, m5, title);
        }
        function writeImageTag(wholeMatch, altText, linkId, url, width, height, m5, title) {
          var gUrls = globals.gUrls, gTitles = globals.gTitles, gDims = globals.gDimensions;
          linkId = linkId.toLowerCase();
          if (!title) {
            title = "";
          }
          if (wholeMatch.search(/\(<?\s*>? ?(['"].*['"])?\)$/m) > -1) {
            url = "";
          } else if (url === "" || url === null) {
            if (linkId === "" || linkId === null) {
              linkId = altText.toLowerCase().replace(/ ?\n/g, " ");
            }
            url = "#" + linkId;
            if (!showdown2.helper.isUndefined(gUrls[linkId])) {
              url = gUrls[linkId];
              if (!showdown2.helper.isUndefined(gTitles[linkId])) {
                title = gTitles[linkId];
              }
              if (!showdown2.helper.isUndefined(gDims[linkId])) {
                width = gDims[linkId].width;
                height = gDims[linkId].height;
              }
            } else {
              return wholeMatch;
            }
          }
          altText = altText.replace(/"/g, "&quot;").replace(showdown2.helper.regexes.asteriskDashAndColon, showdown2.helper.escapeCharactersCallback);
          url = url.replace(showdown2.helper.regexes.asteriskDashAndColon, showdown2.helper.escapeCharactersCallback);
          var result = '<img src="' + url + '" alt="' + altText + '"';
          if (title && showdown2.helper.isString(title)) {
            title = title.replace(/"/g, "&quot;").replace(showdown2.helper.regexes.asteriskDashAndColon, showdown2.helper.escapeCharactersCallback);
            result += ' title="' + title + '"';
          }
          if (width && height) {
            width = width === "*" ? "auto" : width;
            height = height === "*" ? "auto" : height;
            result += ' width="' + width + '"';
            result += ' height="' + height + '"';
          }
          result += " />";
          return result;
        }
        text = text.replace(referenceRegExp, writeImageTag);
        text = text.replace(base64RegExp, writeImageTagBase64);
        text = text.replace(crazyRegExp, writeImageTag);
        text = text.replace(inlineRegExp, writeImageTag);
        text = text.replace(refShortcutRegExp, writeImageTag);
        text = globals.converter._dispatch("images.after", text, options, globals);
        return text;
      });
      showdown2.subParser("italicsAndBold", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("italicsAndBold.before", text, options, globals);
        function parseInside(txt, left, right) {
          return left + txt + right;
        }
        if (options.literalMidWordUnderscores) {
          text = text.replace(/\b___(\S[\s\S]*?)___\b/g, function(wm, txt) {
            return parseInside(txt, "<strong><em>", "</em></strong>");
          });
          text = text.replace(/\b__(\S[\s\S]*?)__\b/g, function(wm, txt) {
            return parseInside(txt, "<strong>", "</strong>");
          });
          text = text.replace(/\b_(\S[\s\S]*?)_\b/g, function(wm, txt) {
            return parseInside(txt, "<em>", "</em>");
          });
        } else {
          text = text.replace(/___(\S[\s\S]*?)___/g, function(wm, m) {
            return /\S$/.test(m) ? parseInside(m, "<strong><em>", "</em></strong>") : wm;
          });
          text = text.replace(/__(\S[\s\S]*?)__/g, function(wm, m) {
            return /\S$/.test(m) ? parseInside(m, "<strong>", "</strong>") : wm;
          });
          text = text.replace(/_([^\s_][\s\S]*?)_/g, function(wm, m) {
            return /\S$/.test(m) ? parseInside(m, "<em>", "</em>") : wm;
          });
        }
        if (options.literalMidWordAsterisks) {
          text = text.replace(/([^*]|^)\B\*\*\*(\S[\s\S]*?)\*\*\*\B(?!\*)/g, function(wm, lead, txt) {
            return parseInside(txt, lead + "<strong><em>", "</em></strong>");
          });
          text = text.replace(/([^*]|^)\B\*\*(\S[\s\S]*?)\*\*\B(?!\*)/g, function(wm, lead, txt) {
            return parseInside(txt, lead + "<strong>", "</strong>");
          });
          text = text.replace(/([^*]|^)\B\*(\S[\s\S]*?)\*\B(?!\*)/g, function(wm, lead, txt) {
            return parseInside(txt, lead + "<em>", "</em>");
          });
        } else {
          text = text.replace(/\*\*\*(\S[\s\S]*?)\*\*\*/g, function(wm, m) {
            return /\S$/.test(m) ? parseInside(m, "<strong><em>", "</em></strong>") : wm;
          });
          text = text.replace(/\*\*(\S[\s\S]*?)\*\*/g, function(wm, m) {
            return /\S$/.test(m) ? parseInside(m, "<strong>", "</strong>") : wm;
          });
          text = text.replace(/\*([^\s*][\s\S]*?)\*/g, function(wm, m) {
            return /\S$/.test(m) ? parseInside(m, "<em>", "</em>") : wm;
          });
        }
        text = globals.converter._dispatch("italicsAndBold.after", text, options, globals);
        return text;
      });
      showdown2.subParser("lists", function(text, options, globals) {
        "use strict";
        function processListItems(listStr, trimTrailing) {
          globals.gListLevel++;
          listStr = listStr.replace(/\n{2,}$/, "\n");
          listStr += "¨0";
          var rgx = /(\n)?(^ {0,3})([*+-]|\d+[.])[ \t]+((\[(x|X| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(¨0| {0,3}([*+-]|\d+[.])[ \t]+))/gm, isParagraphed = /\n[ \t]*\n(?!¨0)/.test(listStr);
          if (options.disableForced4SpacesIndentedSublists) {
            rgx = /(\n)?(^ {0,3})([*+-]|\d+[.])[ \t]+((\[(x|X| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(¨0|\2([*+-]|\d+[.])[ \t]+))/gm;
          }
          listStr = listStr.replace(rgx, function(wholeMatch, m1, m2, m3, m4, taskbtn, checked) {
            checked = checked && checked.trim() !== "";
            var item = showdown2.subParser("outdent")(m4, options, globals), bulletStyle = "";
            if (taskbtn && options.tasklists) {
              bulletStyle = ' class="task-list-item" style="list-style-type: none;"';
              item = item.replace(/^[ \t]*\[(x|X| )?]/m, function() {
                var otp = '<input type="checkbox" disabled style="margin: 0px 0.35em 0.25em -1.6em; vertical-align: middle;"';
                if (checked) {
                  otp += " checked";
                }
                otp += ">";
                return otp;
              });
            }
            item = item.replace(/^([-*+]|\d\.)[ \t]+[\S\n ]*/g, function(wm2) {
              return "¨A" + wm2;
            });
            if (m1 || item.search(/\n{2,}/) > -1) {
              item = showdown2.subParser("githubCodeBlocks")(item, options, globals);
              item = showdown2.subParser("blockGamut")(item, options, globals);
            } else {
              item = showdown2.subParser("lists")(item, options, globals);
              item = item.replace(/\n$/, "");
              item = showdown2.subParser("hashHTMLBlocks")(item, options, globals);
              item = item.replace(/\n\n+/g, "\n\n");
              if (isParagraphed) {
                item = showdown2.subParser("paragraphs")(item, options, globals);
              } else {
                item = showdown2.subParser("spanGamut")(item, options, globals);
              }
            }
            item = item.replace("¨A", "");
            item = "<li" + bulletStyle + ">" + item + "</li>\n";
            return item;
          });
          listStr = listStr.replace(/¨0/g, "");
          globals.gListLevel--;
          if (trimTrailing) {
            listStr = listStr.replace(/\s+$/, "");
          }
          return listStr;
        }
        function styleStartNumber(list, listType) {
          if (listType === "ol") {
            var res = list.match(/^ *(\d+)\./);
            if (res && res[1] !== "1") {
              return ' start="' + res[1] + '"';
            }
          }
          return "";
        }
        function parseConsecutiveLists(list, listType, trimTrailing) {
          var olRgx = options.disableForced4SpacesIndentedSublists ? /^ ?\d+\.[ \t]/gm : /^ {0,3}\d+\.[ \t]/gm, ulRgx = options.disableForced4SpacesIndentedSublists ? /^ ?[*+-][ \t]/gm : /^ {0,3}[*+-][ \t]/gm, counterRxg = listType === "ul" ? olRgx : ulRgx, result = "";
          if (list.search(counterRxg) !== -1) {
            (function parseCL(txt) {
              var pos = txt.search(counterRxg), style2 = styleStartNumber(list, listType);
              if (pos !== -1) {
                result += "\n\n<" + listType + style2 + ">\n" + processListItems(txt.slice(0, pos), !!trimTrailing) + "</" + listType + ">\n";
                listType = listType === "ul" ? "ol" : "ul";
                counterRxg = listType === "ul" ? olRgx : ulRgx;
                parseCL(txt.slice(pos));
              } else {
                result += "\n\n<" + listType + style2 + ">\n" + processListItems(txt, !!trimTrailing) + "</" + listType + ">\n";
              }
            })(list);
          } else {
            var style = styleStartNumber(list, listType);
            result = "\n\n<" + listType + style + ">\n" + processListItems(list, !!trimTrailing) + "</" + listType + ">\n";
          }
          return result;
        }
        text = globals.converter._dispatch("lists.before", text, options, globals);
        text += "¨0";
        if (globals.gListLevel) {
          text = text.replace(
            /^(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(¨0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm,
            function(wholeMatch, list, m2) {
              var listType = m2.search(/[*+-]/g) > -1 ? "ul" : "ol";
              return parseConsecutiveLists(list, listType, true);
            }
          );
        } else {
          text = text.replace(
            /(\n\n|^\n?)(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(¨0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm,
            function(wholeMatch, m1, list, m3) {
              var listType = m3.search(/[*+-]/g) > -1 ? "ul" : "ol";
              return parseConsecutiveLists(list, listType, false);
            }
          );
        }
        text = text.replace(/¨0/, "");
        text = globals.converter._dispatch("lists.after", text, options, globals);
        return text;
      });
      showdown2.subParser("metadata", function(text, options, globals) {
        "use strict";
        if (!options.metadata) {
          return text;
        }
        text = globals.converter._dispatch("metadata.before", text, options, globals);
        function parseMetadataContents(content) {
          globals.metadata.raw = content;
          content = content.replace(/&/g, "&amp;").replace(/"/g, "&quot;");
          content = content.replace(/\n {4}/g, " ");
          content.replace(/^([\S ]+): +([\s\S]+?)$/gm, function(wm, key, value) {
            globals.metadata.parsed[key] = value;
            return "";
          });
        }
        text = text.replace(/^\s*«««+(\S*?)\n([\s\S]+?)\n»»»+\n/, function(wholematch, format2, content) {
          parseMetadataContents(content);
          return "¨M";
        });
        text = text.replace(/^\s*---+(\S*?)\n([\s\S]+?)\n---+\n/, function(wholematch, format2, content) {
          if (format2) {
            globals.metadata.format = format2;
          }
          parseMetadataContents(content);
          return "¨M";
        });
        text = text.replace(/¨M/g, "");
        text = globals.converter._dispatch("metadata.after", text, options, globals);
        return text;
      });
      showdown2.subParser("outdent", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("outdent.before", text, options, globals);
        text = text.replace(/^(\t|[ ]{1,4})/gm, "¨0");
        text = text.replace(/¨0/g, "");
        text = globals.converter._dispatch("outdent.after", text, options, globals);
        return text;
      });
      showdown2.subParser("paragraphs", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("paragraphs.before", text, options, globals);
        text = text.replace(/^\n+/g, "");
        text = text.replace(/\n+$/g, "");
        var grafs = text.split(/\n{2,}/g), grafsOut = [], end = grafs.length;
        for (var i = 0; i < end; i++) {
          var str = grafs[i];
          if (str.search(/¨(K|G)(\d+)\1/g) >= 0) {
            grafsOut.push(str);
          } else if (str.search(/\S/) >= 0) {
            str = showdown2.subParser("spanGamut")(str, options, globals);
            str = str.replace(/^([ \t]*)/g, "<p>");
            str += "</p>";
            grafsOut.push(str);
          }
        }
        end = grafsOut.length;
        for (i = 0; i < end; i++) {
          var blockText = "", grafsOutIt = grafsOut[i], codeFlag = false;
          while (/¨(K|G)(\d+)\1/.test(grafsOutIt)) {
            var delim = RegExp.$1, num = RegExp.$2;
            if (delim === "K") {
              blockText = globals.gHtmlBlocks[num];
            } else {
              if (codeFlag) {
                blockText = showdown2.subParser("encodeCode")(globals.ghCodeBlocks[num].text, options, globals);
              } else {
                blockText = globals.ghCodeBlocks[num].codeblock;
              }
            }
            blockText = blockText.replace(/\$/g, "$$$$");
            grafsOutIt = grafsOutIt.replace(/(\n\n)?¨(K|G)\d+\2(\n\n)?/, blockText);
            if (/^<pre\b[^>]*>\s*<code\b[^>]*>/.test(grafsOutIt)) {
              codeFlag = true;
            }
          }
          grafsOut[i] = grafsOutIt;
        }
        text = grafsOut.join("\n");
        text = text.replace(/^\n+/g, "");
        text = text.replace(/\n+$/g, "");
        return globals.converter._dispatch("paragraphs.after", text, options, globals);
      });
      showdown2.subParser("runExtension", function(ext, text, options, globals) {
        "use strict";
        if (ext.filter) {
          text = ext.filter(text, globals.converter, options);
        } else if (ext.regex) {
          var re = ext.regex;
          if (!(re instanceof RegExp)) {
            re = new RegExp(re, "g");
          }
          text = text.replace(re, ext.replace);
        }
        return text;
      });
      showdown2.subParser("spanGamut", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("spanGamut.before", text, options, globals);
        text = showdown2.subParser("codeSpans")(text, options, globals);
        text = showdown2.subParser("escapeSpecialCharsWithinTagAttributes")(text, options, globals);
        text = showdown2.subParser("encodeBackslashEscapes")(text, options, globals);
        text = showdown2.subParser("images")(text, options, globals);
        text = showdown2.subParser("anchors")(text, options, globals);
        text = showdown2.subParser("autoLinks")(text, options, globals);
        text = showdown2.subParser("simplifiedAutoLinks")(text, options, globals);
        text = showdown2.subParser("emoji")(text, options, globals);
        text = showdown2.subParser("underline")(text, options, globals);
        text = showdown2.subParser("italicsAndBold")(text, options, globals);
        text = showdown2.subParser("strikethrough")(text, options, globals);
        text = showdown2.subParser("ellipsis")(text, options, globals);
        text = showdown2.subParser("hashHTMLSpans")(text, options, globals);
        text = showdown2.subParser("encodeAmpsAndAngles")(text, options, globals);
        if (options.simpleLineBreaks) {
          if (!/\n\n¨K/.test(text)) {
            text = text.replace(/\n+/g, "<br />\n");
          }
        } else {
          text = text.replace(/  +\n/g, "<br />\n");
        }
        text = globals.converter._dispatch("spanGamut.after", text, options, globals);
        return text;
      });
      showdown2.subParser("strikethrough", function(text, options, globals) {
        "use strict";
        function parseInside(txt) {
          if (options.simplifiedAutoLink) {
            txt = showdown2.subParser("simplifiedAutoLinks")(txt, options, globals);
          }
          return "<del>" + txt + "</del>";
        }
        if (options.strikethrough) {
          text = globals.converter._dispatch("strikethrough.before", text, options, globals);
          text = text.replace(/(?:~){2}([\s\S]+?)(?:~){2}/g, function(wm, txt) {
            return parseInside(txt);
          });
          text = globals.converter._dispatch("strikethrough.after", text, options, globals);
        }
        return text;
      });
      showdown2.subParser("stripLinkDefinitions", function(text, options, globals) {
        "use strict";
        var regex = /^ {0,3}\[([^\]]+)]:[ \t]*\n?[ \t]*<?([^>\s]+)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n+|(?=¨0))/gm, base64Regex = /^ {0,3}\[([^\]]+)]:[ \t]*\n?[ \t]*<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n\n|(?=¨0)|(?=\n\[))/gm;
        text += "¨0";
        var replaceFunc = function(wholeMatch, linkId, url, width, height, blankLines, title) {
          linkId = linkId.toLowerCase();
          if (text.toLowerCase().split(linkId).length - 1 < 2) {
            return wholeMatch;
          }
          if (url.match(/^data:.+?\/.+?;base64,/)) {
            globals.gUrls[linkId] = url.replace(/\s/g, "");
          } else {
            globals.gUrls[linkId] = showdown2.subParser("encodeAmpsAndAngles")(url, options, globals);
          }
          if (blankLines) {
            return blankLines + title;
          } else {
            if (title) {
              globals.gTitles[linkId] = title.replace(/"|'/g, "&quot;");
            }
            if (options.parseImgDimensions && width && height) {
              globals.gDimensions[linkId] = {
                width,
                height
              };
            }
          }
          return "";
        };
        text = text.replace(base64Regex, replaceFunc);
        text = text.replace(regex, replaceFunc);
        text = text.replace(/¨0/, "");
        return text;
      });
      showdown2.subParser("tables", function(text, options, globals) {
        "use strict";
        if (!options.tables) {
          return text;
        }
        var tableRgx = /^ {0,3}\|?.+\|.+\n {0,3}\|?[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*:?[ \t]*(?:[-=]){2,}[\s\S]+?(?:\n\n|¨0)/gm, singeColTblRgx = /^ {0,3}\|.+\|[ \t]*\n {0,3}\|[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*\n( {0,3}\|.+\|[ \t]*\n)*(?:\n|¨0)/gm;
        function parseStyles(sLine) {
          if (/^:[ \t]*--*$/.test(sLine)) {
            return ' style="text-align:left;"';
          } else if (/^--*[ \t]*:[ \t]*$/.test(sLine)) {
            return ' style="text-align:right;"';
          } else if (/^:[ \t]*--*[ \t]*:$/.test(sLine)) {
            return ' style="text-align:center;"';
          } else {
            return "";
          }
        }
        function parseHeaders(header, style) {
          var id = "";
          header = header.trim();
          if (options.tablesHeaderId || options.tableHeaderId) {
            id = ' id="' + header.replace(/ /g, "_").toLowerCase() + '"';
          }
          header = showdown2.subParser("spanGamut")(header, options, globals);
          return "<th" + id + style + ">" + header + "</th>\n";
        }
        function parseCells(cell, style) {
          var subText = showdown2.subParser("spanGamut")(cell, options, globals);
          return "<td" + style + ">" + subText + "</td>\n";
        }
        function buildTable(headers, cells) {
          var tb = "<table>\n<thead>\n<tr>\n", tblLgn = headers.length;
          for (var i = 0; i < tblLgn; ++i) {
            tb += headers[i];
          }
          tb += "</tr>\n</thead>\n<tbody>\n";
          for (i = 0; i < cells.length; ++i) {
            tb += "<tr>\n";
            for (var ii = 0; ii < tblLgn; ++ii) {
              tb += cells[i][ii];
            }
            tb += "</tr>\n";
          }
          tb += "</tbody>\n</table>\n";
          return tb;
        }
        function parseTable(rawTable) {
          var i, tableLines = rawTable.split("\n");
          for (i = 0; i < tableLines.length; ++i) {
            if (/^ {0,3}\|/.test(tableLines[i])) {
              tableLines[i] = tableLines[i].replace(/^ {0,3}\|/, "");
            }
            if (/\|[ \t]*$/.test(tableLines[i])) {
              tableLines[i] = tableLines[i].replace(/\|[ \t]*$/, "");
            }
            tableLines[i] = showdown2.subParser("codeSpans")(tableLines[i], options, globals);
          }
          var rawHeaders = tableLines[0].split("|").map(function(s) {
            return s.trim();
          }), rawStyles = tableLines[1].split("|").map(function(s) {
            return s.trim();
          }), rawCells = [], headers = [], styles = [], cells = [];
          tableLines.shift();
          tableLines.shift();
          for (i = 0; i < tableLines.length; ++i) {
            if (tableLines[i].trim() === "") {
              continue;
            }
            rawCells.push(
              tableLines[i].split("|").map(function(s) {
                return s.trim();
              })
            );
          }
          if (rawHeaders.length < rawStyles.length) {
            return rawTable;
          }
          for (i = 0; i < rawStyles.length; ++i) {
            styles.push(parseStyles(rawStyles[i]));
          }
          for (i = 0; i < rawHeaders.length; ++i) {
            if (showdown2.helper.isUndefined(styles[i])) {
              styles[i] = "";
            }
            headers.push(parseHeaders(rawHeaders[i], styles[i]));
          }
          for (i = 0; i < rawCells.length; ++i) {
            var row = [];
            for (var ii = 0; ii < headers.length; ++ii) {
              if (showdown2.helper.isUndefined(rawCells[i][ii])) {
              }
              row.push(parseCells(rawCells[i][ii], styles[ii]));
            }
            cells.push(row);
          }
          return buildTable(headers, cells);
        }
        text = globals.converter._dispatch("tables.before", text, options, globals);
        text = text.replace(/\\(\|)/g, showdown2.helper.escapeCharactersCallback);
        text = text.replace(tableRgx, parseTable);
        text = text.replace(singeColTblRgx, parseTable);
        text = globals.converter._dispatch("tables.after", text, options, globals);
        return text;
      });
      showdown2.subParser("underline", function(text, options, globals) {
        "use strict";
        if (!options.underline) {
          return text;
        }
        text = globals.converter._dispatch("underline.before", text, options, globals);
        if (options.literalMidWordUnderscores) {
          text = text.replace(/\b___(\S[\s\S]*?)___\b/g, function(wm, txt) {
            return "<u>" + txt + "</u>";
          });
          text = text.replace(/\b__(\S[\s\S]*?)__\b/g, function(wm, txt) {
            return "<u>" + txt + "</u>";
          });
        } else {
          text = text.replace(/___(\S[\s\S]*?)___/g, function(wm, m) {
            return /\S$/.test(m) ? "<u>" + m + "</u>" : wm;
          });
          text = text.replace(/__(\S[\s\S]*?)__/g, function(wm, m) {
            return /\S$/.test(m) ? "<u>" + m + "</u>" : wm;
          });
        }
        text = text.replace(/(_)/g, showdown2.helper.escapeCharactersCallback);
        text = globals.converter._dispatch("underline.after", text, options, globals);
        return text;
      });
      showdown2.subParser("unescapeSpecialChars", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("unescapeSpecialChars.before", text, options, globals);
        text = text.replace(/¨E(\d+)E/g, function(wholeMatch, m1) {
          var charCodeToReplace = parseInt(m1);
          return String.fromCharCode(charCodeToReplace);
        });
        text = globals.converter._dispatch("unescapeSpecialChars.after", text, options, globals);
        return text;
      });
      showdown2.subParser("makeMarkdown.blockquote", function(node, globals) {
        "use strict";
        var txt = "";
        if (node.hasChildNodes()) {
          var children = node.childNodes, childrenLength = children.length;
          for (var i = 0; i < childrenLength; ++i) {
            var innerTxt = showdown2.subParser("makeMarkdown.node")(children[i], globals);
            if (innerTxt === "") {
              continue;
            }
            txt += innerTxt;
          }
        }
        txt = txt.trim();
        txt = "> " + txt.split("\n").join("\n> ");
        return txt;
      });
      showdown2.subParser("makeMarkdown.codeBlock", function(node, globals) {
        "use strict";
        var lang = node.getAttribute("language"), num = node.getAttribute("precodenum");
        return "```" + lang + "\n" + globals.preList[num] + "\n```";
      });
      showdown2.subParser("makeMarkdown.codeSpan", function(node) {
        "use strict";
        return "`" + node.innerHTML + "`";
      });
      showdown2.subParser("makeMarkdown.emphasis", function(node, globals) {
        "use strict";
        var txt = "";
        if (node.hasChildNodes()) {
          txt += "*";
          var children = node.childNodes, childrenLength = children.length;
          for (var i = 0; i < childrenLength; ++i) {
            txt += showdown2.subParser("makeMarkdown.node")(children[i], globals);
          }
          txt += "*";
        }
        return txt;
      });
      showdown2.subParser("makeMarkdown.header", function(node, globals, headerLevel) {
        "use strict";
        var headerMark = new Array(headerLevel + 1).join("#"), txt = "";
        if (node.hasChildNodes()) {
          txt = headerMark + " ";
          var children = node.childNodes, childrenLength = children.length;
          for (var i = 0; i < childrenLength; ++i) {
            txt += showdown2.subParser("makeMarkdown.node")(children[i], globals);
          }
        }
        return txt;
      });
      showdown2.subParser("makeMarkdown.hr", function() {
        "use strict";
        return "---";
      });
      showdown2.subParser("makeMarkdown.image", function(node) {
        "use strict";
        var txt = "";
        if (node.hasAttribute("src")) {
          txt += "![" + node.getAttribute("alt") + "](";
          txt += "<" + node.getAttribute("src") + ">";
          if (node.hasAttribute("width") && node.hasAttribute("height")) {
            txt += " =" + node.getAttribute("width") + "x" + node.getAttribute("height");
          }
          if (node.hasAttribute("title")) {
            txt += ' "' + node.getAttribute("title") + '"';
          }
          txt += ")";
        }
        return txt;
      });
      showdown2.subParser("makeMarkdown.links", function(node, globals) {
        "use strict";
        var txt = "";
        if (node.hasChildNodes() && node.hasAttribute("href")) {
          var children = node.childNodes, childrenLength = children.length;
          txt = "[";
          for (var i = 0; i < childrenLength; ++i) {
            txt += showdown2.subParser("makeMarkdown.node")(children[i], globals);
          }
          txt += "](";
          txt += "<" + node.getAttribute("href") + ">";
          if (node.hasAttribute("title")) {
            txt += ' "' + node.getAttribute("title") + '"';
          }
          txt += ")";
        }
        return txt;
      });
      showdown2.subParser("makeMarkdown.list", function(node, globals, type2) {
        "use strict";
        var txt = "";
        if (!node.hasChildNodes()) {
          return "";
        }
        var listItems = node.childNodes, listItemsLenght = listItems.length, listNum = node.getAttribute("start") || 1;
        for (var i = 0; i < listItemsLenght; ++i) {
          if (typeof listItems[i].tagName === "undefined" || listItems[i].tagName.toLowerCase() !== "li") {
            continue;
          }
          var bullet = "";
          if (type2 === "ol") {
            bullet = listNum.toString() + ". ";
          } else {
            bullet = "- ";
          }
          txt += bullet + showdown2.subParser("makeMarkdown.listItem")(listItems[i], globals);
          ++listNum;
        }
        txt += "\n<!-- -->\n";
        return txt.trim();
      });
      showdown2.subParser("makeMarkdown.listItem", function(node, globals) {
        "use strict";
        var listItemTxt = "";
        var children = node.childNodes, childrenLenght = children.length;
        for (var i = 0; i < childrenLenght; ++i) {
          listItemTxt += showdown2.subParser("makeMarkdown.node")(children[i], globals);
        }
        if (!/\n$/.test(listItemTxt)) {
          listItemTxt += "\n";
        } else {
          listItemTxt = listItemTxt.split("\n").join("\n    ").replace(/^ {4}$/gm, "").replace(/\n\n+/g, "\n\n");
        }
        return listItemTxt;
      });
      showdown2.subParser("makeMarkdown.node", function(node, globals, spansOnly) {
        "use strict";
        spansOnly = spansOnly || false;
        var txt = "";
        if (node.nodeType === 3) {
          return showdown2.subParser("makeMarkdown.txt")(node, globals);
        }
        if (node.nodeType === 8) {
          return "<!--" + node.data + "-->\n\n";
        }
        if (node.nodeType !== 1) {
          return "";
        }
        var tagName = node.tagName.toLowerCase();
        switch (tagName) {
          case "h1":
            if (!spansOnly) {
              txt = showdown2.subParser("makeMarkdown.header")(node, globals, 1) + "\n\n";
            }
            break;
          case "h2":
            if (!spansOnly) {
              txt = showdown2.subParser("makeMarkdown.header")(node, globals, 2) + "\n\n";
            }
            break;
          case "h3":
            if (!spansOnly) {
              txt = showdown2.subParser("makeMarkdown.header")(node, globals, 3) + "\n\n";
            }
            break;
          case "h4":
            if (!spansOnly) {
              txt = showdown2.subParser("makeMarkdown.header")(node, globals, 4) + "\n\n";
            }
            break;
          case "h5":
            if (!spansOnly) {
              txt = showdown2.subParser("makeMarkdown.header")(node, globals, 5) + "\n\n";
            }
            break;
          case "h6":
            if (!spansOnly) {
              txt = showdown2.subParser("makeMarkdown.header")(node, globals, 6) + "\n\n";
            }
            break;
          case "p":
            if (!spansOnly) {
              txt = showdown2.subParser("makeMarkdown.paragraph")(node, globals) + "\n\n";
            }
            break;
          case "blockquote":
            if (!spansOnly) {
              txt = showdown2.subParser("makeMarkdown.blockquote")(node, globals) + "\n\n";
            }
            break;
          case "hr":
            if (!spansOnly) {
              txt = showdown2.subParser("makeMarkdown.hr")(node, globals) + "\n\n";
            }
            break;
          case "ol":
            if (!spansOnly) {
              txt = showdown2.subParser("makeMarkdown.list")(node, globals, "ol") + "\n\n";
            }
            break;
          case "ul":
            if (!spansOnly) {
              txt = showdown2.subParser("makeMarkdown.list")(node, globals, "ul") + "\n\n";
            }
            break;
          case "precode":
            if (!spansOnly) {
              txt = showdown2.subParser("makeMarkdown.codeBlock")(node, globals) + "\n\n";
            }
            break;
          case "pre":
            if (!spansOnly) {
              txt = showdown2.subParser("makeMarkdown.pre")(node, globals) + "\n\n";
            }
            break;
          case "table":
            if (!spansOnly) {
              txt = showdown2.subParser("makeMarkdown.table")(node, globals) + "\n\n";
            }
            break;
          case "code":
            txt = showdown2.subParser("makeMarkdown.codeSpan")(node, globals);
            break;
          case "em":
          case "i":
            txt = showdown2.subParser("makeMarkdown.emphasis")(node, globals);
            break;
          case "strong":
          case "b":
            txt = showdown2.subParser("makeMarkdown.strong")(node, globals);
            break;
          case "del":
            txt = showdown2.subParser("makeMarkdown.strikethrough")(node, globals);
            break;
          case "a":
            txt = showdown2.subParser("makeMarkdown.links")(node, globals);
            break;
          case "img":
            txt = showdown2.subParser("makeMarkdown.image")(node, globals);
            break;
          default:
            txt = node.outerHTML + "\n\n";
        }
        return txt;
      });
      showdown2.subParser("makeMarkdown.paragraph", function(node, globals) {
        "use strict";
        var txt = "";
        if (node.hasChildNodes()) {
          var children = node.childNodes, childrenLength = children.length;
          for (var i = 0; i < childrenLength; ++i) {
            txt += showdown2.subParser("makeMarkdown.node")(children[i], globals);
          }
        }
        txt = txt.trim();
        return txt;
      });
      showdown2.subParser("makeMarkdown.pre", function(node, globals) {
        "use strict";
        var num = node.getAttribute("prenum");
        return "<pre>" + globals.preList[num] + "</pre>";
      });
      showdown2.subParser("makeMarkdown.strikethrough", function(node, globals) {
        "use strict";
        var txt = "";
        if (node.hasChildNodes()) {
          txt += "~~";
          var children = node.childNodes, childrenLength = children.length;
          for (var i = 0; i < childrenLength; ++i) {
            txt += showdown2.subParser("makeMarkdown.node")(children[i], globals);
          }
          txt += "~~";
        }
        return txt;
      });
      showdown2.subParser("makeMarkdown.strong", function(node, globals) {
        "use strict";
        var txt = "";
        if (node.hasChildNodes()) {
          txt += "**";
          var children = node.childNodes, childrenLength = children.length;
          for (var i = 0; i < childrenLength; ++i) {
            txt += showdown2.subParser("makeMarkdown.node")(children[i], globals);
          }
          txt += "**";
        }
        return txt;
      });
      showdown2.subParser("makeMarkdown.table", function(node, globals) {
        "use strict";
        var txt = "", tableArray = [[], []], headings = node.querySelectorAll("thead>tr>th"), rows = node.querySelectorAll("tbody>tr"), i, ii;
        for (i = 0; i < headings.length; ++i) {
          var headContent = showdown2.subParser("makeMarkdown.tableCell")(headings[i], globals), allign = "---";
          if (headings[i].hasAttribute("style")) {
            var style = headings[i].getAttribute("style").toLowerCase().replace(/\s/g, "");
            switch (style) {
              case "text-align:left;":
                allign = ":---";
                break;
              case "text-align:right;":
                allign = "---:";
                break;
              case "text-align:center;":
                allign = ":---:";
                break;
            }
          }
          tableArray[0][i] = headContent.trim();
          tableArray[1][i] = allign;
        }
        for (i = 0; i < rows.length; ++i) {
          var r = tableArray.push([]) - 1, cols = rows[i].getElementsByTagName("td");
          for (ii = 0; ii < headings.length; ++ii) {
            var cellContent = " ";
            if (typeof cols[ii] !== "undefined") {
              cellContent = showdown2.subParser("makeMarkdown.tableCell")(cols[ii], globals);
            }
            tableArray[r].push(cellContent);
          }
        }
        var cellSpacesCount = 3;
        for (i = 0; i < tableArray.length; ++i) {
          for (ii = 0; ii < tableArray[i].length; ++ii) {
            var strLen = tableArray[i][ii].length;
            if (strLen > cellSpacesCount) {
              cellSpacesCount = strLen;
            }
          }
        }
        for (i = 0; i < tableArray.length; ++i) {
          for (ii = 0; ii < tableArray[i].length; ++ii) {
            if (i === 1) {
              if (tableArray[i][ii].slice(-1) === ":") {
                tableArray[i][ii] = showdown2.helper.padEnd(tableArray[i][ii].slice(-1), cellSpacesCount - 1, "-") + ":";
              } else {
                tableArray[i][ii] = showdown2.helper.padEnd(tableArray[i][ii], cellSpacesCount, "-");
              }
            } else {
              tableArray[i][ii] = showdown2.helper.padEnd(tableArray[i][ii], cellSpacesCount);
            }
          }
          txt += "| " + tableArray[i].join(" | ") + " |\n";
        }
        return txt.trim();
      });
      showdown2.subParser("makeMarkdown.tableCell", function(node, globals) {
        "use strict";
        var txt = "";
        if (!node.hasChildNodes()) {
          return "";
        }
        var children = node.childNodes, childrenLength = children.length;
        for (var i = 0; i < childrenLength; ++i) {
          txt += showdown2.subParser("makeMarkdown.node")(children[i], globals, true);
        }
        return txt.trim();
      });
      showdown2.subParser("makeMarkdown.txt", function(node) {
        "use strict";
        var txt = node.nodeValue;
        txt = txt.replace(/ +/g, " ");
        txt = txt.replace(/¨NBSP;/g, " ");
        txt = showdown2.helper.unescapeHTMLEntities(txt);
        txt = txt.replace(/([*_~|`])/g, "\\$1");
        txt = txt.replace(/^(\s*)>/g, "\\$1>");
        txt = txt.replace(/^#/gm, "\\#");
        txt = txt.replace(/^(\s*)([-=]{3,})(\s*)$/, "$1\\$2$3");
        txt = txt.replace(/^( {0,3}\d+)\./gm, "$1\\.");
        txt = txt.replace(/^( {0,3})([+-])/gm, "$1\\$2");
        txt = txt.replace(/]([\s]*)\(/g, "\\]$1\\(");
        txt = txt.replace(/^ {0,3}\[([\S \t]*?)]:/gm, "\\[$1]:");
        return txt;
      });
      var root = this;
      if (typeof define === "function" && define.amd) {
        define(function() {
          "use strict";
          return showdown2;
        });
      } else if (typeof module !== "undefined" && module.exports) {
        module.exports = showdown2;
      } else {
        root.showdown = showdown2;
      }
    }).call(exports2);
  }
});

// node_modules/@strapi/plugin-seo/node_modules/react-intl/lib/src/components/useIntl.js
var React3 = __toESM(require_react());

// node_modules/@strapi/plugin-seo/node_modules/react-intl/lib/src/utils.js
var React = __toESM(require_react());

// node_modules/@strapi/plugin-seo/node_modules/@formatjs/ecma402-abstract/lib/262.js
var MINUTES_PER_HOUR = 60;
var SECONDS_PER_MINUTE = 60;
var MS_PER_SECOND = 1e3;
var MS_PER_MINUTE = MS_PER_SECOND * SECONDS_PER_MINUTE;
var MS_PER_HOUR = MS_PER_MINUTE * MINUTES_PER_HOUR;

// node_modules/@strapi/plugin-seo/node_modules/@formatjs/ecma402-abstract/lib/IsSanctionedSimpleUnitIdentifier.js
var SANCTIONED_UNITS = [
  "angle-degree",
  "area-acre",
  "area-hectare",
  "concentr-percent",
  "digital-bit",
  "digital-byte",
  "digital-gigabit",
  "digital-gigabyte",
  "digital-kilobit",
  "digital-kilobyte",
  "digital-megabit",
  "digital-megabyte",
  "digital-petabyte",
  "digital-terabit",
  "digital-terabyte",
  "duration-day",
  "duration-hour",
  "duration-millisecond",
  "duration-minute",
  "duration-month",
  "duration-second",
  "duration-week",
  "duration-year",
  "length-centimeter",
  "length-foot",
  "length-inch",
  "length-kilometer",
  "length-meter",
  "length-mile-scandinavian",
  "length-mile",
  "length-millimeter",
  "length-yard",
  "mass-gram",
  "mass-kilogram",
  "mass-ounce",
  "mass-pound",
  "mass-stone",
  "temperature-celsius",
  "temperature-fahrenheit",
  "volume-fluid-ounce",
  "volume-gallon",
  "volume-liter",
  "volume-milliliter"
];
function removeUnitNamespace(unit) {
  return unit.slice(unit.indexOf("-") + 1);
}
var SIMPLE_UNITS = SANCTIONED_UNITS.map(removeUnitNamespace);

// node_modules/@formatjs/fast-memoize/lib/index.js
function memoize(fn, options) {
  var cache = options && options.cache ? options.cache : cacheDefault;
  var serializer = options && options.serializer ? options.serializer : serializerDefault;
  var strategy = options && options.strategy ? options.strategy : strategyDefault;
  return strategy(fn, {
    cache,
    serializer
  });
}
function isPrimitive(value) {
  return value == null || typeof value === "number" || typeof value === "boolean";
}
function monadic(fn, cache, serializer, arg) {
  var cacheKey = isPrimitive(arg) ? arg : serializer(arg);
  var computedValue = cache.get(cacheKey);
  if (typeof computedValue === "undefined") {
    computedValue = fn.call(this, arg);
    cache.set(cacheKey, computedValue);
  }
  return computedValue;
}
function variadic(fn, cache, serializer) {
  var args = Array.prototype.slice.call(arguments, 3);
  var cacheKey = serializer(args);
  var computedValue = cache.get(cacheKey);
  if (typeof computedValue === "undefined") {
    computedValue = fn.apply(this, args);
    cache.set(cacheKey, computedValue);
  }
  return computedValue;
}
function assemble(fn, context, strategy, cache, serialize) {
  return strategy.bind(context, fn, cache, serialize);
}
function strategyDefault(fn, options) {
  var strategy = fn.length === 1 ? monadic : variadic;
  return assemble(fn, this, strategy, options.cache.create(), options.serializer);
}
function strategyVariadic(fn, options) {
  return assemble(fn, this, variadic, options.cache.create(), options.serializer);
}
function strategyMonadic(fn, options) {
  return assemble(fn, this, monadic, options.cache.create(), options.serializer);
}
var serializerDefault = function() {
  return JSON.stringify(arguments);
};
function ObjectWithoutPrototypeCache() {
  this.cache = /* @__PURE__ */ Object.create(null);
}
ObjectWithoutPrototypeCache.prototype.get = function(key) {
  return this.cache[key];
};
ObjectWithoutPrototypeCache.prototype.set = function(key, value) {
  this.cache[key] = value;
};
var cacheDefault = {
  create: function create() {
    return new ObjectWithoutPrototypeCache();
  }
};
var strategies = {
  variadic: strategyVariadic,
  monadic: strategyMonadic
};

// node_modules/@strapi/plugin-seo/node_modules/@formatjs/ecma402-abstract/lib/utils.js
function invariant(condition, message, Err) {
  if (Err === void 0) {
    Err = Error;
  }
  if (!condition) {
    throw new Err(message);
  }
}
var createMemoizedNumberFormat = memoize(function() {
  var _a2;
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return new ((_a2 = Intl.NumberFormat).bind.apply(_a2, __spreadArray([void 0], args, false)))();
}, {
  strategy: strategies.variadic
});
var createMemoizedDateTimeFormat = memoize(function() {
  var _a2;
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return new ((_a2 = Intl.DateTimeFormat).bind.apply(_a2, __spreadArray([void 0], args, false)))();
}, {
  strategy: strategies.variadic
});
var createMemoizedPluralRules = memoize(function() {
  var _a2;
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return new ((_a2 = Intl.PluralRules).bind.apply(_a2, __spreadArray([void 0], args, false)))();
}, {
  strategy: strategies.variadic
});
var createMemoizedLocale = memoize(function() {
  var _a2;
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return new ((_a2 = Intl.Locale).bind.apply(_a2, __spreadArray([void 0], args, false)))();
}, {
  strategy: strategies.variadic
});
var createMemoizedListFormat = memoize(function() {
  var _a2;
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return new ((_a2 = Intl.ListFormat).bind.apply(_a2, __spreadArray([void 0], args, false)))();
}, {
  strategy: strategies.variadic
});

// node_modules/@strapi/plugin-seo/node_modules/@formatjs/ecma402-abstract/lib/regex.generated.js
var S_UNICODE_REGEX = /[\$\+<->\^`\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20BF\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2E50\u2E51\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uAB6A\uAB6B\uFB29\uFBB2-\uFBC1\uFDFC\uFDFD\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDE8\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEE0-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF73\uDF80-\uDFD8\uDFE0-\uDFEB]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDD78\uDD7A-\uDDCB\uDDCD-\uDE53\uDE60-\uDE6D\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6\uDF00-\uDF92\uDF94-\uDFCA]/;

// node_modules/@strapi/plugin-seo/node_modules/@formatjs/ecma402-abstract/lib/NumberFormat/format_to_parts.js
var CARET_S_UNICODE_REGEX = new RegExp("^".concat(S_UNICODE_REGEX.source));
var S_DOLLAR_UNICODE_REGEX = new RegExp("".concat(S_UNICODE_REGEX.source, "$"));

// node_modules/@strapi/plugin-seo/node_modules/@formatjs/ecma402-abstract/lib/data.js
var MissingLocaleDataError = (
  /** @class */
  function(_super) {
    __extends(MissingLocaleDataError2, _super);
    function MissingLocaleDataError2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "MISSING_LOCALE_DATA";
      return _this;
    }
    return MissingLocaleDataError2;
  }(Error)
);

// node_modules/@strapi/plugin-seo/node_modules/@formatjs/ecma402-abstract/lib/types/date-time.js
var RangePatternType;
(function(RangePatternType2) {
  RangePatternType2["startRange"] = "startRange";
  RangePatternType2["shared"] = "shared";
  RangePatternType2["endRange"] = "endRange";
})(RangePatternType || (RangePatternType = {}));

// node_modules/@strapi/plugin-seo/node_modules/@formatjs/icu-messageformat-parser/lib/error.js
var ErrorKind;
(function(ErrorKind2) {
  ErrorKind2[ErrorKind2["EXPECT_ARGUMENT_CLOSING_BRACE"] = 1] = "EXPECT_ARGUMENT_CLOSING_BRACE";
  ErrorKind2[ErrorKind2["EMPTY_ARGUMENT"] = 2] = "EMPTY_ARGUMENT";
  ErrorKind2[ErrorKind2["MALFORMED_ARGUMENT"] = 3] = "MALFORMED_ARGUMENT";
  ErrorKind2[ErrorKind2["EXPECT_ARGUMENT_TYPE"] = 4] = "EXPECT_ARGUMENT_TYPE";
  ErrorKind2[ErrorKind2["INVALID_ARGUMENT_TYPE"] = 5] = "INVALID_ARGUMENT_TYPE";
  ErrorKind2[ErrorKind2["EXPECT_ARGUMENT_STYLE"] = 6] = "EXPECT_ARGUMENT_STYLE";
  ErrorKind2[ErrorKind2["INVALID_NUMBER_SKELETON"] = 7] = "INVALID_NUMBER_SKELETON";
  ErrorKind2[ErrorKind2["INVALID_DATE_TIME_SKELETON"] = 8] = "INVALID_DATE_TIME_SKELETON";
  ErrorKind2[ErrorKind2["EXPECT_NUMBER_SKELETON"] = 9] = "EXPECT_NUMBER_SKELETON";
  ErrorKind2[ErrorKind2["EXPECT_DATE_TIME_SKELETON"] = 10] = "EXPECT_DATE_TIME_SKELETON";
  ErrorKind2[ErrorKind2["UNCLOSED_QUOTE_IN_ARGUMENT_STYLE"] = 11] = "UNCLOSED_QUOTE_IN_ARGUMENT_STYLE";
  ErrorKind2[ErrorKind2["EXPECT_SELECT_ARGUMENT_OPTIONS"] = 12] = "EXPECT_SELECT_ARGUMENT_OPTIONS";
  ErrorKind2[ErrorKind2["EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE"] = 13] = "EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE";
  ErrorKind2[ErrorKind2["INVALID_PLURAL_ARGUMENT_OFFSET_VALUE"] = 14] = "INVALID_PLURAL_ARGUMENT_OFFSET_VALUE";
  ErrorKind2[ErrorKind2["EXPECT_SELECT_ARGUMENT_SELECTOR"] = 15] = "EXPECT_SELECT_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["EXPECT_PLURAL_ARGUMENT_SELECTOR"] = 16] = "EXPECT_PLURAL_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT"] = 17] = "EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT";
  ErrorKind2[ErrorKind2["EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT"] = 18] = "EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT";
  ErrorKind2[ErrorKind2["INVALID_PLURAL_ARGUMENT_SELECTOR"] = 19] = "INVALID_PLURAL_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["DUPLICATE_PLURAL_ARGUMENT_SELECTOR"] = 20] = "DUPLICATE_PLURAL_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["DUPLICATE_SELECT_ARGUMENT_SELECTOR"] = 21] = "DUPLICATE_SELECT_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["MISSING_OTHER_CLAUSE"] = 22] = "MISSING_OTHER_CLAUSE";
  ErrorKind2[ErrorKind2["INVALID_TAG"] = 23] = "INVALID_TAG";
  ErrorKind2[ErrorKind2["INVALID_TAG_NAME"] = 25] = "INVALID_TAG_NAME";
  ErrorKind2[ErrorKind2["UNMATCHED_CLOSING_TAG"] = 26] = "UNMATCHED_CLOSING_TAG";
  ErrorKind2[ErrorKind2["UNCLOSED_TAG"] = 27] = "UNCLOSED_TAG";
})(ErrorKind || (ErrorKind = {}));

// node_modules/@strapi/plugin-seo/node_modules/@formatjs/icu-messageformat-parser/lib/types.js
var TYPE;
(function(TYPE2) {
  TYPE2[TYPE2["literal"] = 0] = "literal";
  TYPE2[TYPE2["argument"] = 1] = "argument";
  TYPE2[TYPE2["number"] = 2] = "number";
  TYPE2[TYPE2["date"] = 3] = "date";
  TYPE2[TYPE2["time"] = 4] = "time";
  TYPE2[TYPE2["select"] = 5] = "select";
  TYPE2[TYPE2["plural"] = 6] = "plural";
  TYPE2[TYPE2["pound"] = 7] = "pound";
  TYPE2[TYPE2["tag"] = 8] = "tag";
})(TYPE || (TYPE = {}));
var SKELETON_TYPE;
(function(SKELETON_TYPE2) {
  SKELETON_TYPE2[SKELETON_TYPE2["number"] = 0] = "number";
  SKELETON_TYPE2[SKELETON_TYPE2["dateTime"] = 1] = "dateTime";
})(SKELETON_TYPE || (SKELETON_TYPE = {}));
function isLiteralElement(el) {
  return el.type === TYPE.literal;
}
function isArgumentElement(el) {
  return el.type === TYPE.argument;
}
function isNumberElement(el) {
  return el.type === TYPE.number;
}
function isDateElement(el) {
  return el.type === TYPE.date;
}
function isTimeElement(el) {
  return el.type === TYPE.time;
}
function isSelectElement(el) {
  return el.type === TYPE.select;
}
function isPluralElement(el) {
  return el.type === TYPE.plural;
}
function isPoundElement(el) {
  return el.type === TYPE.pound;
}
function isTagElement(el) {
  return el.type === TYPE.tag;
}
function isNumberSkeleton(el) {
  return !!(el && typeof el === "object" && el.type === SKELETON_TYPE.number);
}
function isDateTimeSkeleton(el) {
  return !!(el && typeof el === "object" && el.type === SKELETON_TYPE.dateTime);
}

// node_modules/@strapi/plugin-seo/node_modules/@formatjs/icu-messageformat-parser/lib/regex.generated.js
var SPACE_SEPARATOR_REGEX = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/;

// node_modules/@strapi/plugin-seo/node_modules/@formatjs/icu-skeleton-parser/lib/date-time.js
var DATE_TIME_REGEX = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;
function parseDateTimeSkeleton(skeleton) {
  var result = {};
  skeleton.replace(DATE_TIME_REGEX, function(match2) {
    var len = match2.length;
    switch (match2[0]) {
      case "G":
        result.era = len === 4 ? "long" : len === 5 ? "narrow" : "short";
        break;
      case "y":
        result.year = len === 2 ? "2-digit" : "numeric";
        break;
      case "Y":
      case "u":
      case "U":
      case "r":
        throw new RangeError("`Y/u/U/r` (year) patterns are not supported, use `y` instead");
      case "q":
      case "Q":
        throw new RangeError("`q/Q` (quarter) patterns are not supported");
      case "M":
      case "L":
        result.month = ["numeric", "2-digit", "short", "long", "narrow"][len - 1];
        break;
      case "w":
      case "W":
        throw new RangeError("`w/W` (week) patterns are not supported");
      case "d":
        result.day = ["numeric", "2-digit"][len - 1];
        break;
      case "D":
      case "F":
      case "g":
        throw new RangeError("`D/F/g` (day) patterns are not supported, use `d` instead");
      case "E":
        result.weekday = len === 4 ? "long" : len === 5 ? "narrow" : "short";
        break;
      case "e":
        if (len < 4) {
          throw new RangeError("`e..eee` (weekday) patterns are not supported");
        }
        result.weekday = ["short", "long", "narrow", "short"][len - 4];
        break;
      case "c":
        if (len < 4) {
          throw new RangeError("`c..ccc` (weekday) patterns are not supported");
        }
        result.weekday = ["short", "long", "narrow", "short"][len - 4];
        break;
      case "a":
        result.hour12 = true;
        break;
      case "b":
      case "B":
        throw new RangeError("`b/B` (period) patterns are not supported, use `a` instead");
      case "h":
        result.hourCycle = "h12";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "H":
        result.hourCycle = "h23";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "K":
        result.hourCycle = "h11";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "k":
        result.hourCycle = "h24";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "j":
      case "J":
      case "C":
        throw new RangeError("`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead");
      case "m":
        result.minute = ["numeric", "2-digit"][len - 1];
        break;
      case "s":
        result.second = ["numeric", "2-digit"][len - 1];
        break;
      case "S":
      case "A":
        throw new RangeError("`S/A` (second) patterns are not supported, use `s` instead");
      case "z":
        result.timeZoneName = len < 4 ? "short" : "long";
        break;
      case "Z":
      case "O":
      case "v":
      case "V":
      case "X":
      case "x":
        throw new RangeError("`Z/O/v/V/X/x` (timeZone) patterns are not supported, use `z` instead");
    }
    return "";
  });
  return result;
}

// node_modules/@strapi/plugin-seo/node_modules/@formatjs/icu-skeleton-parser/lib/regex.generated.js
var WHITE_SPACE_REGEX = /[\t-\r \x85\u200E\u200F\u2028\u2029]/i;

// node_modules/@strapi/plugin-seo/node_modules/@formatjs/icu-skeleton-parser/lib/number.js
function parseNumberSkeletonFromString(skeleton) {
  if (skeleton.length === 0) {
    throw new Error("Number skeleton cannot be empty");
  }
  var stringTokens = skeleton.split(WHITE_SPACE_REGEX).filter(function(x) {
    return x.length > 0;
  });
  var tokens = [];
  for (var _i = 0, stringTokens_1 = stringTokens; _i < stringTokens_1.length; _i++) {
    var stringToken = stringTokens_1[_i];
    var stemAndOptions = stringToken.split("/");
    if (stemAndOptions.length === 0) {
      throw new Error("Invalid number skeleton");
    }
    var stem = stemAndOptions[0], options = stemAndOptions.slice(1);
    for (var _a2 = 0, options_1 = options; _a2 < options_1.length; _a2++) {
      var option = options_1[_a2];
      if (option.length === 0) {
        throw new Error("Invalid number skeleton");
      }
    }
    tokens.push({ stem, options });
  }
  return tokens;
}
function icuUnitToEcma(unit) {
  return unit.replace(/^(.*?)-/, "");
}
var FRACTION_PRECISION_REGEX = /^\.(?:(0+)(\*)?|(#+)|(0+)(#+))$/g;
var SIGNIFICANT_PRECISION_REGEX = /^(@+)?(\+|#+)?[rs]?$/g;
var INTEGER_WIDTH_REGEX = /(\*)(0+)|(#+)(0+)|(0+)/g;
var CONCISE_INTEGER_WIDTH_REGEX = /^(0+)$/;
function parseSignificantPrecision(str) {
  var result = {};
  if (str[str.length - 1] === "r") {
    result.roundingPriority = "morePrecision";
  } else if (str[str.length - 1] === "s") {
    result.roundingPriority = "lessPrecision";
  }
  str.replace(SIGNIFICANT_PRECISION_REGEX, function(_, g1, g2) {
    if (typeof g2 !== "string") {
      result.minimumSignificantDigits = g1.length;
      result.maximumSignificantDigits = g1.length;
    } else if (g2 === "+") {
      result.minimumSignificantDigits = g1.length;
    } else if (g1[0] === "#") {
      result.maximumSignificantDigits = g1.length;
    } else {
      result.minimumSignificantDigits = g1.length;
      result.maximumSignificantDigits = g1.length + (typeof g2 === "string" ? g2.length : 0);
    }
    return "";
  });
  return result;
}
function parseSign(str) {
  switch (str) {
    case "sign-auto":
      return {
        signDisplay: "auto"
      };
    case "sign-accounting":
    case "()":
      return {
        currencySign: "accounting"
      };
    case "sign-always":
    case "+!":
      return {
        signDisplay: "always"
      };
    case "sign-accounting-always":
    case "()!":
      return {
        signDisplay: "always",
        currencySign: "accounting"
      };
    case "sign-except-zero":
    case "+?":
      return {
        signDisplay: "exceptZero"
      };
    case "sign-accounting-except-zero":
    case "()?":
      return {
        signDisplay: "exceptZero",
        currencySign: "accounting"
      };
    case "sign-never":
    case "+_":
      return {
        signDisplay: "never"
      };
  }
}
function parseConciseScientificAndEngineeringStem(stem) {
  var result;
  if (stem[0] === "E" && stem[1] === "E") {
    result = {
      notation: "engineering"
    };
    stem = stem.slice(2);
  } else if (stem[0] === "E") {
    result = {
      notation: "scientific"
    };
    stem = stem.slice(1);
  }
  if (result) {
    var signDisplay = stem.slice(0, 2);
    if (signDisplay === "+!") {
      result.signDisplay = "always";
      stem = stem.slice(2);
    } else if (signDisplay === "+?") {
      result.signDisplay = "exceptZero";
      stem = stem.slice(2);
    }
    if (!CONCISE_INTEGER_WIDTH_REGEX.test(stem)) {
      throw new Error("Malformed concise eng/scientific notation");
    }
    result.minimumIntegerDigits = stem.length;
  }
  return result;
}
function parseNotationOptions(opt) {
  var result = {};
  var signOpts = parseSign(opt);
  if (signOpts) {
    return signOpts;
  }
  return result;
}
function parseNumberSkeleton(tokens) {
  var result = {};
  for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
    var token = tokens_1[_i];
    switch (token.stem) {
      case "percent":
      case "%":
        result.style = "percent";
        continue;
      case "%x100":
        result.style = "percent";
        result.scale = 100;
        continue;
      case "currency":
        result.style = "currency";
        result.currency = token.options[0];
        continue;
      case "group-off":
      case ",_":
        result.useGrouping = false;
        continue;
      case "precision-integer":
      case ".":
        result.maximumFractionDigits = 0;
        continue;
      case "measure-unit":
      case "unit":
        result.style = "unit";
        result.unit = icuUnitToEcma(token.options[0]);
        continue;
      case "compact-short":
      case "K":
        result.notation = "compact";
        result.compactDisplay = "short";
        continue;
      case "compact-long":
      case "KK":
        result.notation = "compact";
        result.compactDisplay = "long";
        continue;
      case "scientific":
        result = __assign(__assign(__assign({}, result), { notation: "scientific" }), token.options.reduce(function(all, opt2) {
          return __assign(__assign({}, all), parseNotationOptions(opt2));
        }, {}));
        continue;
      case "engineering":
        result = __assign(__assign(__assign({}, result), { notation: "engineering" }), token.options.reduce(function(all, opt2) {
          return __assign(__assign({}, all), parseNotationOptions(opt2));
        }, {}));
        continue;
      case "notation-simple":
        result.notation = "standard";
        continue;
      case "unit-width-narrow":
        result.currencyDisplay = "narrowSymbol";
        result.unitDisplay = "narrow";
        continue;
      case "unit-width-short":
        result.currencyDisplay = "code";
        result.unitDisplay = "short";
        continue;
      case "unit-width-full-name":
        result.currencyDisplay = "name";
        result.unitDisplay = "long";
        continue;
      case "unit-width-iso-code":
        result.currencyDisplay = "symbol";
        continue;
      case "scale":
        result.scale = parseFloat(token.options[0]);
        continue;
      case "rounding-mode-floor":
        result.roundingMode = "floor";
        continue;
      case "rounding-mode-ceiling":
        result.roundingMode = "ceil";
        continue;
      case "rounding-mode-down":
        result.roundingMode = "trunc";
        continue;
      case "rounding-mode-up":
        result.roundingMode = "expand";
        continue;
      case "rounding-mode-half-even":
        result.roundingMode = "halfEven";
        continue;
      case "rounding-mode-half-down":
        result.roundingMode = "halfTrunc";
        continue;
      case "rounding-mode-half-up":
        result.roundingMode = "halfExpand";
        continue;
      case "integer-width":
        if (token.options.length > 1) {
          throw new RangeError("integer-width stems only accept a single optional option");
        }
        token.options[0].replace(INTEGER_WIDTH_REGEX, function(_, g1, g2, g3, g4, g5) {
          if (g1) {
            result.minimumIntegerDigits = g2.length;
          } else if (g3 && g4) {
            throw new Error("We currently do not support maximum integer digits");
          } else if (g5) {
            throw new Error("We currently do not support exact integer digits");
          }
          return "";
        });
        continue;
    }
    if (CONCISE_INTEGER_WIDTH_REGEX.test(token.stem)) {
      result.minimumIntegerDigits = token.stem.length;
      continue;
    }
    if (FRACTION_PRECISION_REGEX.test(token.stem)) {
      if (token.options.length > 1) {
        throw new RangeError("Fraction-precision stems only accept a single optional option");
      }
      token.stem.replace(FRACTION_PRECISION_REGEX, function(_, g1, g2, g3, g4, g5) {
        if (g2 === "*") {
          result.minimumFractionDigits = g1.length;
        } else if (g3 && g3[0] === "#") {
          result.maximumFractionDigits = g3.length;
        } else if (g4 && g5) {
          result.minimumFractionDigits = g4.length;
          result.maximumFractionDigits = g4.length + g5.length;
        } else {
          result.minimumFractionDigits = g1.length;
          result.maximumFractionDigits = g1.length;
        }
        return "";
      });
      var opt = token.options[0];
      if (opt === "w") {
        result = __assign(__assign({}, result), { trailingZeroDisplay: "stripIfInteger" });
      } else if (opt) {
        result = __assign(__assign({}, result), parseSignificantPrecision(opt));
      }
      continue;
    }
    if (SIGNIFICANT_PRECISION_REGEX.test(token.stem)) {
      result = __assign(__assign({}, result), parseSignificantPrecision(token.stem));
      continue;
    }
    var signOpts = parseSign(token.stem);
    if (signOpts) {
      result = __assign(__assign({}, result), signOpts);
    }
    var conciseScientificAndEngineeringOpts = parseConciseScientificAndEngineeringStem(token.stem);
    if (conciseScientificAndEngineeringOpts) {
      result = __assign(__assign({}, result), conciseScientificAndEngineeringOpts);
    }
  }
  return result;
}

// node_modules/@strapi/plugin-seo/node_modules/@formatjs/icu-messageformat-parser/lib/time-data.generated.js
var timeData = {
  "001": [
    "H",
    "h"
  ],
  "419": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "AC": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "AD": [
    "H",
    "hB"
  ],
  "AE": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "AF": [
    "H",
    "hb",
    "hB",
    "h"
  ],
  "AG": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "AI": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "AL": [
    "h",
    "H",
    "hB"
  ],
  "AM": [
    "H",
    "hB"
  ],
  "AO": [
    "H",
    "hB"
  ],
  "AR": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "AS": [
    "h",
    "H"
  ],
  "AT": [
    "H",
    "hB"
  ],
  "AU": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "AW": [
    "H",
    "hB"
  ],
  "AX": [
    "H"
  ],
  "AZ": [
    "H",
    "hB",
    "h"
  ],
  "BA": [
    "H",
    "hB",
    "h"
  ],
  "BB": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "BD": [
    "h",
    "hB",
    "H"
  ],
  "BE": [
    "H",
    "hB"
  ],
  "BF": [
    "H",
    "hB"
  ],
  "BG": [
    "H",
    "hB",
    "h"
  ],
  "BH": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "BI": [
    "H",
    "h"
  ],
  "BJ": [
    "H",
    "hB"
  ],
  "BL": [
    "H",
    "hB"
  ],
  "BM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "BN": [
    "hb",
    "hB",
    "h",
    "H"
  ],
  "BO": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "BQ": [
    "H"
  ],
  "BR": [
    "H",
    "hB"
  ],
  "BS": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "BT": [
    "h",
    "H"
  ],
  "BW": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "BY": [
    "H",
    "h"
  ],
  "BZ": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "CA": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "CC": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "CD": [
    "hB",
    "H"
  ],
  "CF": [
    "H",
    "h",
    "hB"
  ],
  "CG": [
    "H",
    "hB"
  ],
  "CH": [
    "H",
    "hB",
    "h"
  ],
  "CI": [
    "H",
    "hB"
  ],
  "CK": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "CL": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "CM": [
    "H",
    "h",
    "hB"
  ],
  "CN": [
    "H",
    "hB",
    "hb",
    "h"
  ],
  "CO": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "CP": [
    "H"
  ],
  "CR": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "CU": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "CV": [
    "H",
    "hB"
  ],
  "CW": [
    "H",
    "hB"
  ],
  "CX": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "CY": [
    "h",
    "H",
    "hb",
    "hB"
  ],
  "CZ": [
    "H"
  ],
  "DE": [
    "H",
    "hB"
  ],
  "DG": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "DJ": [
    "h",
    "H"
  ],
  "DK": [
    "H"
  ],
  "DM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "DO": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "DZ": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "EA": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "EC": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "EE": [
    "H",
    "hB"
  ],
  "EG": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "EH": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "ER": [
    "h",
    "H"
  ],
  "ES": [
    "H",
    "hB",
    "h",
    "hb"
  ],
  "ET": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "FI": [
    "H"
  ],
  "FJ": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "FK": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "FM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "FO": [
    "H",
    "h"
  ],
  "FR": [
    "H",
    "hB"
  ],
  "GA": [
    "H",
    "hB"
  ],
  "GB": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "GD": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "GE": [
    "H",
    "hB",
    "h"
  ],
  "GF": [
    "H",
    "hB"
  ],
  "GG": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "GH": [
    "h",
    "H"
  ],
  "GI": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "GL": [
    "H",
    "h"
  ],
  "GM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "GN": [
    "H",
    "hB"
  ],
  "GP": [
    "H",
    "hB"
  ],
  "GQ": [
    "H",
    "hB",
    "h",
    "hb"
  ],
  "GR": [
    "h",
    "H",
    "hb",
    "hB"
  ],
  "GT": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "GU": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "GW": [
    "H",
    "hB"
  ],
  "GY": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "HK": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "HN": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "HR": [
    "H",
    "hB"
  ],
  "HU": [
    "H",
    "h"
  ],
  "IC": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "ID": [
    "H"
  ],
  "IE": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "IL": [
    "H",
    "hB"
  ],
  "IM": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "IN": [
    "h",
    "H"
  ],
  "IO": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "IQ": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "IR": [
    "hB",
    "H"
  ],
  "IS": [
    "H"
  ],
  "IT": [
    "H",
    "hB"
  ],
  "JE": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "JM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "JO": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "JP": [
    "H",
    "K",
    "h"
  ],
  "KE": [
    "hB",
    "hb",
    "H",
    "h"
  ],
  "KG": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "KH": [
    "hB",
    "h",
    "H",
    "hb"
  ],
  "KI": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "KM": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "KN": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "KP": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "KR": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "KW": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "KY": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "KZ": [
    "H",
    "hB"
  ],
  "LA": [
    "H",
    "hb",
    "hB",
    "h"
  ],
  "LB": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "LC": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "LI": [
    "H",
    "hB",
    "h"
  ],
  "LK": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "LR": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "LS": [
    "h",
    "H"
  ],
  "LT": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "LU": [
    "H",
    "h",
    "hB"
  ],
  "LV": [
    "H",
    "hB",
    "hb",
    "h"
  ],
  "LY": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "MA": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "MC": [
    "H",
    "hB"
  ],
  "MD": [
    "H",
    "hB"
  ],
  "ME": [
    "H",
    "hB",
    "h"
  ],
  "MF": [
    "H",
    "hB"
  ],
  "MG": [
    "H",
    "h"
  ],
  "MH": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "MK": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "ML": [
    "H"
  ],
  "MM": [
    "hB",
    "hb",
    "H",
    "h"
  ],
  "MN": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "MO": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "MP": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "MQ": [
    "H",
    "hB"
  ],
  "MR": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "MS": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "MT": [
    "H",
    "h"
  ],
  "MU": [
    "H",
    "h"
  ],
  "MV": [
    "H",
    "h"
  ],
  "MW": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "MX": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "MY": [
    "hb",
    "hB",
    "h",
    "H"
  ],
  "MZ": [
    "H",
    "hB"
  ],
  "NA": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "NC": [
    "H",
    "hB"
  ],
  "NE": [
    "H"
  ],
  "NF": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "NG": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "NI": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "NL": [
    "H",
    "hB"
  ],
  "NO": [
    "H",
    "h"
  ],
  "NP": [
    "H",
    "h",
    "hB"
  ],
  "NR": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "NU": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "NZ": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "OM": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "PA": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "PE": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "PF": [
    "H",
    "h",
    "hB"
  ],
  "PG": [
    "h",
    "H"
  ],
  "PH": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "PK": [
    "h",
    "hB",
    "H"
  ],
  "PL": [
    "H",
    "h"
  ],
  "PM": [
    "H",
    "hB"
  ],
  "PN": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "PR": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "PS": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "PT": [
    "H",
    "hB"
  ],
  "PW": [
    "h",
    "H"
  ],
  "PY": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "QA": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "RE": [
    "H",
    "hB"
  ],
  "RO": [
    "H",
    "hB"
  ],
  "RS": [
    "H",
    "hB",
    "h"
  ],
  "RU": [
    "H"
  ],
  "RW": [
    "H",
    "h"
  ],
  "SA": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "SB": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "SC": [
    "H",
    "h",
    "hB"
  ],
  "SD": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "SE": [
    "H"
  ],
  "SG": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "SH": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "SI": [
    "H",
    "hB"
  ],
  "SJ": [
    "H"
  ],
  "SK": [
    "H"
  ],
  "SL": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "SM": [
    "H",
    "h",
    "hB"
  ],
  "SN": [
    "H",
    "h",
    "hB"
  ],
  "SO": [
    "h",
    "H"
  ],
  "SR": [
    "H",
    "hB"
  ],
  "SS": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "ST": [
    "H",
    "hB"
  ],
  "SV": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "SX": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "SY": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "SZ": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "TA": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "TC": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "TD": [
    "h",
    "H",
    "hB"
  ],
  "TF": [
    "H",
    "h",
    "hB"
  ],
  "TG": [
    "H",
    "hB"
  ],
  "TH": [
    "H",
    "h"
  ],
  "TJ": [
    "H",
    "h"
  ],
  "TL": [
    "H",
    "hB",
    "hb",
    "h"
  ],
  "TM": [
    "H",
    "h"
  ],
  "TN": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "TO": [
    "h",
    "H"
  ],
  "TR": [
    "H",
    "hB"
  ],
  "TT": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "TW": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "TZ": [
    "hB",
    "hb",
    "H",
    "h"
  ],
  "UA": [
    "H",
    "hB",
    "h"
  ],
  "UG": [
    "hB",
    "hb",
    "H",
    "h"
  ],
  "UM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "US": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "UY": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "UZ": [
    "H",
    "hB",
    "h"
  ],
  "VA": [
    "H",
    "h",
    "hB"
  ],
  "VC": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "VE": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "VG": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "VI": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "VN": [
    "H",
    "h"
  ],
  "VU": [
    "h",
    "H"
  ],
  "WF": [
    "H",
    "hB"
  ],
  "WS": [
    "h",
    "H"
  ],
  "XK": [
    "H",
    "hB",
    "h"
  ],
  "YE": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "YT": [
    "H",
    "hB"
  ],
  "ZA": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "ZM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "ZW": [
    "H",
    "h"
  ],
  "af-ZA": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "ar-001": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "ca-ES": [
    "H",
    "h",
    "hB"
  ],
  "en-001": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "en-HK": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "en-IL": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "en-MY": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "es-BR": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "es-ES": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "es-GQ": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "fr-CA": [
    "H",
    "h",
    "hB"
  ],
  "gl-ES": [
    "H",
    "h",
    "hB"
  ],
  "gu-IN": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "hi-IN": [
    "hB",
    "h",
    "H"
  ],
  "it-CH": [
    "H",
    "h",
    "hB"
  ],
  "it-IT": [
    "H",
    "h",
    "hB"
  ],
  "kn-IN": [
    "hB",
    "h",
    "H"
  ],
  "ml-IN": [
    "hB",
    "h",
    "H"
  ],
  "mr-IN": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "pa-IN": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "ta-IN": [
    "hB",
    "h",
    "hb",
    "H"
  ],
  "te-IN": [
    "hB",
    "h",
    "H"
  ],
  "zu-ZA": [
    "H",
    "hB",
    "hb",
    "h"
  ]
};

// node_modules/@strapi/plugin-seo/node_modules/@formatjs/icu-messageformat-parser/lib/date-time-pattern-generator.js
function getBestPattern(skeleton, locale) {
  var skeletonCopy = "";
  for (var patternPos = 0; patternPos < skeleton.length; patternPos++) {
    var patternChar = skeleton.charAt(patternPos);
    if (patternChar === "j") {
      var extraLength = 0;
      while (patternPos + 1 < skeleton.length && skeleton.charAt(patternPos + 1) === patternChar) {
        extraLength++;
        patternPos++;
      }
      var hourLen = 1 + (extraLength & 1);
      var dayPeriodLen = extraLength < 2 ? 1 : 3 + (extraLength >> 1);
      var dayPeriodChar = "a";
      var hourChar = getDefaultHourSymbolFromLocale(locale);
      if (hourChar == "H" || hourChar == "k") {
        dayPeriodLen = 0;
      }
      while (dayPeriodLen-- > 0) {
        skeletonCopy += dayPeriodChar;
      }
      while (hourLen-- > 0) {
        skeletonCopy = hourChar + skeletonCopy;
      }
    } else if (patternChar === "J") {
      skeletonCopy += "H";
    } else {
      skeletonCopy += patternChar;
    }
  }
  return skeletonCopy;
}
function getDefaultHourSymbolFromLocale(locale) {
  var hourCycle = locale.hourCycle;
  if (hourCycle === void 0 && // @ts-ignore hourCycle(s) is not identified yet
  locale.hourCycles && // @ts-ignore
  locale.hourCycles.length) {
    hourCycle = locale.hourCycles[0];
  }
  if (hourCycle) {
    switch (hourCycle) {
      case "h24":
        return "k";
      case "h23":
        return "H";
      case "h12":
        return "h";
      case "h11":
        return "K";
      default:
        throw new Error("Invalid hourCycle");
    }
  }
  var languageTag = locale.language;
  var regionTag;
  if (languageTag !== "root") {
    regionTag = locale.maximize().region;
  }
  var hourCycles = timeData[regionTag || ""] || timeData[languageTag || ""] || timeData["".concat(languageTag, "-001")] || timeData["001"];
  return hourCycles[0];
}

// node_modules/@strapi/plugin-seo/node_modules/@formatjs/icu-messageformat-parser/lib/parser.js
var _a;
var SPACE_SEPARATOR_START_REGEX = new RegExp("^".concat(SPACE_SEPARATOR_REGEX.source, "*"));
var SPACE_SEPARATOR_END_REGEX = new RegExp("".concat(SPACE_SEPARATOR_REGEX.source, "*$"));
function createLocation(start, end) {
  return { start, end };
}
var hasNativeStartsWith = !!String.prototype.startsWith && "_a".startsWith("a", 1);
var hasNativeFromCodePoint = !!String.fromCodePoint;
var hasNativeFromEntries = !!Object.fromEntries;
var hasNativeCodePointAt = !!String.prototype.codePointAt;
var hasTrimStart = !!String.prototype.trimStart;
var hasTrimEnd = !!String.prototype.trimEnd;
var hasNativeIsSafeInteger = !!Number.isSafeInteger;
var isSafeInteger = hasNativeIsSafeInteger ? Number.isSafeInteger : function(n) {
  return typeof n === "number" && isFinite(n) && Math.floor(n) === n && Math.abs(n) <= 9007199254740991;
};
var REGEX_SUPPORTS_U_AND_Y = true;
try {
  re = RE("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu");
  REGEX_SUPPORTS_U_AND_Y = ((_a = re.exec("a")) === null || _a === void 0 ? void 0 : _a[0]) === "a";
} catch (_) {
  REGEX_SUPPORTS_U_AND_Y = false;
}
var re;
var startsWith = hasNativeStartsWith ? (
  // Native
  function startsWith2(s, search, position) {
    return s.startsWith(search, position);
  }
) : (
  // For IE11
  function startsWith3(s, search, position) {
    return s.slice(position, position + search.length) === search;
  }
);
var fromCodePoint = hasNativeFromCodePoint ? String.fromCodePoint : (
  // IE11
  function fromCodePoint2() {
    var codePoints = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      codePoints[_i] = arguments[_i];
    }
    var elements = "";
    var length = codePoints.length;
    var i = 0;
    var code;
    while (length > i) {
      code = codePoints[i++];
      if (code > 1114111)
        throw RangeError(code + " is not a valid code point");
      elements += code < 65536 ? String.fromCharCode(code) : String.fromCharCode(((code -= 65536) >> 10) + 55296, code % 1024 + 56320);
    }
    return elements;
  }
);
var fromEntries = (
  // native
  hasNativeFromEntries ? Object.fromEntries : (
    // Ponyfill
    function fromEntries2(entries) {
      var obj = {};
      for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
        var _a2 = entries_1[_i], k = _a2[0], v = _a2[1];
        obj[k] = v;
      }
      return obj;
    }
  )
);
var codePointAt = hasNativeCodePointAt ? (
  // Native
  function codePointAt2(s, index2) {
    return s.codePointAt(index2);
  }
) : (
  // IE 11
  function codePointAt3(s, index2) {
    var size = s.length;
    if (index2 < 0 || index2 >= size) {
      return void 0;
    }
    var first = s.charCodeAt(index2);
    var second;
    return first < 55296 || first > 56319 || index2 + 1 === size || (second = s.charCodeAt(index2 + 1)) < 56320 || second > 57343 ? first : (first - 55296 << 10) + (second - 56320) + 65536;
  }
);
var trimStart = hasTrimStart ? (
  // Native
  function trimStart2(s) {
    return s.trimStart();
  }
) : (
  // Ponyfill
  function trimStart3(s) {
    return s.replace(SPACE_SEPARATOR_START_REGEX, "");
  }
);
var trimEnd = hasTrimEnd ? (
  // Native
  function trimEnd2(s) {
    return s.trimEnd();
  }
) : (
  // Ponyfill
  function trimEnd3(s) {
    return s.replace(SPACE_SEPARATOR_END_REGEX, "");
  }
);
function RE(s, flag) {
  return new RegExp(s, flag);
}
var matchIdentifierAtIndex;
if (REGEX_SUPPORTS_U_AND_Y) {
  IDENTIFIER_PREFIX_RE_1 = RE("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu");
  matchIdentifierAtIndex = function matchIdentifierAtIndex2(s, index2) {
    var _a2;
    IDENTIFIER_PREFIX_RE_1.lastIndex = index2;
    var match2 = IDENTIFIER_PREFIX_RE_1.exec(s);
    return (_a2 = match2[1]) !== null && _a2 !== void 0 ? _a2 : "";
  };
} else {
  matchIdentifierAtIndex = function matchIdentifierAtIndex2(s, index2) {
    var match2 = [];
    while (true) {
      var c = codePointAt(s, index2);
      if (c === void 0 || _isWhiteSpace(c) || _isPatternSyntax(c)) {
        break;
      }
      match2.push(c);
      index2 += c >= 65536 ? 2 : 1;
    }
    return fromCodePoint.apply(void 0, match2);
  };
}
var IDENTIFIER_PREFIX_RE_1;
var Parser = (
  /** @class */
  function() {
    function Parser3(message, options) {
      if (options === void 0) {
        options = {};
      }
      this.message = message;
      this.position = { offset: 0, line: 1, column: 1 };
      this.ignoreTag = !!options.ignoreTag;
      this.locale = options.locale;
      this.requiresOtherClause = !!options.requiresOtherClause;
      this.shouldParseSkeletons = !!options.shouldParseSkeletons;
    }
    Parser3.prototype.parse = function() {
      if (this.offset() !== 0) {
        throw Error("parser can only be used once");
      }
      return this.parseMessage(0, "", false);
    };
    Parser3.prototype.parseMessage = function(nestingLevel, parentArgType, expectingCloseTag) {
      var elements = [];
      while (!this.isEOF()) {
        var char = this.char();
        if (char === 123) {
          var result = this.parseArgument(nestingLevel, expectingCloseTag);
          if (result.err) {
            return result;
          }
          elements.push(result.val);
        } else if (char === 125 && nestingLevel > 0) {
          break;
        } else if (char === 35 && (parentArgType === "plural" || parentArgType === "selectordinal")) {
          var position = this.clonePosition();
          this.bump();
          elements.push({
            type: TYPE.pound,
            location: createLocation(position, this.clonePosition())
          });
        } else if (char === 60 && !this.ignoreTag && this.peek() === 47) {
          if (expectingCloseTag) {
            break;
          } else {
            return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(this.clonePosition(), this.clonePosition()));
          }
        } else if (char === 60 && !this.ignoreTag && _isAlpha(this.peek() || 0)) {
          var result = this.parseTag(nestingLevel, parentArgType);
          if (result.err) {
            return result;
          }
          elements.push(result.val);
        } else {
          var result = this.parseLiteral(nestingLevel, parentArgType);
          if (result.err) {
            return result;
          }
          elements.push(result.val);
        }
      }
      return { val: elements, err: null };
    };
    Parser3.prototype.parseTag = function(nestingLevel, parentArgType) {
      var startPosition = this.clonePosition();
      this.bump();
      var tagName = this.parseTagName();
      this.bumpSpace();
      if (this.bumpIf("/>")) {
        return {
          val: {
            type: TYPE.literal,
            value: "<".concat(tagName, "/>"),
            location: createLocation(startPosition, this.clonePosition())
          },
          err: null
        };
      } else if (this.bumpIf(">")) {
        var childrenResult = this.parseMessage(nestingLevel + 1, parentArgType, true);
        if (childrenResult.err) {
          return childrenResult;
        }
        var children = childrenResult.val;
        var endTagStartPosition = this.clonePosition();
        if (this.bumpIf("</")) {
          if (this.isEOF() || !_isAlpha(this.char())) {
            return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
          }
          var closingTagNameStartPosition = this.clonePosition();
          var closingTagName = this.parseTagName();
          if (tagName !== closingTagName) {
            return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(closingTagNameStartPosition, this.clonePosition()));
          }
          this.bumpSpace();
          if (!this.bumpIf(">")) {
            return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
          }
          return {
            val: {
              type: TYPE.tag,
              value: tagName,
              children,
              location: createLocation(startPosition, this.clonePosition())
            },
            err: null
          };
        } else {
          return this.error(ErrorKind.UNCLOSED_TAG, createLocation(startPosition, this.clonePosition()));
        }
      } else {
        return this.error(ErrorKind.INVALID_TAG, createLocation(startPosition, this.clonePosition()));
      }
    };
    Parser3.prototype.parseTagName = function() {
      var startOffset = this.offset();
      this.bump();
      while (!this.isEOF() && _isPotentialElementNameChar(this.char())) {
        this.bump();
      }
      return this.message.slice(startOffset, this.offset());
    };
    Parser3.prototype.parseLiteral = function(nestingLevel, parentArgType) {
      var start = this.clonePosition();
      var value = "";
      while (true) {
        var parseQuoteResult = this.tryParseQuote(parentArgType);
        if (parseQuoteResult) {
          value += parseQuoteResult;
          continue;
        }
        var parseUnquotedResult = this.tryParseUnquoted(nestingLevel, parentArgType);
        if (parseUnquotedResult) {
          value += parseUnquotedResult;
          continue;
        }
        var parseLeftAngleResult = this.tryParseLeftAngleBracket();
        if (parseLeftAngleResult) {
          value += parseLeftAngleResult;
          continue;
        }
        break;
      }
      var location = createLocation(start, this.clonePosition());
      return {
        val: { type: TYPE.literal, value, location },
        err: null
      };
    };
    Parser3.prototype.tryParseLeftAngleBracket = function() {
      if (!this.isEOF() && this.char() === 60 && (this.ignoreTag || // If at the opening tag or closing tag position, bail.
      !_isAlphaOrSlash(this.peek() || 0))) {
        this.bump();
        return "<";
      }
      return null;
    };
    Parser3.prototype.tryParseQuote = function(parentArgType) {
      if (this.isEOF() || this.char() !== 39) {
        return null;
      }
      switch (this.peek()) {
        case 39:
          this.bump();
          this.bump();
          return "'";
        case 123:
        case 60:
        case 62:
        case 125:
          break;
        case 35:
          if (parentArgType === "plural" || parentArgType === "selectordinal") {
            break;
          }
          return null;
        default:
          return null;
      }
      this.bump();
      var codePoints = [this.char()];
      this.bump();
      while (!this.isEOF()) {
        var ch = this.char();
        if (ch === 39) {
          if (this.peek() === 39) {
            codePoints.push(39);
            this.bump();
          } else {
            this.bump();
            break;
          }
        } else {
          codePoints.push(ch);
        }
        this.bump();
      }
      return fromCodePoint.apply(void 0, codePoints);
    };
    Parser3.prototype.tryParseUnquoted = function(nestingLevel, parentArgType) {
      if (this.isEOF()) {
        return null;
      }
      var ch = this.char();
      if (ch === 60 || ch === 123 || ch === 35 && (parentArgType === "plural" || parentArgType === "selectordinal") || ch === 125 && nestingLevel > 0) {
        return null;
      } else {
        this.bump();
        return fromCodePoint(ch);
      }
    };
    Parser3.prototype.parseArgument = function(nestingLevel, expectingCloseTag) {
      var openingBracePosition = this.clonePosition();
      this.bump();
      this.bumpSpace();
      if (this.isEOF()) {
        return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
      }
      if (this.char() === 125) {
        this.bump();
        return this.error(ErrorKind.EMPTY_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
      }
      var value = this.parseIdentifierIfPossible().value;
      if (!value) {
        return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
      }
      this.bumpSpace();
      if (this.isEOF()) {
        return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
      }
      switch (this.char()) {
        case 125: {
          this.bump();
          return {
            val: {
              type: TYPE.argument,
              // value does not include the opening and closing braces.
              value,
              location: createLocation(openingBracePosition, this.clonePosition())
            },
            err: null
          };
        }
        case 44: {
          this.bump();
          this.bumpSpace();
          if (this.isEOF()) {
            return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
          }
          return this.parseArgumentOptions(nestingLevel, expectingCloseTag, value, openingBracePosition);
        }
        default:
          return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
      }
    };
    Parser3.prototype.parseIdentifierIfPossible = function() {
      var startingPosition = this.clonePosition();
      var startOffset = this.offset();
      var value = matchIdentifierAtIndex(this.message, startOffset);
      var endOffset = startOffset + value.length;
      this.bumpTo(endOffset);
      var endPosition = this.clonePosition();
      var location = createLocation(startingPosition, endPosition);
      return { value, location };
    };
    Parser3.prototype.parseArgumentOptions = function(nestingLevel, expectingCloseTag, value, openingBracePosition) {
      var _a2;
      var typeStartPosition = this.clonePosition();
      var argType = this.parseIdentifierIfPossible().value;
      var typeEndPosition = this.clonePosition();
      switch (argType) {
        case "":
          return this.error(ErrorKind.EXPECT_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
        case "number":
        case "date":
        case "time": {
          this.bumpSpace();
          var styleAndLocation = null;
          if (this.bumpIf(",")) {
            this.bumpSpace();
            var styleStartPosition = this.clonePosition();
            var result = this.parseSimpleArgStyleIfPossible();
            if (result.err) {
              return result;
            }
            var style = trimEnd(result.val);
            if (style.length === 0) {
              return this.error(ErrorKind.EXPECT_ARGUMENT_STYLE, createLocation(this.clonePosition(), this.clonePosition()));
            }
            var styleLocation = createLocation(styleStartPosition, this.clonePosition());
            styleAndLocation = { style, styleLocation };
          }
          var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
          if (argCloseResult.err) {
            return argCloseResult;
          }
          var location_1 = createLocation(openingBracePosition, this.clonePosition());
          if (styleAndLocation && startsWith(styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style, "::", 0)) {
            var skeleton = trimStart(styleAndLocation.style.slice(2));
            if (argType === "number") {
              var result = this.parseNumberSkeletonFromString(skeleton, styleAndLocation.styleLocation);
              if (result.err) {
                return result;
              }
              return {
                val: { type: TYPE.number, value, location: location_1, style: result.val },
                err: null
              };
            } else {
              if (skeleton.length === 0) {
                return this.error(ErrorKind.EXPECT_DATE_TIME_SKELETON, location_1);
              }
              var dateTimePattern = skeleton;
              if (this.locale) {
                dateTimePattern = getBestPattern(skeleton, this.locale);
              }
              var style = {
                type: SKELETON_TYPE.dateTime,
                pattern: dateTimePattern,
                location: styleAndLocation.styleLocation,
                parsedOptions: this.shouldParseSkeletons ? parseDateTimeSkeleton(dateTimePattern) : {}
              };
              var type2 = argType === "date" ? TYPE.date : TYPE.time;
              return {
                val: { type: type2, value, location: location_1, style },
                err: null
              };
            }
          }
          return {
            val: {
              type: argType === "number" ? TYPE.number : argType === "date" ? TYPE.date : TYPE.time,
              value,
              location: location_1,
              style: (_a2 = styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style) !== null && _a2 !== void 0 ? _a2 : null
            },
            err: null
          };
        }
        case "plural":
        case "selectordinal":
        case "select": {
          var typeEndPosition_1 = this.clonePosition();
          this.bumpSpace();
          if (!this.bumpIf(",")) {
            return this.error(ErrorKind.EXPECT_SELECT_ARGUMENT_OPTIONS, createLocation(typeEndPosition_1, __assign({}, typeEndPosition_1)));
          }
          this.bumpSpace();
          var identifierAndLocation = this.parseIdentifierIfPossible();
          var pluralOffset = 0;
          if (argType !== "select" && identifierAndLocation.value === "offset") {
            if (!this.bumpIf(":")) {
              return this.error(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, createLocation(this.clonePosition(), this.clonePosition()));
            }
            this.bumpSpace();
            var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, ErrorKind.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);
            if (result.err) {
              return result;
            }
            this.bumpSpace();
            identifierAndLocation = this.parseIdentifierIfPossible();
            pluralOffset = result.val;
          }
          var optionsResult = this.tryParsePluralOrSelectOptions(nestingLevel, argType, expectingCloseTag, identifierAndLocation);
          if (optionsResult.err) {
            return optionsResult;
          }
          var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
          if (argCloseResult.err) {
            return argCloseResult;
          }
          var location_2 = createLocation(openingBracePosition, this.clonePosition());
          if (argType === "select") {
            return {
              val: {
                type: TYPE.select,
                value,
                options: fromEntries(optionsResult.val),
                location: location_2
              },
              err: null
            };
          } else {
            return {
              val: {
                type: TYPE.plural,
                value,
                options: fromEntries(optionsResult.val),
                offset: pluralOffset,
                pluralType: argType === "plural" ? "cardinal" : "ordinal",
                location: location_2
              },
              err: null
            };
          }
        }
        default:
          return this.error(ErrorKind.INVALID_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
      }
    };
    Parser3.prototype.tryParseArgumentClose = function(openingBracePosition) {
      if (this.isEOF() || this.char() !== 125) {
        return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
      }
      this.bump();
      return { val: true, err: null };
    };
    Parser3.prototype.parseSimpleArgStyleIfPossible = function() {
      var nestedBraces = 0;
      var startPosition = this.clonePosition();
      while (!this.isEOF()) {
        var ch = this.char();
        switch (ch) {
          case 39: {
            this.bump();
            var apostrophePosition = this.clonePosition();
            if (!this.bumpUntil("'")) {
              return this.error(ErrorKind.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, createLocation(apostrophePosition, this.clonePosition()));
            }
            this.bump();
            break;
          }
          case 123: {
            nestedBraces += 1;
            this.bump();
            break;
          }
          case 125: {
            if (nestedBraces > 0) {
              nestedBraces -= 1;
            } else {
              return {
                val: this.message.slice(startPosition.offset, this.offset()),
                err: null
              };
            }
            break;
          }
          default:
            this.bump();
            break;
        }
      }
      return {
        val: this.message.slice(startPosition.offset, this.offset()),
        err: null
      };
    };
    Parser3.prototype.parseNumberSkeletonFromString = function(skeleton, location) {
      var tokens = [];
      try {
        tokens = parseNumberSkeletonFromString(skeleton);
      } catch (e) {
        return this.error(ErrorKind.INVALID_NUMBER_SKELETON, location);
      }
      return {
        val: {
          type: SKELETON_TYPE.number,
          tokens,
          location,
          parsedOptions: this.shouldParseSkeletons ? parseNumberSkeleton(tokens) : {}
        },
        err: null
      };
    };
    Parser3.prototype.tryParsePluralOrSelectOptions = function(nestingLevel, parentArgType, expectCloseTag, parsedFirstIdentifier) {
      var _a2;
      var hasOtherClause = false;
      var options = [];
      var parsedSelectors = /* @__PURE__ */ new Set();
      var selector = parsedFirstIdentifier.value, selectorLocation = parsedFirstIdentifier.location;
      while (true) {
        if (selector.length === 0) {
          var startPosition = this.clonePosition();
          if (parentArgType !== "select" && this.bumpIf("=")) {
            var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, ErrorKind.INVALID_PLURAL_ARGUMENT_SELECTOR);
            if (result.err) {
              return result;
            }
            selectorLocation = createLocation(startPosition, this.clonePosition());
            selector = this.message.slice(startPosition.offset, this.offset());
          } else {
            break;
          }
        }
        if (parsedSelectors.has(selector)) {
          return this.error(parentArgType === "select" ? ErrorKind.DUPLICATE_SELECT_ARGUMENT_SELECTOR : ErrorKind.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, selectorLocation);
        }
        if (selector === "other") {
          hasOtherClause = true;
        }
        this.bumpSpace();
        var openingBracePosition = this.clonePosition();
        if (!this.bumpIf("{")) {
          return this.error(parentArgType === "select" ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, createLocation(this.clonePosition(), this.clonePosition()));
        }
        var fragmentResult = this.parseMessage(nestingLevel + 1, parentArgType, expectCloseTag);
        if (fragmentResult.err) {
          return fragmentResult;
        }
        var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
        if (argCloseResult.err) {
          return argCloseResult;
        }
        options.push([
          selector,
          {
            value: fragmentResult.val,
            location: createLocation(openingBracePosition, this.clonePosition())
          }
        ]);
        parsedSelectors.add(selector);
        this.bumpSpace();
        _a2 = this.parseIdentifierIfPossible(), selector = _a2.value, selectorLocation = _a2.location;
      }
      if (options.length === 0) {
        return this.error(parentArgType === "select" ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, createLocation(this.clonePosition(), this.clonePosition()));
      }
      if (this.requiresOtherClause && !hasOtherClause) {
        return this.error(ErrorKind.MISSING_OTHER_CLAUSE, createLocation(this.clonePosition(), this.clonePosition()));
      }
      return { val: options, err: null };
    };
    Parser3.prototype.tryParseDecimalInteger = function(expectNumberError, invalidNumberError) {
      var sign = 1;
      var startingPosition = this.clonePosition();
      if (this.bumpIf("+")) {
      } else if (this.bumpIf("-")) {
        sign = -1;
      }
      var hasDigits = false;
      var decimal = 0;
      while (!this.isEOF()) {
        var ch = this.char();
        if (ch >= 48 && ch <= 57) {
          hasDigits = true;
          decimal = decimal * 10 + (ch - 48);
          this.bump();
        } else {
          break;
        }
      }
      var location = createLocation(startingPosition, this.clonePosition());
      if (!hasDigits) {
        return this.error(expectNumberError, location);
      }
      decimal *= sign;
      if (!isSafeInteger(decimal)) {
        return this.error(invalidNumberError, location);
      }
      return { val: decimal, err: null };
    };
    Parser3.prototype.offset = function() {
      return this.position.offset;
    };
    Parser3.prototype.isEOF = function() {
      return this.offset() === this.message.length;
    };
    Parser3.prototype.clonePosition = function() {
      return {
        offset: this.position.offset,
        line: this.position.line,
        column: this.position.column
      };
    };
    Parser3.prototype.char = function() {
      var offset = this.position.offset;
      if (offset >= this.message.length) {
        throw Error("out of bound");
      }
      var code = codePointAt(this.message, offset);
      if (code === void 0) {
        throw Error("Offset ".concat(offset, " is at invalid UTF-16 code unit boundary"));
      }
      return code;
    };
    Parser3.prototype.error = function(kind, location) {
      return {
        val: null,
        err: {
          kind,
          message: this.message,
          location
        }
      };
    };
    Parser3.prototype.bump = function() {
      if (this.isEOF()) {
        return;
      }
      var code = this.char();
      if (code === 10) {
        this.position.line += 1;
        this.position.column = 1;
        this.position.offset += 1;
      } else {
        this.position.column += 1;
        this.position.offset += code < 65536 ? 1 : 2;
      }
    };
    Parser3.prototype.bumpIf = function(prefix) {
      if (startsWith(this.message, prefix, this.offset())) {
        for (var i = 0; i < prefix.length; i++) {
          this.bump();
        }
        return true;
      }
      return false;
    };
    Parser3.prototype.bumpUntil = function(pattern) {
      var currentOffset = this.offset();
      var index2 = this.message.indexOf(pattern, currentOffset);
      if (index2 >= 0) {
        this.bumpTo(index2);
        return true;
      } else {
        this.bumpTo(this.message.length);
        return false;
      }
    };
    Parser3.prototype.bumpTo = function(targetOffset) {
      if (this.offset() > targetOffset) {
        throw Error("targetOffset ".concat(targetOffset, " must be greater than or equal to the current offset ").concat(this.offset()));
      }
      targetOffset = Math.min(targetOffset, this.message.length);
      while (true) {
        var offset = this.offset();
        if (offset === targetOffset) {
          break;
        }
        if (offset > targetOffset) {
          throw Error("targetOffset ".concat(targetOffset, " is at invalid UTF-16 code unit boundary"));
        }
        this.bump();
        if (this.isEOF()) {
          break;
        }
      }
    };
    Parser3.prototype.bumpSpace = function() {
      while (!this.isEOF() && _isWhiteSpace(this.char())) {
        this.bump();
      }
    };
    Parser3.prototype.peek = function() {
      if (this.isEOF()) {
        return null;
      }
      var code = this.char();
      var offset = this.offset();
      var nextCode = this.message.charCodeAt(offset + (code >= 65536 ? 2 : 1));
      return nextCode !== null && nextCode !== void 0 ? nextCode : null;
    };
    return Parser3;
  }()
);
function _isAlpha(codepoint) {
  return codepoint >= 97 && codepoint <= 122 || codepoint >= 65 && codepoint <= 90;
}
function _isAlphaOrSlash(codepoint) {
  return _isAlpha(codepoint) || codepoint === 47;
}
function _isPotentialElementNameChar(c) {
  return c === 45 || c === 46 || c >= 48 && c <= 57 || c === 95 || c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 183 || c >= 192 && c <= 214 || c >= 216 && c <= 246 || c >= 248 && c <= 893 || c >= 895 && c <= 8191 || c >= 8204 && c <= 8205 || c >= 8255 && c <= 8256 || c >= 8304 && c <= 8591 || c >= 11264 && c <= 12271 || c >= 12289 && c <= 55295 || c >= 63744 && c <= 64975 || c >= 65008 && c <= 65533 || c >= 65536 && c <= 983039;
}
function _isWhiteSpace(c) {
  return c >= 9 && c <= 13 || c === 32 || c === 133 || c >= 8206 && c <= 8207 || c === 8232 || c === 8233;
}
function _isPatternSyntax(c) {
  return c >= 33 && c <= 35 || c === 36 || c >= 37 && c <= 39 || c === 40 || c === 41 || c === 42 || c === 43 || c === 44 || c === 45 || c >= 46 && c <= 47 || c >= 58 && c <= 59 || c >= 60 && c <= 62 || c >= 63 && c <= 64 || c === 91 || c === 92 || c === 93 || c === 94 || c === 96 || c === 123 || c === 124 || c === 125 || c === 126 || c === 161 || c >= 162 && c <= 165 || c === 166 || c === 167 || c === 169 || c === 171 || c === 172 || c === 174 || c === 176 || c === 177 || c === 182 || c === 187 || c === 191 || c === 215 || c === 247 || c >= 8208 && c <= 8213 || c >= 8214 && c <= 8215 || c === 8216 || c === 8217 || c === 8218 || c >= 8219 && c <= 8220 || c === 8221 || c === 8222 || c === 8223 || c >= 8224 && c <= 8231 || c >= 8240 && c <= 8248 || c === 8249 || c === 8250 || c >= 8251 && c <= 8254 || c >= 8257 && c <= 8259 || c === 8260 || c === 8261 || c === 8262 || c >= 8263 && c <= 8273 || c === 8274 || c === 8275 || c >= 8277 && c <= 8286 || c >= 8592 && c <= 8596 || c >= 8597 && c <= 8601 || c >= 8602 && c <= 8603 || c >= 8604 && c <= 8607 || c === 8608 || c >= 8609 && c <= 8610 || c === 8611 || c >= 8612 && c <= 8613 || c === 8614 || c >= 8615 && c <= 8621 || c === 8622 || c >= 8623 && c <= 8653 || c >= 8654 && c <= 8655 || c >= 8656 && c <= 8657 || c === 8658 || c === 8659 || c === 8660 || c >= 8661 && c <= 8691 || c >= 8692 && c <= 8959 || c >= 8960 && c <= 8967 || c === 8968 || c === 8969 || c === 8970 || c === 8971 || c >= 8972 && c <= 8991 || c >= 8992 && c <= 8993 || c >= 8994 && c <= 9e3 || c === 9001 || c === 9002 || c >= 9003 && c <= 9083 || c === 9084 || c >= 9085 && c <= 9114 || c >= 9115 && c <= 9139 || c >= 9140 && c <= 9179 || c >= 9180 && c <= 9185 || c >= 9186 && c <= 9254 || c >= 9255 && c <= 9279 || c >= 9280 && c <= 9290 || c >= 9291 && c <= 9311 || c >= 9472 && c <= 9654 || c === 9655 || c >= 9656 && c <= 9664 || c === 9665 || c >= 9666 && c <= 9719 || c >= 9720 && c <= 9727 || c >= 9728 && c <= 9838 || c === 9839 || c >= 9840 && c <= 10087 || c === 10088 || c === 10089 || c === 10090 || c === 10091 || c === 10092 || c === 10093 || c === 10094 || c === 10095 || c === 10096 || c === 10097 || c === 10098 || c === 10099 || c === 10100 || c === 10101 || c >= 10132 && c <= 10175 || c >= 10176 && c <= 10180 || c === 10181 || c === 10182 || c >= 10183 && c <= 10213 || c === 10214 || c === 10215 || c === 10216 || c === 10217 || c === 10218 || c === 10219 || c === 10220 || c === 10221 || c === 10222 || c === 10223 || c >= 10224 && c <= 10239 || c >= 10240 && c <= 10495 || c >= 10496 && c <= 10626 || c === 10627 || c === 10628 || c === 10629 || c === 10630 || c === 10631 || c === 10632 || c === 10633 || c === 10634 || c === 10635 || c === 10636 || c === 10637 || c === 10638 || c === 10639 || c === 10640 || c === 10641 || c === 10642 || c === 10643 || c === 10644 || c === 10645 || c === 10646 || c === 10647 || c === 10648 || c >= 10649 && c <= 10711 || c === 10712 || c === 10713 || c === 10714 || c === 10715 || c >= 10716 && c <= 10747 || c === 10748 || c === 10749 || c >= 10750 && c <= 11007 || c >= 11008 && c <= 11055 || c >= 11056 && c <= 11076 || c >= 11077 && c <= 11078 || c >= 11079 && c <= 11084 || c >= 11085 && c <= 11123 || c >= 11124 && c <= 11125 || c >= 11126 && c <= 11157 || c === 11158 || c >= 11159 && c <= 11263 || c >= 11776 && c <= 11777 || c === 11778 || c === 11779 || c === 11780 || c === 11781 || c >= 11782 && c <= 11784 || c === 11785 || c === 11786 || c === 11787 || c === 11788 || c === 11789 || c >= 11790 && c <= 11798 || c === 11799 || c >= 11800 && c <= 11801 || c === 11802 || c === 11803 || c === 11804 || c === 11805 || c >= 11806 && c <= 11807 || c === 11808 || c === 11809 || c === 11810 || c === 11811 || c === 11812 || c === 11813 || c === 11814 || c === 11815 || c === 11816 || c === 11817 || c >= 11818 && c <= 11822 || c === 11823 || c >= 11824 && c <= 11833 || c >= 11834 && c <= 11835 || c >= 11836 && c <= 11839 || c === 11840 || c === 11841 || c === 11842 || c >= 11843 && c <= 11855 || c >= 11856 && c <= 11857 || c === 11858 || c >= 11859 && c <= 11903 || c >= 12289 && c <= 12291 || c === 12296 || c === 12297 || c === 12298 || c === 12299 || c === 12300 || c === 12301 || c === 12302 || c === 12303 || c === 12304 || c === 12305 || c >= 12306 && c <= 12307 || c === 12308 || c === 12309 || c === 12310 || c === 12311 || c === 12312 || c === 12313 || c === 12314 || c === 12315 || c === 12316 || c === 12317 || c >= 12318 && c <= 12319 || c === 12320 || c === 12336 || c === 64830 || c === 64831 || c >= 65093 && c <= 65094;
}

// node_modules/@strapi/plugin-seo/node_modules/@formatjs/icu-messageformat-parser/lib/index.js
function pruneLocation(els) {
  els.forEach(function(el) {
    delete el.location;
    if (isSelectElement(el) || isPluralElement(el)) {
      for (var k in el.options) {
        delete el.options[k].location;
        pruneLocation(el.options[k].value);
      }
    } else if (isNumberElement(el) && isNumberSkeleton(el.style)) {
      delete el.style.location;
    } else if ((isDateElement(el) || isTimeElement(el)) && isDateTimeSkeleton(el.style)) {
      delete el.style.location;
    } else if (isTagElement(el)) {
      pruneLocation(el.children);
    }
  });
}
function parse(message, opts) {
  if (opts === void 0) {
    opts = {};
  }
  opts = __assign({ shouldParseSkeletons: true, requiresOtherClause: true }, opts);
  var result = new Parser(message, opts).parse();
  if (result.err) {
    var error = SyntaxError(ErrorKind[result.err.kind]);
    error.location = result.err.location;
    error.originalMessage = result.err.message;
    throw error;
  }
  if (!(opts === null || opts === void 0 ? void 0 : opts.captureLocation)) {
    pruneLocation(result.val);
  }
  return result.val;
}

// node_modules/@strapi/plugin-seo/node_modules/intl-messageformat/lib/src/error.js
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2["MISSING_VALUE"] = "MISSING_VALUE";
  ErrorCode2["INVALID_VALUE"] = "INVALID_VALUE";
  ErrorCode2["MISSING_INTL_API"] = "MISSING_INTL_API";
})(ErrorCode || (ErrorCode = {}));
var FormatError = (
  /** @class */
  function(_super) {
    __extends(FormatError2, _super);
    function FormatError2(msg, code, originalMessage) {
      var _this = _super.call(this, msg) || this;
      _this.code = code;
      _this.originalMessage = originalMessage;
      return _this;
    }
    FormatError2.prototype.toString = function() {
      return "[formatjs Error: ".concat(this.code, "] ").concat(this.message);
    };
    return FormatError2;
  }(Error)
);
var InvalidValueError = (
  /** @class */
  function(_super) {
    __extends(InvalidValueError2, _super);
    function InvalidValueError2(variableId, value, options, originalMessage) {
      return _super.call(this, 'Invalid values for "'.concat(variableId, '": "').concat(value, '". Options are "').concat(Object.keys(options).join('", "'), '"'), ErrorCode.INVALID_VALUE, originalMessage) || this;
    }
    return InvalidValueError2;
  }(FormatError)
);
var InvalidValueTypeError = (
  /** @class */
  function(_super) {
    __extends(InvalidValueTypeError2, _super);
    function InvalidValueTypeError2(value, type2, originalMessage) {
      return _super.call(this, 'Value for "'.concat(value, '" must be of type ').concat(type2), ErrorCode.INVALID_VALUE, originalMessage) || this;
    }
    return InvalidValueTypeError2;
  }(FormatError)
);
var MissingValueError = (
  /** @class */
  function(_super) {
    __extends(MissingValueError2, _super);
    function MissingValueError2(variableId, originalMessage) {
      return _super.call(this, 'The intl string context variable "'.concat(variableId, '" was not provided to the string "').concat(originalMessage, '"'), ErrorCode.MISSING_VALUE, originalMessage) || this;
    }
    return MissingValueError2;
  }(FormatError)
);

// node_modules/@strapi/plugin-seo/node_modules/intl-messageformat/lib/src/formatters.js
var PART_TYPE;
(function(PART_TYPE2) {
  PART_TYPE2[PART_TYPE2["literal"] = 0] = "literal";
  PART_TYPE2[PART_TYPE2["object"] = 1] = "object";
})(PART_TYPE || (PART_TYPE = {}));
function mergeLiteral(parts) {
  if (parts.length < 2) {
    return parts;
  }
  return parts.reduce(function(all, part) {
    var lastPart = all[all.length - 1];
    if (!lastPart || lastPart.type !== PART_TYPE.literal || part.type !== PART_TYPE.literal) {
      all.push(part);
    } else {
      lastPart.value += part.value;
    }
    return all;
  }, []);
}
function isFormatXMLElementFn(el) {
  return typeof el === "function";
}
function formatToParts2(els, locales, formatters2, formats, values, currentPluralValue, originalMessage) {
  if (els.length === 1 && isLiteralElement(els[0])) {
    return [
      {
        type: PART_TYPE.literal,
        value: els[0].value
      }
    ];
  }
  var result = [];
  for (var _i = 0, els_1 = els; _i < els_1.length; _i++) {
    var el = els_1[_i];
    if (isLiteralElement(el)) {
      result.push({
        type: PART_TYPE.literal,
        value: el.value
      });
      continue;
    }
    if (isPoundElement(el)) {
      if (typeof currentPluralValue === "number") {
        result.push({
          type: PART_TYPE.literal,
          value: formatters2.getNumberFormat(locales).format(currentPluralValue)
        });
      }
      continue;
    }
    var varName = el.value;
    if (!(values && varName in values)) {
      throw new MissingValueError(varName, originalMessage);
    }
    var value = values[varName];
    if (isArgumentElement(el)) {
      if (!value || typeof value === "string" || typeof value === "number") {
        value = typeof value === "string" || typeof value === "number" ? String(value) : "";
      }
      result.push({
        type: typeof value === "string" ? PART_TYPE.literal : PART_TYPE.object,
        value
      });
      continue;
    }
    if (isDateElement(el)) {
      var style = typeof el.style === "string" ? formats.date[el.style] : isDateTimeSkeleton(el.style) ? el.style.parsedOptions : void 0;
      result.push({
        type: PART_TYPE.literal,
        value: formatters2.getDateTimeFormat(locales, style).format(value)
      });
      continue;
    }
    if (isTimeElement(el)) {
      var style = typeof el.style === "string" ? formats.time[el.style] : isDateTimeSkeleton(el.style) ? el.style.parsedOptions : formats.time.medium;
      result.push({
        type: PART_TYPE.literal,
        value: formatters2.getDateTimeFormat(locales, style).format(value)
      });
      continue;
    }
    if (isNumberElement(el)) {
      var style = typeof el.style === "string" ? formats.number[el.style] : isNumberSkeleton(el.style) ? el.style.parsedOptions : void 0;
      if (style && style.scale) {
        value = value * (style.scale || 1);
      }
      result.push({
        type: PART_TYPE.literal,
        value: formatters2.getNumberFormat(locales, style).format(value)
      });
      continue;
    }
    if (isTagElement(el)) {
      var children = el.children, value_1 = el.value;
      var formatFn = values[value_1];
      if (!isFormatXMLElementFn(formatFn)) {
        throw new InvalidValueTypeError(value_1, "function", originalMessage);
      }
      var parts = formatToParts2(children, locales, formatters2, formats, values, currentPluralValue);
      var chunks = formatFn(parts.map(function(p) {
        return p.value;
      }));
      if (!Array.isArray(chunks)) {
        chunks = [chunks];
      }
      result.push.apply(result, chunks.map(function(c) {
        return {
          type: typeof c === "string" ? PART_TYPE.literal : PART_TYPE.object,
          value: c
        };
      }));
    }
    if (isSelectElement(el)) {
      var opt = el.options[value] || el.options.other;
      if (!opt) {
        throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);
      }
      result.push.apply(result, formatToParts2(opt.value, locales, formatters2, formats, values));
      continue;
    }
    if (isPluralElement(el)) {
      var opt = el.options["=".concat(value)];
      if (!opt) {
        if (!Intl.PluralRules) {
          throw new FormatError('Intl.PluralRules is not available in this environment.\nTry polyfilling it using "@formatjs/intl-pluralrules"\n', ErrorCode.MISSING_INTL_API, originalMessage);
        }
        var rule = formatters2.getPluralRules(locales, { type: el.pluralType }).select(value - (el.offset || 0));
        opt = el.options[rule] || el.options.other;
      }
      if (!opt) {
        throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);
      }
      result.push.apply(result, formatToParts2(opt.value, locales, formatters2, formats, values, value - (el.offset || 0)));
      continue;
    }
  }
  return mergeLiteral(result);
}

// node_modules/@strapi/plugin-seo/node_modules/intl-messageformat/lib/src/core.js
function mergeConfig(c1, c2) {
  if (!c2) {
    return c1;
  }
  return __assign(__assign(__assign({}, c1 || {}), c2 || {}), Object.keys(c1).reduce(function(all, k) {
    all[k] = __assign(__assign({}, c1[k]), c2[k] || {});
    return all;
  }, {}));
}
function mergeConfigs(defaultConfig, configs) {
  if (!configs) {
    return defaultConfig;
  }
  return Object.keys(defaultConfig).reduce(function(all, k) {
    all[k] = mergeConfig(defaultConfig[k], configs[k]);
    return all;
  }, __assign({}, defaultConfig));
}
function createFastMemoizeCache(store) {
  return {
    create: function() {
      return {
        get: function(key) {
          return store[key];
        },
        set: function(key, value) {
          store[key] = value;
        }
      };
    }
  };
}
function createDefaultFormatters(cache) {
  if (cache === void 0) {
    cache = {
      number: {},
      dateTime: {},
      pluralRules: {}
    };
  }
  return {
    getNumberFormat: memoize(function() {
      var _a2;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new ((_a2 = Intl.NumberFormat).bind.apply(_a2, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache(cache.number),
      strategy: strategies.variadic
    }),
    getDateTimeFormat: memoize(function() {
      var _a2;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new ((_a2 = Intl.DateTimeFormat).bind.apply(_a2, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache(cache.dateTime),
      strategy: strategies.variadic
    }),
    getPluralRules: memoize(function() {
      var _a2;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new ((_a2 = Intl.PluralRules).bind.apply(_a2, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache(cache.pluralRules),
      strategy: strategies.variadic
    })
  };
}
var IntlMessageFormat = (
  /** @class */
  function() {
    function IntlMessageFormat2(message, locales, overrideFormats, opts) {
      if (locales === void 0) {
        locales = IntlMessageFormat2.defaultLocale;
      }
      var _this = this;
      this.formatterCache = {
        number: {},
        dateTime: {},
        pluralRules: {}
      };
      this.format = function(values) {
        var parts = _this.formatToParts(values);
        if (parts.length === 1) {
          return parts[0].value;
        }
        var result = parts.reduce(function(all, part) {
          if (!all.length || part.type !== PART_TYPE.literal || typeof all[all.length - 1] !== "string") {
            all.push(part.value);
          } else {
            all[all.length - 1] += part.value;
          }
          return all;
        }, []);
        if (result.length <= 1) {
          return result[0] || "";
        }
        return result;
      };
      this.formatToParts = function(values) {
        return formatToParts2(_this.ast, _this.locales, _this.formatters, _this.formats, values, void 0, _this.message);
      };
      this.resolvedOptions = function() {
        var _a3;
        return {
          locale: ((_a3 = _this.resolvedLocale) === null || _a3 === void 0 ? void 0 : _a3.toString()) || Intl.NumberFormat.supportedLocalesOf(_this.locales)[0]
        };
      };
      this.getAst = function() {
        return _this.ast;
      };
      this.locales = locales;
      this.resolvedLocale = IntlMessageFormat2.resolveLocale(locales);
      if (typeof message === "string") {
        this.message = message;
        if (!IntlMessageFormat2.__parse) {
          throw new TypeError("IntlMessageFormat.__parse must be set to process `message` of type `string`");
        }
        var _a2 = opts || {}, formatters2 = _a2.formatters, parseOpts = __rest(_a2, ["formatters"]);
        this.ast = IntlMessageFormat2.__parse(message, __assign(__assign({}, parseOpts), { locale: this.resolvedLocale }));
      } else {
        this.ast = message;
      }
      if (!Array.isArray(this.ast)) {
        throw new TypeError("A message must be provided as a String or AST.");
      }
      this.formats = mergeConfigs(IntlMessageFormat2.formats, overrideFormats);
      this.formatters = opts && opts.formatters || createDefaultFormatters(this.formatterCache);
    }
    Object.defineProperty(IntlMessageFormat2, "defaultLocale", {
      get: function() {
        if (!IntlMessageFormat2.memoizedDefaultLocale) {
          IntlMessageFormat2.memoizedDefaultLocale = new Intl.NumberFormat().resolvedOptions().locale;
        }
        return IntlMessageFormat2.memoizedDefaultLocale;
      },
      enumerable: false,
      configurable: true
    });
    IntlMessageFormat2.memoizedDefaultLocale = null;
    IntlMessageFormat2.resolveLocale = function(locales) {
      if (typeof Intl.Locale === "undefined") {
        return;
      }
      var supportedLocales = Intl.NumberFormat.supportedLocalesOf(locales);
      if (supportedLocales.length > 0) {
        return new Intl.Locale(supportedLocales[0]);
      }
      return new Intl.Locale(typeof locales === "string" ? locales : locales[0]);
    };
    IntlMessageFormat2.__parse = parse;
    IntlMessageFormat2.formats = {
      number: {
        integer: {
          maximumFractionDigits: 0
        },
        currency: {
          style: "currency"
        },
        percent: {
          style: "percent"
        }
      },
      date: {
        short: {
          month: "numeric",
          day: "numeric",
          year: "2-digit"
        },
        medium: {
          month: "short",
          day: "numeric",
          year: "numeric"
        },
        long: {
          month: "long",
          day: "numeric",
          year: "numeric"
        },
        full: {
          weekday: "long",
          month: "long",
          day: "numeric",
          year: "numeric"
        }
      },
      time: {
        short: {
          hour: "numeric",
          minute: "numeric"
        },
        medium: {
          hour: "numeric",
          minute: "numeric",
          second: "numeric"
        },
        long: {
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          timeZoneName: "short"
        },
        full: {
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          timeZoneName: "short"
        }
      }
    };
    return IntlMessageFormat2;
  }()
);

// node_modules/@strapi/plugin-seo/node_modules/@formatjs/intl/lib/src/error.js
var IntlErrorCode;
(function(IntlErrorCode2) {
  IntlErrorCode2["FORMAT_ERROR"] = "FORMAT_ERROR";
  IntlErrorCode2["UNSUPPORTED_FORMATTER"] = "UNSUPPORTED_FORMATTER";
  IntlErrorCode2["INVALID_CONFIG"] = "INVALID_CONFIG";
  IntlErrorCode2["MISSING_DATA"] = "MISSING_DATA";
  IntlErrorCode2["MISSING_TRANSLATION"] = "MISSING_TRANSLATION";
})(IntlErrorCode || (IntlErrorCode = {}));
var IntlError = (
  /** @class */
  function(_super) {
    __extends(IntlError2, _super);
    function IntlError2(code, message, exception) {
      var _this = this;
      var err = exception ? exception instanceof Error ? exception : new Error(String(exception)) : void 0;
      _this = _super.call(this, "[@formatjs/intl Error ".concat(code, "] ").concat(message, "\n").concat(err ? "\n".concat(err.message, "\n").concat(err.stack) : "")) || this;
      _this.code = code;
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(_this, IntlError2);
      }
      return _this;
    }
    return IntlError2;
  }(Error)
);
var UnsupportedFormatterError = (
  /** @class */
  function(_super) {
    __extends(UnsupportedFormatterError2, _super);
    function UnsupportedFormatterError2(message, exception) {
      return _super.call(this, IntlErrorCode.UNSUPPORTED_FORMATTER, message, exception) || this;
    }
    return UnsupportedFormatterError2;
  }(IntlError)
);
var InvalidConfigError = (
  /** @class */
  function(_super) {
    __extends(InvalidConfigError2, _super);
    function InvalidConfigError2(message, exception) {
      return _super.call(this, IntlErrorCode.INVALID_CONFIG, message, exception) || this;
    }
    return InvalidConfigError2;
  }(IntlError)
);
var MissingDataError = (
  /** @class */
  function(_super) {
    __extends(MissingDataError2, _super);
    function MissingDataError2(message, exception) {
      return _super.call(this, IntlErrorCode.MISSING_DATA, message, exception) || this;
    }
    return MissingDataError2;
  }(IntlError)
);
var IntlFormatError = (
  /** @class */
  function(_super) {
    __extends(IntlFormatError2, _super);
    function IntlFormatError2(message, locale, exception) {
      var _this = _super.call(this, IntlErrorCode.FORMAT_ERROR, "".concat(message, "\nLocale: ").concat(locale, "\n"), exception) || this;
      _this.locale = locale;
      return _this;
    }
    return IntlFormatError2;
  }(IntlError)
);
var MessageFormatError = (
  /** @class */
  function(_super) {
    __extends(MessageFormatError2, _super);
    function MessageFormatError2(message, locale, descriptor, exception) {
      var _this = _super.call(this, "".concat(message, "\nMessageID: ").concat(descriptor === null || descriptor === void 0 ? void 0 : descriptor.id, "\nDefault Message: ").concat(descriptor === null || descriptor === void 0 ? void 0 : descriptor.defaultMessage, "\nDescription: ").concat(descriptor === null || descriptor === void 0 ? void 0 : descriptor.description, "\n"), locale, exception) || this;
      _this.descriptor = descriptor;
      _this.locale = locale;
      return _this;
    }
    return MessageFormatError2;
  }(IntlFormatError)
);
var MissingTranslationError = (
  /** @class */
  function(_super) {
    __extends(MissingTranslationError2, _super);
    function MissingTranslationError2(descriptor, locale) {
      var _this = _super.call(this, IntlErrorCode.MISSING_TRANSLATION, 'Missing message: "'.concat(descriptor.id, '" for locale "').concat(locale, '", using ').concat(descriptor.defaultMessage ? "default message (".concat(typeof descriptor.defaultMessage === "string" ? descriptor.defaultMessage : descriptor.defaultMessage.map(function(e) {
        var _a2;
        return (_a2 = e.value) !== null && _a2 !== void 0 ? _a2 : JSON.stringify(e);
      }).join(), ")") : "id", " as fallback.")) || this;
      _this.descriptor = descriptor;
      return _this;
    }
    return MissingTranslationError2;
  }(IntlError)
);

// node_modules/@strapi/plugin-seo/node_modules/@formatjs/intl/lib/src/utils.js
function filterProps(props, allowlist, defaults) {
  if (defaults === void 0) {
    defaults = {};
  }
  return allowlist.reduce(function(filtered, name2) {
    if (name2 in props) {
      filtered[name2] = props[name2];
    } else if (name2 in defaults) {
      filtered[name2] = defaults[name2];
    }
    return filtered;
  }, {});
}
var defaultErrorHandler = function(error) {
  if (true) {
    console.error(error);
  }
};
var defaultWarnHandler = function(warning) {
  if (true) {
    console.warn(warning);
  }
};
var DEFAULT_INTL_CONFIG = {
  formats: {},
  messages: {},
  timeZone: void 0,
  defaultLocale: "en",
  defaultFormats: {},
  fallbackOnEmptyString: true,
  onError: defaultErrorHandler,
  onWarn: defaultWarnHandler
};
function createIntlCache() {
  return {
    dateTime: {},
    number: {},
    message: {},
    relativeTime: {},
    pluralRules: {},
    list: {},
    displayNames: {}
  };
}
function createFastMemoizeCache2(store) {
  return {
    create: function() {
      return {
        get: function(key) {
          return store[key];
        },
        set: function(key, value) {
          store[key] = value;
        }
      };
    }
  };
}
function createFormatters(cache) {
  if (cache === void 0) {
    cache = createIntlCache();
  }
  var RelativeTimeFormat = Intl.RelativeTimeFormat;
  var ListFormat = Intl.ListFormat;
  var DisplayNames = Intl.DisplayNames;
  var getDateTimeFormat = memoize(function() {
    var _a2;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return new ((_a2 = Intl.DateTimeFormat).bind.apply(_a2, __spreadArray([void 0], args, false)))();
  }, {
    cache: createFastMemoizeCache2(cache.dateTime),
    strategy: strategies.variadic
  });
  var getNumberFormat = memoize(function() {
    var _a2;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return new ((_a2 = Intl.NumberFormat).bind.apply(_a2, __spreadArray([void 0], args, false)))();
  }, {
    cache: createFastMemoizeCache2(cache.number),
    strategy: strategies.variadic
  });
  var getPluralRules = memoize(function() {
    var _a2;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return new ((_a2 = Intl.PluralRules).bind.apply(_a2, __spreadArray([void 0], args, false)))();
  }, {
    cache: createFastMemoizeCache2(cache.pluralRules),
    strategy: strategies.variadic
  });
  return {
    getDateTimeFormat,
    getNumberFormat,
    getMessageFormat: memoize(function(message, locales, overrideFormats, opts) {
      return new IntlMessageFormat(message, locales, overrideFormats, __assign({ formatters: {
        getNumberFormat,
        getDateTimeFormat,
        getPluralRules
      } }, opts || {}));
    }, {
      cache: createFastMemoizeCache2(cache.message),
      strategy: strategies.variadic
    }),
    getRelativeTimeFormat: memoize(function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new (RelativeTimeFormat.bind.apply(RelativeTimeFormat, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache2(cache.relativeTime),
      strategy: strategies.variadic
    }),
    getPluralRules,
    getListFormat: memoize(function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new (ListFormat.bind.apply(ListFormat, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache2(cache.list),
      strategy: strategies.variadic
    }),
    getDisplayNames: memoize(function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new (DisplayNames.bind.apply(DisplayNames, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache2(cache.displayNames),
      strategy: strategies.variadic
    })
  };
}
function getNamedFormat(formats, type2, name2, onError) {
  var formatType = formats && formats[type2];
  var format2;
  if (formatType) {
    format2 = formatType[name2];
  }
  if (format2) {
    return format2;
  }
  onError(new UnsupportedFormatterError("No ".concat(type2, " format named: ").concat(name2)));
}

// node_modules/@strapi/plugin-seo/node_modules/@formatjs/intl/lib/src/message.js
function setTimeZoneInOptions(opts, timeZone) {
  return Object.keys(opts).reduce(function(all, k) {
    all[k] = __assign({ timeZone }, opts[k]);
    return all;
  }, {});
}
function deepMergeOptions(opts1, opts2) {
  var keys = Object.keys(__assign(__assign({}, opts1), opts2));
  return keys.reduce(function(all, k) {
    all[k] = __assign(__assign({}, opts1[k] || {}), opts2[k] || {});
    return all;
  }, {});
}
function deepMergeFormatsAndSetTimeZone(f1, timeZone) {
  if (!timeZone) {
    return f1;
  }
  var mfFormats = IntlMessageFormat.formats;
  return __assign(__assign(__assign({}, mfFormats), f1), { date: deepMergeOptions(setTimeZoneInOptions(mfFormats.date, timeZone), setTimeZoneInOptions(f1.date || {}, timeZone)), time: deepMergeOptions(setTimeZoneInOptions(mfFormats.time, timeZone), setTimeZoneInOptions(f1.time || {}, timeZone)) });
}
var formatMessage = function(_a2, state, messageDescriptor, values, opts) {
  var locale = _a2.locale, formats = _a2.formats, messages = _a2.messages, defaultLocale = _a2.defaultLocale, defaultFormats = _a2.defaultFormats, fallbackOnEmptyString = _a2.fallbackOnEmptyString, onError = _a2.onError, timeZone = _a2.timeZone, defaultRichTextElements = _a2.defaultRichTextElements;
  if (messageDescriptor === void 0) {
    messageDescriptor = { id: "" };
  }
  var msgId = messageDescriptor.id, defaultMessage = messageDescriptor.defaultMessage;
  invariant(!!msgId, "[@formatjs/intl] An `id` must be provided to format a message. You can either:\n1. Configure your build toolchain with [babel-plugin-formatjs](https://formatjs.io/docs/tooling/babel-plugin)\nor [@formatjs/ts-transformer](https://formatjs.io/docs/tooling/ts-transformer) OR\n2. Configure your `eslint` config to include [eslint-plugin-formatjs](https://formatjs.io/docs/tooling/linter#enforce-id)\nto autofix this issue");
  var id = String(msgId);
  var message = (
    // In case messages is Object.create(null)
    // e.g import('foo.json') from webpack)
    // See https://github.com/formatjs/formatjs/issues/1914
    messages && Object.prototype.hasOwnProperty.call(messages, id) && messages[id]
  );
  if (Array.isArray(message) && message.length === 1 && message[0].type === TYPE.literal) {
    return message[0].value;
  }
  if (!values && message && typeof message === "string" && !defaultRichTextElements) {
    return message.replace(/'\{(.*?)\}'/gi, "{$1}");
  }
  values = __assign(__assign({}, defaultRichTextElements), values || {});
  formats = deepMergeFormatsAndSetTimeZone(formats, timeZone);
  defaultFormats = deepMergeFormatsAndSetTimeZone(defaultFormats, timeZone);
  if (!message) {
    if (fallbackOnEmptyString === false && message === "") {
      return message;
    }
    if (!defaultMessage || locale && locale.toLowerCase() !== defaultLocale.toLowerCase()) {
      onError(new MissingTranslationError(messageDescriptor, locale));
    }
    if (defaultMessage) {
      try {
        var formatter = state.getMessageFormat(defaultMessage, defaultLocale, defaultFormats, opts);
        return formatter.format(values);
      } catch (e) {
        onError(new MessageFormatError('Error formatting default message for: "'.concat(id, '", rendering default message verbatim'), locale, messageDescriptor, e));
        return typeof defaultMessage === "string" ? defaultMessage : id;
      }
    }
    return id;
  }
  try {
    var formatter = state.getMessageFormat(message, locale, formats, __assign({ formatters: state }, opts || {}));
    return formatter.format(values);
  } catch (e) {
    onError(new MessageFormatError('Error formatting message: "'.concat(id, '", using ').concat(defaultMessage ? "default message" : "id", " as fallback."), locale, messageDescriptor, e));
  }
  if (defaultMessage) {
    try {
      var formatter = state.getMessageFormat(defaultMessage, defaultLocale, defaultFormats, opts);
      return formatter.format(values);
    } catch (e) {
      onError(new MessageFormatError('Error formatting the default message for: "'.concat(id, '", rendering message verbatim'), locale, messageDescriptor, e));
    }
  }
  if (typeof message === "string") {
    return message;
  }
  if (typeof defaultMessage === "string") {
    return defaultMessage;
  }
  return id;
};

// node_modules/@strapi/plugin-seo/node_modules/@formatjs/intl/lib/src/dateTime.js
var DATE_TIME_FORMAT_OPTIONS = [
  "formatMatcher",
  "timeZone",
  "hour12",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName",
  "hourCycle",
  "dateStyle",
  "timeStyle",
  "calendar",
  // 'dayPeriod',
  "numberingSystem",
  "fractionalSecondDigits"
];
function getFormatter(_a2, type2, getDateTimeFormat, options) {
  var locale = _a2.locale, formats = _a2.formats, onError = _a2.onError, timeZone = _a2.timeZone;
  if (options === void 0) {
    options = {};
  }
  var format2 = options.format;
  var defaults = __assign(__assign({}, timeZone && { timeZone }), format2 && getNamedFormat(formats, type2, format2, onError));
  var filteredOptions = filterProps(options, DATE_TIME_FORMAT_OPTIONS, defaults);
  if (type2 === "time" && !filteredOptions.hour && !filteredOptions.minute && !filteredOptions.second && !filteredOptions.timeStyle && !filteredOptions.dateStyle) {
    filteredOptions = __assign(__assign({}, filteredOptions), { hour: "numeric", minute: "numeric" });
  }
  return getDateTimeFormat(locale, filteredOptions);
}
function formatDate(config, getDateTimeFormat) {
  var _a2 = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    _a2[_i - 2] = arguments[_i];
  }
  var value = _a2[0], _b = _a2[1], options = _b === void 0 ? {} : _b;
  var date = typeof value === "string" ? new Date(value || 0) : value;
  try {
    return getFormatter(config, "date", getDateTimeFormat, options).format(date);
  } catch (e) {
    config.onError(new IntlFormatError("Error formatting date.", config.locale, e));
  }
  return String(date);
}
function formatTime(config, getDateTimeFormat) {
  var _a2 = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    _a2[_i - 2] = arguments[_i];
  }
  var value = _a2[0], _b = _a2[1], options = _b === void 0 ? {} : _b;
  var date = typeof value === "string" ? new Date(value || 0) : value;
  try {
    return getFormatter(config, "time", getDateTimeFormat, options).format(date);
  } catch (e) {
    config.onError(new IntlFormatError("Error formatting time.", config.locale, e));
  }
  return String(date);
}
function formatDateTimeRange(config, getDateTimeFormat) {
  var _a2 = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    _a2[_i - 2] = arguments[_i];
  }
  var from = _a2[0], to = _a2[1], _b = _a2[2], options = _b === void 0 ? {} : _b;
  var timeZone = config.timeZone, locale = config.locale, onError = config.onError;
  var filteredOptions = filterProps(options, DATE_TIME_FORMAT_OPTIONS, timeZone ? { timeZone } : {});
  try {
    return getDateTimeFormat(locale, filteredOptions).formatRange(from, to);
  } catch (e) {
    onError(new IntlFormatError("Error formatting date time range.", config.locale, e));
  }
  return String(from);
}
function formatDateToParts(config, getDateTimeFormat) {
  var _a2 = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    _a2[_i - 2] = arguments[_i];
  }
  var value = _a2[0], _b = _a2[1], options = _b === void 0 ? {} : _b;
  var date = typeof value === "string" ? new Date(value || 0) : value;
  try {
    return getFormatter(config, "date", getDateTimeFormat, options).formatToParts(date);
  } catch (e) {
    config.onError(new IntlFormatError("Error formatting date.", config.locale, e));
  }
  return [];
}
function formatTimeToParts(config, getDateTimeFormat) {
  var _a2 = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    _a2[_i - 2] = arguments[_i];
  }
  var value = _a2[0], _b = _a2[1], options = _b === void 0 ? {} : _b;
  var date = typeof value === "string" ? new Date(value || 0) : value;
  try {
    return getFormatter(config, "time", getDateTimeFormat, options).formatToParts(date);
  } catch (e) {
    config.onError(new IntlFormatError("Error formatting time.", config.locale, e));
  }
  return [];
}

// node_modules/@strapi/plugin-seo/node_modules/@formatjs/intl/lib/src/displayName.js
var DISPLAY_NAMES_OPTONS = [
  "style",
  "type",
  "fallback",
  "languageDisplay"
];
function formatDisplayName(_a2, getDisplayNames, value, options) {
  var locale = _a2.locale, onError = _a2.onError;
  var DisplayNames = Intl.DisplayNames;
  if (!DisplayNames) {
    onError(new FormatError('Intl.DisplayNames is not available in this environment.\nTry polyfilling it using "@formatjs/intl-displaynames"\n', ErrorCode.MISSING_INTL_API));
  }
  var filteredOptions = filterProps(options, DISPLAY_NAMES_OPTONS);
  try {
    return getDisplayNames(locale, filteredOptions).of(value);
  } catch (e) {
    onError(new IntlFormatError("Error formatting display name.", locale, e));
  }
}

// node_modules/@strapi/plugin-seo/node_modules/@formatjs/intl/lib/src/list.js
var LIST_FORMAT_OPTIONS = [
  "type",
  "style"
];
var now = Date.now();
function generateToken(i) {
  return "".concat(now, "_").concat(i, "_").concat(now);
}
function formatList(opts, getListFormat, values, options) {
  if (options === void 0) {
    options = {};
  }
  var results = formatListToParts(opts, getListFormat, values, options).reduce(function(all, el) {
    var val = el.value;
    if (typeof val !== "string") {
      all.push(val);
    } else if (typeof all[all.length - 1] === "string") {
      all[all.length - 1] += val;
    } else {
      all.push(val);
    }
    return all;
  }, []);
  return results.length === 1 ? results[0] : results.length === 0 ? "" : results;
}
function formatListToParts(_a2, getListFormat, values, options) {
  var locale = _a2.locale, onError = _a2.onError;
  if (options === void 0) {
    options = {};
  }
  var ListFormat = Intl.ListFormat;
  if (!ListFormat) {
    onError(new FormatError('Intl.ListFormat is not available in this environment.\nTry polyfilling it using "@formatjs/intl-listformat"\n', ErrorCode.MISSING_INTL_API));
  }
  var filteredOptions = filterProps(options, LIST_FORMAT_OPTIONS);
  try {
    var richValues_1 = {};
    var serializedValues = values.map(function(v, i) {
      if (typeof v === "object") {
        var id = generateToken(i);
        richValues_1[id] = v;
        return id;
      }
      return String(v);
    });
    return getListFormat(locale, filteredOptions).formatToParts(serializedValues).map(function(part) {
      return part.type === "literal" ? part : __assign(__assign({}, part), { value: richValues_1[part.value] || part.value });
    });
  } catch (e) {
    onError(new IntlFormatError("Error formatting list.", locale, e));
  }
  return values;
}

// node_modules/@strapi/plugin-seo/node_modules/@formatjs/intl/lib/src/plural.js
var PLURAL_FORMAT_OPTIONS = ["type"];
function formatPlural(_a2, getPluralRules, value, options) {
  var locale = _a2.locale, onError = _a2.onError;
  if (options === void 0) {
    options = {};
  }
  if (!Intl.PluralRules) {
    onError(new FormatError('Intl.PluralRules is not available in this environment.\nTry polyfilling it using "@formatjs/intl-pluralrules"\n', ErrorCode.MISSING_INTL_API));
  }
  var filteredOptions = filterProps(options, PLURAL_FORMAT_OPTIONS);
  try {
    return getPluralRules(locale, filteredOptions).select(value);
  } catch (e) {
    onError(new IntlFormatError("Error formatting plural.", locale, e));
  }
  return "other";
}

// node_modules/@strapi/plugin-seo/node_modules/@formatjs/intl/lib/src/relativeTime.js
var RELATIVE_TIME_FORMAT_OPTIONS = ["numeric", "style"];
function getFormatter2(_a2, getRelativeTimeFormat, options) {
  var locale = _a2.locale, formats = _a2.formats, onError = _a2.onError;
  if (options === void 0) {
    options = {};
  }
  var format2 = options.format;
  var defaults = !!format2 && getNamedFormat(formats, "relative", format2, onError) || {};
  var filteredOptions = filterProps(options, RELATIVE_TIME_FORMAT_OPTIONS, defaults);
  return getRelativeTimeFormat(locale, filteredOptions);
}
function formatRelativeTime(config, getRelativeTimeFormat, value, unit, options) {
  if (options === void 0) {
    options = {};
  }
  if (!unit) {
    unit = "second";
  }
  var RelativeTimeFormat = Intl.RelativeTimeFormat;
  if (!RelativeTimeFormat) {
    config.onError(new FormatError('Intl.RelativeTimeFormat is not available in this environment.\nTry polyfilling it using "@formatjs/intl-relativetimeformat"\n', ErrorCode.MISSING_INTL_API));
  }
  try {
    return getFormatter2(config, getRelativeTimeFormat, options).format(value, unit);
  } catch (e) {
    config.onError(new IntlFormatError("Error formatting relative time.", config.locale, e));
  }
  return String(value);
}

// node_modules/@strapi/plugin-seo/node_modules/@formatjs/intl/lib/src/number.js
var NUMBER_FORMAT_OPTIONS = [
  "style",
  "currency",
  "unit",
  "unitDisplay",
  "useGrouping",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  // ES2020 NumberFormat
  "compactDisplay",
  "currencyDisplay",
  "currencySign",
  "notation",
  "signDisplay",
  "unit",
  "unitDisplay",
  "numberingSystem",
  // ES2023 NumberFormat
  "trailingZeroDisplay",
  "roundingPriority",
  "roundingIncrement",
  "roundingMode"
];
function getFormatter3(_a2, getNumberFormat, options) {
  var locale = _a2.locale, formats = _a2.formats, onError = _a2.onError;
  if (options === void 0) {
    options = {};
  }
  var format2 = options.format;
  var defaults = format2 && getNamedFormat(formats, "number", format2, onError) || {};
  var filteredOptions = filterProps(options, NUMBER_FORMAT_OPTIONS, defaults);
  return getNumberFormat(locale, filteredOptions);
}
function formatNumber(config, getNumberFormat, value, options) {
  if (options === void 0) {
    options = {};
  }
  try {
    return getFormatter3(config, getNumberFormat, options).format(value);
  } catch (e) {
    config.onError(new IntlFormatError("Error formatting number.", config.locale, e));
  }
  return String(value);
}
function formatNumberToParts(config, getNumberFormat, value, options) {
  if (options === void 0) {
    options = {};
  }
  try {
    return getFormatter3(config, getNumberFormat, options).formatToParts(value);
  } catch (e) {
    config.onError(new IntlFormatError("Error formatting number.", config.locale, e));
  }
  return [];
}

// node_modules/@strapi/plugin-seo/node_modules/@formatjs/intl/lib/src/create-intl.js
function messagesContainString(messages) {
  var firstMessage = messages ? messages[Object.keys(messages)[0]] : void 0;
  return typeof firstMessage === "string";
}
function verifyConfigMessages(config) {
  if (config.onWarn && config.defaultRichTextElements && messagesContainString(config.messages || {})) {
    config.onWarn('[@formatjs/intl] "defaultRichTextElements" was specified but "message" was not pre-compiled. \nPlease consider using "@formatjs/cli" to pre-compile your messages for performance.\nFor more details see https://formatjs.io/docs/getting-started/message-distribution');
  }
}
function createIntl(config, cache) {
  var formatters2 = createFormatters(cache);
  var resolvedConfig = __assign(__assign({}, DEFAULT_INTL_CONFIG), config);
  var locale = resolvedConfig.locale, defaultLocale = resolvedConfig.defaultLocale, onError = resolvedConfig.onError;
  if (!locale) {
    if (onError) {
      onError(new InvalidConfigError('"locale" was not configured, using "'.concat(defaultLocale, '" as fallback. See https://formatjs.io/docs/react-intl/api#intlshape for more details')));
    }
    resolvedConfig.locale = resolvedConfig.defaultLocale || "en";
  } else if (!Intl.NumberFormat.supportedLocalesOf(locale).length && onError) {
    onError(new MissingDataError('Missing locale data for locale: "'.concat(locale, '" in Intl.NumberFormat. Using default locale: "').concat(defaultLocale, '" as fallback. See https://formatjs.io/docs/react-intl#runtime-requirements for more details')));
  } else if (!Intl.DateTimeFormat.supportedLocalesOf(locale).length && onError) {
    onError(new MissingDataError('Missing locale data for locale: "'.concat(locale, '" in Intl.DateTimeFormat. Using default locale: "').concat(defaultLocale, '" as fallback. See https://formatjs.io/docs/react-intl#runtime-requirements for more details')));
  }
  verifyConfigMessages(resolvedConfig);
  return __assign(__assign({}, resolvedConfig), {
    formatters: formatters2,
    formatNumber: formatNumber.bind(null, resolvedConfig, formatters2.getNumberFormat),
    formatNumberToParts: formatNumberToParts.bind(null, resolvedConfig, formatters2.getNumberFormat),
    formatRelativeTime: formatRelativeTime.bind(null, resolvedConfig, formatters2.getRelativeTimeFormat),
    formatDate: formatDate.bind(null, resolvedConfig, formatters2.getDateTimeFormat),
    formatDateToParts: formatDateToParts.bind(null, resolvedConfig, formatters2.getDateTimeFormat),
    formatTime: formatTime.bind(null, resolvedConfig, formatters2.getDateTimeFormat),
    formatDateTimeRange: formatDateTimeRange.bind(null, resolvedConfig, formatters2.getDateTimeFormat),
    formatTimeToParts: formatTimeToParts.bind(null, resolvedConfig, formatters2.getDateTimeFormat),
    formatPlural: formatPlural.bind(null, resolvedConfig, formatters2.getPluralRules),
    // @ts-expect-error TODO: will get to this later
    formatMessage: formatMessage.bind(null, resolvedConfig, formatters2),
    // @ts-expect-error TODO: will get to this later
    $t: formatMessage.bind(null, resolvedConfig, formatters2),
    formatList: formatList.bind(null, resolvedConfig, formatters2.getListFormat),
    formatListToParts: formatListToParts.bind(null, resolvedConfig, formatters2.getListFormat),
    formatDisplayName: formatDisplayName.bind(null, resolvedConfig, formatters2.getDisplayNames)
  });
}

// node_modules/@strapi/plugin-seo/node_modules/react-intl/lib/src/utils.js
function invariantIntlContext(intl) {
  invariant(intl, "[React Intl] Could not find required `intl` object. <IntlProvider> needs to exist in the component ancestry.");
}
var DEFAULT_INTL_CONFIG2 = __assign(__assign({}, DEFAULT_INTL_CONFIG), { textComponent: React.Fragment });
function assignUniqueKeysToParts(formatXMLElementFn) {
  return function(parts) {
    return formatXMLElementFn(React.Children.toArray(parts));
  };
}
function shallowEqual(objA, objB) {
  if (objA === objB) {
    return true;
  }
  if (!objA || !objB) {
    return false;
  }
  var aKeys = Object.keys(objA);
  var bKeys = Object.keys(objB);
  var len = aKeys.length;
  if (bKeys.length !== len) {
    return false;
  }
  for (var i = 0; i < len; i++) {
    var key = aKeys[i];
    if (objA[key] !== objB[key] || !Object.prototype.hasOwnProperty.call(objB, key)) {
      return false;
    }
  }
  return true;
}

// node_modules/@strapi/plugin-seo/node_modules/react-intl/lib/src/components/injectIntl.js
var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
var React2 = __toESM(require_react());
var IntlContext = typeof window !== "undefined" && !window.__REACT_INTL_BYPASS_GLOBAL_CONTEXT__ ? window.__REACT_INTL_CONTEXT__ || (window.__REACT_INTL_CONTEXT__ = React2.createContext(null)) : React2.createContext(null);
var IntlConsumer = IntlContext.Consumer;
var IntlProvider = IntlContext.Provider;
var Provider = IntlProvider;
var Context = IntlContext;

// node_modules/@strapi/plugin-seo/node_modules/react-intl/lib/src/components/useIntl.js
function useIntl() {
  var intl = React3.useContext(Context);
  invariantIntlContext(intl);
  return intl;
}

// node_modules/@strapi/plugin-seo/node_modules/react-intl/lib/src/components/createFormattedComponent.js
var React4 = __toESM(require_react());
var DisplayName;
(function(DisplayName2) {
  DisplayName2["formatDate"] = "FormattedDate";
  DisplayName2["formatTime"] = "FormattedTime";
  DisplayName2["formatNumber"] = "FormattedNumber";
  DisplayName2["formatList"] = "FormattedList";
  DisplayName2["formatDisplayName"] = "FormattedDisplayName";
})(DisplayName || (DisplayName = {}));
var DisplayNameParts;
(function(DisplayNameParts2) {
  DisplayNameParts2["formatDate"] = "FormattedDateParts";
  DisplayNameParts2["formatTime"] = "FormattedTimeParts";
  DisplayNameParts2["formatNumber"] = "FormattedNumberParts";
  DisplayNameParts2["formatList"] = "FormattedListParts";
})(DisplayNameParts || (DisplayNameParts = {}));
var FormattedNumberParts = function(props) {
  var intl = useIntl();
  var value = props.value, children = props.children, formatProps = __rest(props, ["value", "children"]);
  return children(intl.formatNumberToParts(value, formatProps));
};
FormattedNumberParts.displayName = "FormattedNumberParts";
FormattedNumberParts.displayName = "FormattedNumberParts";
function createFormattedDateTimePartsComponent(name2) {
  var ComponentParts = function(props) {
    var intl = useIntl();
    var value = props.value, children = props.children, formatProps = __rest(props, ["value", "children"]);
    var date = typeof value === "string" ? new Date(value || 0) : value;
    var formattedParts = name2 === "formatDate" ? intl.formatDateToParts(date, formatProps) : intl.formatTimeToParts(date, formatProps);
    return children(formattedParts);
  };
  ComponentParts.displayName = DisplayNameParts[name2];
  return ComponentParts;
}
function createFormattedComponent(name2) {
  var Component = function(props) {
    var intl = useIntl();
    var value = props.value, children = props.children, formatProps = __rest(
      props,
      ["value", "children"]
    );
    var formattedValue = intl[name2](value, formatProps);
    if (typeof children === "function") {
      return children(formattedValue);
    }
    var Text = intl.textComponent || React4.Fragment;
    return React4.createElement(Text, null, formattedValue);
  };
  Component.displayName = DisplayName[name2];
  return Component;
}

// node_modules/@strapi/plugin-seo/node_modules/react-intl/lib/src/components/provider.js
var React6 = __toESM(require_react());

// node_modules/@strapi/plugin-seo/node_modules/react-intl/lib/src/components/createIntl.js
var React5 = __toESM(require_react());
function assignUniqueKeysToFormatXMLElementFnArgument(values) {
  if (!values) {
    return values;
  }
  return Object.keys(values).reduce(function(acc, k) {
    var v = values[k];
    acc[k] = isFormatXMLElementFn(v) ? assignUniqueKeysToParts(v) : v;
    return acc;
  }, {});
}
var formatMessage2 = function(config, formatters2, descriptor, rawValues) {
  var rest = [];
  for (var _i = 4; _i < arguments.length; _i++) {
    rest[_i - 4] = arguments[_i];
  }
  var values = assignUniqueKeysToFormatXMLElementFnArgument(rawValues);
  var chunks = formatMessage.apply(void 0, __spreadArray([
    config,
    formatters2,
    descriptor,
    values
  ], rest, false));
  if (Array.isArray(chunks)) {
    return React5.Children.toArray(chunks);
  }
  return chunks;
};
var createIntl2 = function(_a2, cache) {
  var rawDefaultRichTextElements = _a2.defaultRichTextElements, config = __rest(_a2, ["defaultRichTextElements"]);
  var defaultRichTextElements = assignUniqueKeysToFormatXMLElementFnArgument(rawDefaultRichTextElements);
  var coreIntl = createIntl(__assign(__assign(__assign({}, DEFAULT_INTL_CONFIG2), config), { defaultRichTextElements }), cache);
  var resolvedConfig = {
    locale: coreIntl.locale,
    timeZone: coreIntl.timeZone,
    fallbackOnEmptyString: coreIntl.fallbackOnEmptyString,
    formats: coreIntl.formats,
    defaultLocale: coreIntl.defaultLocale,
    defaultFormats: coreIntl.defaultFormats,
    messages: coreIntl.messages,
    onError: coreIntl.onError,
    defaultRichTextElements
  };
  return __assign(__assign({}, coreIntl), {
    formatMessage: formatMessage2.bind(
      null,
      resolvedConfig,
      // @ts-expect-error fix this
      coreIntl.formatters
    ),
    // @ts-expect-error fix this
    $t: formatMessage2.bind(null, resolvedConfig, coreIntl.formatters)
  });
};

// node_modules/@strapi/plugin-seo/node_modules/react-intl/lib/src/components/provider.js
function processIntlConfig(config) {
  return {
    locale: config.locale,
    timeZone: config.timeZone,
    fallbackOnEmptyString: config.fallbackOnEmptyString,
    formats: config.formats,
    textComponent: config.textComponent,
    messages: config.messages,
    defaultLocale: config.defaultLocale,
    defaultFormats: config.defaultFormats,
    onError: config.onError,
    onWarn: config.onWarn,
    wrapRichTextChunksInFragment: config.wrapRichTextChunksInFragment,
    defaultRichTextElements: config.defaultRichTextElements
  };
}
var IntlProvider2 = (
  /** @class */
  function(_super) {
    __extends(IntlProvider3, _super);
    function IntlProvider3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.cache = createIntlCache();
      _this.state = {
        cache: _this.cache,
        intl: createIntl2(processIntlConfig(_this.props), _this.cache),
        prevConfig: processIntlConfig(_this.props)
      };
      return _this;
    }
    IntlProvider3.getDerivedStateFromProps = function(props, _a2) {
      var prevConfig = _a2.prevConfig, cache = _a2.cache;
      var config = processIntlConfig(props);
      if (!shallowEqual(prevConfig, config)) {
        return {
          intl: createIntl2(config, cache),
          prevConfig: config
        };
      }
      return null;
    };
    IntlProvider3.prototype.render = function() {
      invariantIntlContext(this.state.intl);
      return React6.createElement(Provider, { value: this.state.intl }, this.props.children);
    };
    IntlProvider3.displayName = "IntlProvider";
    IntlProvider3.defaultProps = DEFAULT_INTL_CONFIG2;
    return IntlProvider3;
  }(React6.PureComponent)
);

// node_modules/@strapi/plugin-seo/node_modules/react-intl/lib/src/components/relative.js
var React7 = __toESM(require_react());
var MINUTE = 60;
var HOUR = 60 * 60;
var DAY = 60 * 60 * 24;
function selectUnit(seconds) {
  var absValue = Math.abs(seconds);
  if (absValue < MINUTE) {
    return "second";
  }
  if (absValue < HOUR) {
    return "minute";
  }
  if (absValue < DAY) {
    return "hour";
  }
  return "day";
}
function getDurationInSeconds(unit) {
  switch (unit) {
    case "second":
      return 1;
    case "minute":
      return MINUTE;
    case "hour":
      return HOUR;
    default:
      return DAY;
  }
}
function valueToSeconds(value, unit) {
  if (!value) {
    return 0;
  }
  switch (unit) {
    case "second":
      return value;
    case "minute":
      return value * MINUTE;
    default:
      return value * HOUR;
  }
}
var INCREMENTABLE_UNITS = [
  "second",
  "minute",
  "hour"
];
function canIncrement(unit) {
  if (unit === void 0) {
    unit = "second";
  }
  return INCREMENTABLE_UNITS.indexOf(unit) > -1;
}
var SimpleFormattedRelativeTime = function(props) {
  var _a2 = useIntl(), formatRelativeTime2 = _a2.formatRelativeTime, Text = _a2.textComponent;
  var children = props.children, value = props.value, unit = props.unit, otherProps = __rest(props, ["children", "value", "unit"]);
  var formattedRelativeTime = formatRelativeTime2(value || 0, unit, otherProps);
  if (typeof children === "function") {
    return children(formattedRelativeTime);
  }
  if (Text) {
    return React7.createElement(Text, null, formattedRelativeTime);
  }
  return React7.createElement(React7.Fragment, null, formattedRelativeTime);
};
var FormattedRelativeTime = function(_a2) {
  var _b = _a2.value, value = _b === void 0 ? 0 : _b, _c = _a2.unit, unit = _c === void 0 ? "second" : _c, updateIntervalInSeconds = _a2.updateIntervalInSeconds, otherProps = __rest(_a2, ["value", "unit", "updateIntervalInSeconds"]);
  invariant(!updateIntervalInSeconds || !!(updateIntervalInSeconds && canIncrement(unit)), "Cannot schedule update with unit longer than hour");
  var _d = React7.useState(), prevUnit = _d[0], setPrevUnit = _d[1];
  var _e = React7.useState(0), prevValue = _e[0], setPrevValue = _e[1];
  var _f = React7.useState(0), currentValueInSeconds = _f[0], setCurrentValueInSeconds = _f[1];
  var updateTimer;
  if (unit !== prevUnit || value !== prevValue) {
    setPrevValue(value || 0);
    setPrevUnit(unit);
    setCurrentValueInSeconds(canIncrement(unit) ? valueToSeconds(value, unit) : 0);
  }
  React7.useEffect(function() {
    function clearUpdateTimer() {
      clearTimeout(updateTimer);
    }
    clearUpdateTimer();
    if (!updateIntervalInSeconds || !canIncrement(unit)) {
      return clearUpdateTimer;
    }
    var nextValueInSeconds = currentValueInSeconds - updateIntervalInSeconds;
    var nextUnit = selectUnit(nextValueInSeconds);
    if (nextUnit === "day") {
      return clearUpdateTimer;
    }
    var unitDuration2 = getDurationInSeconds(nextUnit);
    var remainder = nextValueInSeconds % unitDuration2;
    var prevInterestingValueInSeconds = nextValueInSeconds - remainder;
    var nextInterestingValueInSeconds = prevInterestingValueInSeconds >= currentValueInSeconds ? prevInterestingValueInSeconds - unitDuration2 : prevInterestingValueInSeconds;
    var delayInSeconds = Math.abs(nextInterestingValueInSeconds - currentValueInSeconds);
    if (currentValueInSeconds !== nextInterestingValueInSeconds) {
      updateTimer = setTimeout(function() {
        return setCurrentValueInSeconds(nextInterestingValueInSeconds);
      }, delayInSeconds * 1e3);
    }
    return clearUpdateTimer;
  }, [currentValueInSeconds, updateIntervalInSeconds, unit]);
  var currentValue = value || 0;
  var currentUnit = unit;
  if (canIncrement(unit) && typeof currentValueInSeconds === "number" && updateIntervalInSeconds) {
    currentUnit = selectUnit(currentValueInSeconds);
    var unitDuration = getDurationInSeconds(currentUnit);
    currentValue = Math.round(currentValueInSeconds / unitDuration);
  }
  return React7.createElement(SimpleFormattedRelativeTime, __assign({ value: currentValue, unit: currentUnit }, otherProps));
};
FormattedRelativeTime.displayName = "FormattedRelativeTime";

// node_modules/@strapi/plugin-seo/node_modules/react-intl/lib/src/components/plural.js
var React8 = __toESM(require_react());
var FormattedPlural = function(props) {
  var _a2 = useIntl(), formatPlural2 = _a2.formatPlural, Text = _a2.textComponent;
  var value = props.value, other = props.other, children = props.children;
  var pluralCategory = formatPlural2(value, props);
  var formattedPlural = props[pluralCategory] || other;
  if (typeof children === "function") {
    return children(formattedPlural);
  }
  if (Text) {
    return React8.createElement(Text, null, formattedPlural);
  }
  return formattedPlural;
};
FormattedPlural.displayName = "FormattedPlural";

// node_modules/@strapi/plugin-seo/node_modules/react-intl/lib/src/components/message.js
var React9 = __toESM(require_react());
function areEqual(prevProps, nextProps) {
  var values = prevProps.values, otherProps = __rest(prevProps, ["values"]);
  var nextValues = nextProps.values, nextOtherProps = __rest(nextProps, ["values"]);
  return shallowEqual(nextValues, values) && shallowEqual(otherProps, nextOtherProps);
}
function FormattedMessage(props) {
  var intl = useIntl();
  var formatMessage3 = intl.formatMessage, _a2 = intl.textComponent, Text = _a2 === void 0 ? React9.Fragment : _a2;
  var id = props.id, description2 = props.description, defaultMessage = props.defaultMessage, values = props.values, children = props.children, _b = props.tagName, Component = _b === void 0 ? Text : _b, ignoreTag = props.ignoreTag;
  var descriptor = { id, description: description2, defaultMessage };
  var nodes = formatMessage3(descriptor, values, {
    ignoreTag
  });
  if (typeof children === "function") {
    return children(Array.isArray(nodes) ? nodes : [nodes]);
  }
  if (Component) {
    return React9.createElement(Component, null, React9.Children.toArray(nodes));
  }
  return React9.createElement(React9.Fragment, null, nodes);
}
FormattedMessage.displayName = "FormattedMessage";
var MemoizedFormattedMessage = React9.memo(FormattedMessage, areEqual);
MemoizedFormattedMessage.displayName = "MemoizedFormattedMessage";

// node_modules/@strapi/plugin-seo/node_modules/react-intl/lib/src/components/dateTimeRange.js
var React10 = __toESM(require_react());
var FormattedDateTimeRange = function(props) {
  var intl = useIntl();
  var from = props.from, to = props.to, children = props.children, formatProps = __rest(props, ["from", "to", "children"]);
  var formattedValue = intl.formatDateTimeRange(from, to, formatProps);
  if (typeof children === "function") {
    return children(formattedValue);
  }
  var Text = intl.textComponent || React10.Fragment;
  return React10.createElement(Text, null, formattedValue);
};
FormattedDateTimeRange.displayName = "FormattedDateTimeRange";

// node_modules/@strapi/plugin-seo/node_modules/react-intl/lib/index.js
var FormattedDate = createFormattedComponent("formatDate");
var FormattedTime = createFormattedComponent("formatTime");
var FormattedNumber = createFormattedComponent("formatNumber");
var FormattedList = createFormattedComponent("formatList");
var FormattedDisplayName = createFormattedComponent("formatDisplayName");
var FormattedDateParts = createFormattedDateTimePartsComponent("formatDate");
var FormattedTimeParts = createFormattedDateTimePartsComponent("formatTime");

// node_modules/@strapi/plugin-seo/dist/_chunks/index-DoK7BakP.mjs
var React11 = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_isEqual = __toESM(require_isEqual(), 1);
var import_isNull = __toESM(require_isNull(), 1);
var import_isEmpty = __toESM(require_isEmpty(), 1);
var import_get = __toESM(require_get(), 1);
var import_isNumber = __toESM(require_isNumber(), 1);

// node_modules/@strapi/plugin-seo/node_modules/date-fns/constants.js
var daysInYear = 365.2425;
var maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1e3;
var minTime = -maxTime;
var millisecondsInWeek = 6048e5;
var millisecondsInMinute = 6e4;
var millisecondsInHour = 36e5;
var millisecondsInSecond = 1e3;
var minutesInMonth = 43200;
var minutesInDay = 1440;
var secondsInHour = 3600;
var secondsInDay = secondsInHour * 24;
var secondsInWeek = secondsInDay * 7;
var secondsInYear = secondsInDay * daysInYear;
var secondsInMonth = secondsInYear / 12;
var secondsInQuarter = secondsInMonth * 3;
var constructFromSymbol = Symbol.for("constructDateFrom");

// node_modules/@strapi/plugin-seo/node_modules/date-fns/constructFrom.js
function constructFrom(date, value) {
  if (typeof date === "function") return date(value);
  if (date && typeof date === "object" && constructFromSymbol in date)
    return date[constructFromSymbol](value);
  if (date instanceof Date) return new date.constructor(value);
  return new Date(value);
}

// node_modules/@strapi/plugin-seo/node_modules/date-fns/toDate.js
function toDate(argument, context) {
  return constructFrom(context || argument, argument);
}

// node_modules/@strapi/plugin-seo/node_modules/date-fns/addDays.js
function addDays(date, amount, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  if (isNaN(amount)) return constructFrom((options == null ? void 0 : options.in) || date, NaN);
  if (!amount) return _date;
  _date.setDate(_date.getDate() + amount);
  return _date;
}

// node_modules/@strapi/plugin-seo/node_modules/date-fns/_lib/defaultOptions.js
var defaultOptions = {};
function getDefaultOptions() {
  return defaultOptions;
}

// node_modules/@strapi/plugin-seo/node_modules/date-fns/startOfWeek.js
function startOfWeek(date, options) {
  var _a2, _b, _c, _d;
  const defaultOptions2 = getDefaultOptions();
  const weekStartsOn = (options == null ? void 0 : options.weekStartsOn) ?? ((_b = (_a2 = options == null ? void 0 : options.locale) == null ? void 0 : _a2.options) == null ? void 0 : _b.weekStartsOn) ?? defaultOptions2.weekStartsOn ?? ((_d = (_c = defaultOptions2.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.weekStartsOn) ?? 0;
  const _date = toDate(date, options == null ? void 0 : options.in);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  _date.setDate(_date.getDate() - diff);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// node_modules/@strapi/plugin-seo/node_modules/date-fns/startOfISOWeek.js
function startOfISOWeek(date, options) {
  return startOfWeek(date, { ...options, weekStartsOn: 1 });
}

// node_modules/@strapi/plugin-seo/node_modules/date-fns/getISOWeekYear.js
function getISOWeekYear(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  const year = _date.getFullYear();
  const fourthOfJanuaryOfNextYear = constructFrom(_date, 0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
  const fourthOfJanuaryOfThisYear = constructFrom(_date, 0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/@strapi/plugin-seo/node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.js
function getTimezoneOffsetInMilliseconds(date) {
  const _date = toDate(date);
  const utcDate = new Date(
    Date.UTC(
      _date.getFullYear(),
      _date.getMonth(),
      _date.getDate(),
      _date.getHours(),
      _date.getMinutes(),
      _date.getSeconds(),
      _date.getMilliseconds()
    )
  );
  utcDate.setUTCFullYear(_date.getFullYear());
  return +date - +utcDate;
}

// node_modules/@strapi/plugin-seo/node_modules/date-fns/_lib/normalizeDates.js
function normalizeDates(context, ...dates) {
  const normalize = constructFrom.bind(
    null,
    context || dates.find((date) => typeof date === "object")
  );
  return dates.map(normalize);
}

// node_modules/@strapi/plugin-seo/node_modules/date-fns/startOfISOWeekYear.js
function startOfISOWeekYear(date, options) {
  const year = getISOWeekYear(date, options);
  const fourthOfJanuary = constructFrom((options == null ? void 0 : options.in) || date, 0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  return startOfISOWeek(fourthOfJanuary);
}

// node_modules/@strapi/plugin-seo/node_modules/date-fns/compareAsc.js
function compareAsc(dateLeft, dateRight) {
  const diff = +toDate(dateLeft) - +toDate(dateRight);
  if (diff < 0) return -1;
  else if (diff > 0) return 1;
  return diff;
}

// node_modules/@strapi/plugin-seo/node_modules/date-fns/differenceInCalendarMonths.js
function differenceInCalendarMonths(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options == null ? void 0 : options.in,
    laterDate,
    earlierDate
  );
  const yearsDiff = laterDate_.getFullYear() - earlierDate_.getFullYear();
  const monthsDiff = laterDate_.getMonth() - earlierDate_.getMonth();
  return yearsDiff * 12 + monthsDiff;
}

// node_modules/@strapi/plugin-seo/node_modules/date-fns/_lib/getRoundingMethod.js
function getRoundingMethod(method) {
  return (number) => {
    const round = method ? Math[method] : Math.trunc;
    const result = round(number);
    return result === 0 ? 0 : result;
  };
}

// node_modules/@strapi/plugin-seo/node_modules/date-fns/differenceInMilliseconds.js
function differenceInMilliseconds(laterDate, earlierDate) {
  return +toDate(laterDate) - +toDate(earlierDate);
}

// node_modules/@strapi/plugin-seo/node_modules/date-fns/endOfDay.js
function endOfDay(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  _date.setHours(23, 59, 59, 999);
  return _date;
}

// node_modules/@strapi/plugin-seo/node_modules/date-fns/endOfMonth.js
function endOfMonth(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  const month = _date.getMonth();
  _date.setFullYear(_date.getFullYear(), month + 1, 0);
  _date.setHours(23, 59, 59, 999);
  return _date;
}

// node_modules/@strapi/plugin-seo/node_modules/date-fns/isLastDayOfMonth.js
function isLastDayOfMonth(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  return +endOfDay(_date, options) === +endOfMonth(_date, options);
}

// node_modules/@strapi/plugin-seo/node_modules/date-fns/differenceInMonths.js
function differenceInMonths(laterDate, earlierDate, options) {
  const [laterDate_, workingLaterDate, earlierDate_] = normalizeDates(
    options == null ? void 0 : options.in,
    laterDate,
    laterDate,
    earlierDate
  );
  const sign = compareAsc(workingLaterDate, earlierDate_);
  const difference = Math.abs(
    differenceInCalendarMonths(workingLaterDate, earlierDate_)
  );
  if (difference < 1) return 0;
  if (workingLaterDate.getMonth() === 1 && workingLaterDate.getDate() > 27)
    workingLaterDate.setDate(30);
  workingLaterDate.setMonth(workingLaterDate.getMonth() - sign * difference);
  let isLastMonthNotFull = compareAsc(workingLaterDate, earlierDate_) === -sign;
  if (isLastDayOfMonth(laterDate_) && difference === 1 && compareAsc(laterDate_, earlierDate_) === 1) {
    isLastMonthNotFull = false;
  }
  const result = sign * (difference - +isLastMonthNotFull);
  return result === 0 ? 0 : result;
}

// node_modules/@strapi/plugin-seo/node_modules/date-fns/differenceInSeconds.js
function differenceInSeconds(laterDate, earlierDate, options) {
  const diff = differenceInMilliseconds(laterDate, earlierDate) / 1e3;
  return getRoundingMethod(options == null ? void 0 : options.roundingMethod)(diff);
}

// node_modules/@strapi/plugin-seo/node_modules/date-fns/locale/en-US/_lib/formatDistance.js
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
var formatDistance = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options == null ? void 0 : options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/locale/_lib/buildFormatLongFn.js
function buildFormatLongFn(args) {
  return (options = {}) => {
    const width = options.width ? String(options.width) : args.defaultWidth;
    const format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}

// node_modules/@strapi/plugin-seo/node_modules/date-fns/locale/en-US/_lib/formatLong.js
var dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/locale/en-US/_lib/formatRelative.js
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
var formatRelative = (token, _date, _baseDate, _options) => formatRelativeLocale[token];

// node_modules/@strapi/plugin-seo/node_modules/date-fns/locale/_lib/buildLocalizeFn.js
function buildLocalizeFn(args) {
  return (value, options) => {
    const context = (options == null ? void 0 : options.context) ? String(options.context) : "standalone";
    let valuesArray;
    if (context === "formatting" && args.formattingValues) {
      const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      const width = (options == null ? void 0 : options.width) ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      const defaultWidth = args.defaultWidth;
      const width = (options == null ? void 0 : options.width) ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[width] || args.values[defaultWidth];
    }
    const index2 = args.argumentCallback ? args.argumentCallback(value) : value;
    return valuesArray[index2];
  };
}

// node_modules/@strapi/plugin-seo/node_modules/date-fns/locale/en-US/_lib/localize.js
var eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
};
var dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
var ordinalNumber = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  const rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/locale/_lib/buildMatchFn.js
function buildMatchFn(args) {
  return (string, options = {}) => {
    const width = options.width;
    const matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    const matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    const matchedString = matchResult[0];
    const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    const key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString)) : (
      // [TODO] -- I challenge you to fix the type
      findKey(parsePatterns, (pattern) => pattern.test(matchedString))
    );
    let value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? (
      // [TODO] -- I challenge you to fix the type
      options.valueCallback(value)
    ) : value;
    const rest = string.slice(matchedString.length);
    return { value, rest };
  };
}
function findKey(object, predicate) {
  for (const key in object) {
    if (Object.prototype.hasOwnProperty.call(object, key) && predicate(object[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array, predicate) {
  for (let key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return void 0;
}

// node_modules/@strapi/plugin-seo/node_modules/date-fns/locale/_lib/buildMatchPatternFn.js
function buildMatchPatternFn(args) {
  return (string, options = {}) => {
    const matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    const matchedString = matchResult[0];
    const parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    const rest = string.slice(matchedString.length);
    return { value, rest };
  };
}

// node_modules/@strapi/plugin-seo/node_modules/date-fns/locale/en-US/_lib/match.js
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/locale/en-US.js
var enUS = {
  code: "en-US",
  formatDistance,
  formatLong,
  formatRelative,
  localize,
  match,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/getISOWeek.js
function getISOWeek(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  const diff = +startOfISOWeek(_date) - +startOfISOWeekYear(_date);
  return Math.round(diff / millisecondsInWeek) + 1;
}

// node_modules/@strapi/plugin-seo/node_modules/date-fns/getWeekYear.js
function getWeekYear(date, options) {
  var _a2, _b, _c, _d;
  const _date = toDate(date, options == null ? void 0 : options.in);
  const year = _date.getFullYear();
  const defaultOptions2 = getDefaultOptions();
  const firstWeekContainsDate = (options == null ? void 0 : options.firstWeekContainsDate) ?? ((_b = (_a2 = options == null ? void 0 : options.locale) == null ? void 0 : _a2.options) == null ? void 0 : _b.firstWeekContainsDate) ?? defaultOptions2.firstWeekContainsDate ?? ((_d = (_c = defaultOptions2.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) ?? 1;
  const firstWeekOfNextYear = constructFrom((options == null ? void 0 : options.in) || date, 0);
  firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfWeek(firstWeekOfNextYear, options);
  const firstWeekOfThisYear = constructFrom((options == null ? void 0 : options.in) || date, 0);
  firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfWeek(firstWeekOfThisYear, options);
  if (+_date >= +startOfNextYear) {
    return year + 1;
  } else if (+_date >= +startOfThisYear) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/@strapi/plugin-seo/node_modules/date-fns/startOfWeekYear.js
function startOfWeekYear(date, options) {
  var _a2, _b, _c, _d;
  const defaultOptions2 = getDefaultOptions();
  const firstWeekContainsDate = (options == null ? void 0 : options.firstWeekContainsDate) ?? ((_b = (_a2 = options == null ? void 0 : options.locale) == null ? void 0 : _a2.options) == null ? void 0 : _b.firstWeekContainsDate) ?? defaultOptions2.firstWeekContainsDate ?? ((_d = (_c = defaultOptions2.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) ?? 1;
  const year = getWeekYear(date, options);
  const firstWeek = constructFrom((options == null ? void 0 : options.in) || date, 0);
  firstWeek.setFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  const _date = startOfWeek(firstWeek, options);
  return _date;
}

// node_modules/@strapi/plugin-seo/node_modules/date-fns/getWeek.js
function getWeek(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  const diff = +startOfWeek(_date, options) - +startOfWeekYear(_date, options);
  return Math.round(diff / millisecondsInWeek) + 1;
}

// node_modules/@strapi/plugin-seo/node_modules/date-fns/formatDistance.js
function formatDistance2(laterDate, earlierDate, options) {
  const defaultOptions2 = getDefaultOptions();
  const locale = (options == null ? void 0 : options.locale) ?? defaultOptions2.locale ?? enUS;
  const minutesInAlmostTwoDays = 2520;
  const comparison = compareAsc(laterDate, earlierDate);
  if (isNaN(comparison)) throw new RangeError("Invalid time value");
  const localizeOptions = Object.assign({}, options, {
    addSuffix: options == null ? void 0 : options.addSuffix,
    comparison
  });
  const [laterDate_, earlierDate_] = normalizeDates(
    options == null ? void 0 : options.in,
    ...comparison > 0 ? [earlierDate, laterDate] : [laterDate, earlierDate]
  );
  const seconds = differenceInSeconds(earlierDate_, laterDate_);
  const offsetInSeconds = (getTimezoneOffsetInMilliseconds(earlierDate_) - getTimezoneOffsetInMilliseconds(laterDate_)) / 1e3;
  const minutes = Math.round((seconds - offsetInSeconds) / 60);
  let months;
  if (minutes < 2) {
    if (options == null ? void 0 : options.includeSeconds) {
      if (seconds < 5) {
        return locale.formatDistance("lessThanXSeconds", 5, localizeOptions);
      } else if (seconds < 10) {
        return locale.formatDistance("lessThanXSeconds", 10, localizeOptions);
      } else if (seconds < 20) {
        return locale.formatDistance("lessThanXSeconds", 20, localizeOptions);
      } else if (seconds < 40) {
        return locale.formatDistance("halfAMinute", 0, localizeOptions);
      } else if (seconds < 60) {
        return locale.formatDistance("lessThanXMinutes", 1, localizeOptions);
      } else {
        return locale.formatDistance("xMinutes", 1, localizeOptions);
      }
    } else {
      if (minutes === 0) {
        return locale.formatDistance("lessThanXMinutes", 1, localizeOptions);
      } else {
        return locale.formatDistance("xMinutes", minutes, localizeOptions);
      }
    }
  } else if (minutes < 45) {
    return locale.formatDistance("xMinutes", minutes, localizeOptions);
  } else if (minutes < 90) {
    return locale.formatDistance("aboutXHours", 1, localizeOptions);
  } else if (minutes < minutesInDay) {
    const hours = Math.round(minutes / 60);
    return locale.formatDistance("aboutXHours", hours, localizeOptions);
  } else if (minutes < minutesInAlmostTwoDays) {
    return locale.formatDistance("xDays", 1, localizeOptions);
  } else if (minutes < minutesInMonth) {
    const days = Math.round(minutes / minutesInDay);
    return locale.formatDistance("xDays", days, localizeOptions);
  } else if (minutes < minutesInMonth * 2) {
    months = Math.round(minutes / minutesInMonth);
    return locale.formatDistance("aboutXMonths", months, localizeOptions);
  }
  months = differenceInMonths(earlierDate_, laterDate_);
  if (months < 12) {
    const nearestMonth = Math.round(minutes / minutesInMonth);
    return locale.formatDistance("xMonths", nearestMonth, localizeOptions);
  } else {
    const monthsSinceStartOfYear = months % 12;
    const years = Math.trunc(months / 12);
    if (monthsSinceStartOfYear < 3) {
      return locale.formatDistance("aboutXYears", years, localizeOptions);
    } else if (monthsSinceStartOfYear < 9) {
      return locale.formatDistance("overXYears", years, localizeOptions);
    } else {
      return locale.formatDistance("almostXYears", years + 1, localizeOptions);
    }
  }
}

// node_modules/@strapi/plugin-seo/node_modules/date-fns/getISODay.js
function getISODay(date, options) {
  const day = toDate(date, options == null ? void 0 : options.in).getDay();
  return day === 0 ? 7 : day;
}

// node_modules/@strapi/plugin-seo/node_modules/date-fns/parse/_lib/Setter.js
var Setter = class {
  constructor() {
    __publicField(this, "subPriority", 0);
  }
  validate(_utcDate, _options) {
    return true;
  }
};
var ValueSetter = class extends Setter {
  constructor(value, validateValue, setValue, priority, subPriority) {
    super();
    this.value = value;
    this.validateValue = validateValue;
    this.setValue = setValue;
    this.priority = priority;
    if (subPriority) {
      this.subPriority = subPriority;
    }
  }
  validate(date, options) {
    return this.validateValue(date, this.value, options);
  }
  set(date, flags, options) {
    return this.setValue(date, flags, this.value, options);
  }
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/parse/_lib/Parser.js
var Parser2 = class {
  run(dateString, token, match2, options) {
    const result = this.parse(dateString, token, match2, options);
    if (!result) {
      return null;
    }
    return {
      setter: new ValueSetter(
        result.value,
        this.validate,
        this.set,
        this.priority,
        this.subPriority
      ),
      rest: result.rest
    };
  }
  validate(_utcDate, _value, _options) {
    return true;
  }
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/parse/_lib/parsers/EraParser.js
var EraParser = class extends Parser2 {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 140);
    __publicField(this, "incompatibleTokens", ["R", "u", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "G":
      case "GG":
      case "GGG":
        return match2.era(dateString, { width: "abbreviated" }) || match2.era(dateString, { width: "narrow" });
      case "GGGGG":
        return match2.era(dateString, { width: "narrow" });
      case "GGGG":
      default:
        return match2.era(dateString, { width: "wide" }) || match2.era(dateString, { width: "abbreviated" }) || match2.era(dateString, { width: "narrow" });
    }
  }
  set(date, flags, value) {
    flags.era = value;
    date.setFullYear(value, 0, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/parse/_lib/constants.js
var numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/
  // 0 to 9999, -0 to -9999
};
var timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/parse/_lib/utils.js
function mapValue(parseFnResult, mapFn) {
  if (!parseFnResult) {
    return parseFnResult;
  }
  return {
    value: mapFn(parseFnResult.value),
    rest: parseFnResult.rest
  };
}
function parseNumericPattern(pattern, dateString) {
  const matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  return {
    value: parseInt(matchResult[0], 10),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseTimezonePattern(pattern, dateString) {
  const matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  if (matchResult[0] === "Z") {
    return {
      value: 0,
      rest: dateString.slice(1)
    };
  }
  const sign = matchResult[1] === "+" ? 1 : -1;
  const hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  const minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  const seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned(dateString) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
}
function parseNDigits(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, dateString);
    default:
      return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), dateString);
  }
}
function parseNDigitsSigned(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
    default:
      return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), dateString);
  }
}
function dayPeriodEnumToHours(dayPeriod) {
  switch (dayPeriod) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  const isCommonEra = currentYear > 0;
  const absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  let result;
  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    const rangeEnd = absCurrentYear + 50;
    const rangeEndCentury = Math.trunc(rangeEnd / 100) * 100;
    const isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }
  return isCommonEra ? result : 1 - result;
}
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}

// node_modules/@strapi/plugin-seo/node_modules/date-fns/parse/_lib/parsers/YearParser.js
var YearParser = class extends Parser2 {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 130);
    __publicField(this, "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
  }
  parse(dateString, token, match2) {
    const valueCallback = (year) => ({
      year,
      isTwoDigitYear: token === "yy"
    });
    switch (token) {
      case "y":
        return mapValue(parseNDigits(4, dateString), valueCallback);
      case "yo":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "year"
          }),
          valueCallback
        );
      default:
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
    }
  }
  validate(_date, value) {
    return value.isTwoDigitYear || value.year > 0;
  }
  set(date, flags, value) {
    const currentYear = date.getFullYear();
    if (value.isTwoDigitYear) {
      const normalizedTwoDigitYear = normalizeTwoDigitYear(
        value.year,
        currentYear
      );
      date.setFullYear(normalizedTwoDigitYear, 0, 1);
      date.setHours(0, 0, 0, 0);
      return date;
    }
    const year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
    date.setFullYear(year, 0, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/parse/_lib/parsers/LocalWeekYearParser.js
var LocalWeekYearParser = class extends Parser2 {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 130);
    __publicField(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "Q",
      "q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "i",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    const valueCallback = (year) => ({
      year,
      isTwoDigitYear: token === "YY"
    });
    switch (token) {
      case "Y":
        return mapValue(parseNDigits(4, dateString), valueCallback);
      case "Yo":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "year"
          }),
          valueCallback
        );
      default:
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
    }
  }
  validate(_date, value) {
    return value.isTwoDigitYear || value.year > 0;
  }
  set(date, flags, value, options) {
    const currentYear = getWeekYear(date, options);
    if (value.isTwoDigitYear) {
      const normalizedTwoDigitYear = normalizeTwoDigitYear(
        value.year,
        currentYear
      );
      date.setFullYear(
        normalizedTwoDigitYear,
        0,
        options.firstWeekContainsDate
      );
      date.setHours(0, 0, 0, 0);
      return startOfWeek(date, options);
    }
    const year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
    date.setFullYear(year, 0, options.firstWeekContainsDate);
    date.setHours(0, 0, 0, 0);
    return startOfWeek(date, options);
  }
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/parse/_lib/parsers/ISOWeekYearParser.js
var ISOWeekYearParser = class extends Parser2 {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 130);
    __publicField(this, "incompatibleTokens", [
      "G",
      "y",
      "Y",
      "u",
      "Q",
      "q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token) {
    if (token === "R") {
      return parseNDigitsSigned(4, dateString);
    }
    return parseNDigitsSigned(token.length, dateString);
  }
  set(date, _flags, value) {
    const firstWeekOfYear = constructFrom(date, 0);
    firstWeekOfYear.setFullYear(value, 0, 4);
    firstWeekOfYear.setHours(0, 0, 0, 0);
    return startOfISOWeek(firstWeekOfYear);
  }
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/parse/_lib/parsers/ExtendedYearParser.js
var ExtendedYearParser = class extends Parser2 {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 130);
    __publicField(this, "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
  }
  parse(dateString, token) {
    if (token === "u") {
      return parseNDigitsSigned(4, dateString);
    }
    return parseNDigitsSigned(token.length, dateString);
  }
  set(date, _flags, value) {
    date.setFullYear(value, 0, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/parse/_lib/parsers/QuarterParser.js
var QuarterParser = class extends Parser2 {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 120);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "Q":
      case "QQ":
        return parseNDigits(token.length, dateString);
      case "Qo":
        return match2.ordinalNumber(dateString, { unit: "quarter" });
      case "QQQ":
        return match2.quarter(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.quarter(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQQ":
        return match2.quarter(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return match2.quarter(dateString, {
          width: "wide",
          context: "formatting"
        }) || match2.quarter(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.quarter(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 4;
  }
  set(date, _flags, value) {
    date.setMonth((value - 1) * 3, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/parse/_lib/parsers/StandAloneQuarterParser.js
var StandAloneQuarterParser = class extends Parser2 {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 120);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "Q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "q":
      case "qq":
        return parseNDigits(token.length, dateString);
      case "qo":
        return match2.ordinalNumber(dateString, { unit: "quarter" });
      case "qqq":
        return match2.quarter(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.quarter(dateString, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqqq":
        return match2.quarter(dateString, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return match2.quarter(dateString, {
          width: "wide",
          context: "standalone"
        }) || match2.quarter(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.quarter(dateString, {
          width: "narrow",
          context: "standalone"
        });
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 4;
  }
  set(date, _flags, value) {
    date.setMonth((value - 1) * 3, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/parse/_lib/parsers/MonthParser.js
var MonthParser = class extends Parser2 {
  constructor() {
    super(...arguments);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "L",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
    __publicField(this, "priority", 110);
  }
  parse(dateString, token, match2) {
    const valueCallback = (value) => value - 1;
    switch (token) {
      case "M":
        return mapValue(
          parseNumericPattern(numericPatterns.month, dateString),
          valueCallback
        );
      case "MM":
        return mapValue(parseNDigits(2, dateString), valueCallback);
      case "Mo":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "month"
          }),
          valueCallback
        );
      case "MMM":
        return match2.month(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.month(dateString, { width: "narrow", context: "formatting" });
      case "MMMMM":
        return match2.month(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return match2.month(dateString, { width: "wide", context: "formatting" }) || match2.month(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.month(dateString, { width: "narrow", context: "formatting" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 11;
  }
  set(date, _flags, value) {
    date.setMonth(value, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/parse/_lib/parsers/StandAloneMonthParser.js
var StandAloneMonthParser = class extends Parser2 {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 110);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "M",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    const valueCallback = (value) => value - 1;
    switch (token) {
      case "L":
        return mapValue(
          parseNumericPattern(numericPatterns.month, dateString),
          valueCallback
        );
      case "LL":
        return mapValue(parseNDigits(2, dateString), valueCallback);
      case "Lo":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "month"
          }),
          valueCallback
        );
      case "LLL":
        return match2.month(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.month(dateString, { width: "narrow", context: "standalone" });
      case "LLLLL":
        return match2.month(dateString, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return match2.month(dateString, { width: "wide", context: "standalone" }) || match2.month(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.month(dateString, { width: "narrow", context: "standalone" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 11;
  }
  set(date, _flags, value) {
    date.setMonth(value, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/setWeek.js
function setWeek(date, week, options) {
  const date_ = toDate(date, options == null ? void 0 : options.in);
  const diff = getWeek(date_, options) - week;
  date_.setDate(date_.getDate() - diff * 7);
  return toDate(date_, options == null ? void 0 : options.in);
}

// node_modules/@strapi/plugin-seo/node_modules/date-fns/parse/_lib/parsers/LocalWeekParser.js
var LocalWeekParser = class extends Parser2 {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 100);
    __publicField(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "i",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "w":
        return parseNumericPattern(numericPatterns.week, dateString);
      case "wo":
        return match2.ordinalNumber(dateString, { unit: "week" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 53;
  }
  set(date, _flags, value, options) {
    return startOfWeek(setWeek(date, value, options), options);
  }
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/setISOWeek.js
function setISOWeek(date, week, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  const diff = getISOWeek(_date, options) - week;
  _date.setDate(_date.getDate() - diff * 7);
  return _date;
}

// node_modules/@strapi/plugin-seo/node_modules/date-fns/parse/_lib/parsers/ISOWeekParser.js
var ISOWeekParser = class extends Parser2 {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 100);
    __publicField(this, "incompatibleTokens", [
      "y",
      "Y",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "I":
        return parseNumericPattern(numericPatterns.week, dateString);
      case "Io":
        return match2.ordinalNumber(dateString, { unit: "week" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 53;
  }
  set(date, _flags, value) {
    return startOfISOWeek(setISOWeek(date, value));
  }
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/parse/_lib/parsers/DateParser.js
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [
  31,
  29,
  31,
  30,
  31,
  30,
  31,
  31,
  30,
  31,
  30,
  31
];
var DateParser = class extends Parser2 {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "subPriority", 1);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "d":
        return parseNumericPattern(numericPatterns.date, dateString);
      case "do":
        return match2.ordinalNumber(dateString, { unit: "date" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(date, value) {
    const year = date.getFullYear();
    const isLeapYear2 = isLeapYearIndex(year);
    const month = date.getMonth();
    if (isLeapYear2) {
      return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
    } else {
      return value >= 1 && value <= DAYS_IN_MONTH[month];
    }
  }
  set(date, _flags, value) {
    date.setDate(value);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/parse/_lib/parsers/DayOfYearParser.js
var DayOfYearParser = class extends Parser2 {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "subpriority", 1);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "E",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "D":
      case "DD":
        return parseNumericPattern(numericPatterns.dayOfYear, dateString);
      case "Do":
        return match2.ordinalNumber(dateString, { unit: "date" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(date, value) {
    const year = date.getFullYear();
    const isLeapYear2 = isLeapYearIndex(year);
    if (isLeapYear2) {
      return value >= 1 && value <= 366;
    } else {
      return value >= 1 && value <= 365;
    }
  }
  set(date, _flags, value) {
    date.setMonth(0, value);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/setDay.js
function setDay(date, day, options) {
  var _a2, _b, _c, _d;
  const defaultOptions2 = getDefaultOptions();
  const weekStartsOn = (options == null ? void 0 : options.weekStartsOn) ?? ((_b = (_a2 = options == null ? void 0 : options.locale) == null ? void 0 : _a2.options) == null ? void 0 : _b.weekStartsOn) ?? defaultOptions2.weekStartsOn ?? ((_d = (_c = defaultOptions2.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.weekStartsOn) ?? 0;
  const date_ = toDate(date, options == null ? void 0 : options.in);
  const currentDay = date_.getDay();
  const remainder = day % 7;
  const dayIndex = (remainder + 7) % 7;
  const delta = 7 - weekStartsOn;
  const diff = day < 0 || day > 6 ? day - (currentDay + delta) % 7 : (dayIndex + delta) % 7 - (currentDay + delta) % 7;
  return addDays(date_, diff, options);
}

// node_modules/@strapi/plugin-seo/node_modules/date-fns/parse/_lib/parsers/DayParser.js
var DayParser = class extends Parser2 {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "E":
      case "EE":
      case "EEE":
        return match2.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
      case "EEEEE":
        return match2.day(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
      case "EEEE":
      default:
        return match2.day(dateString, { width: "wide", context: "formatting" }) || match2.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 6;
  }
  set(date, _flags, value, options) {
    date = setDay(date, value, options);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/parse/_lib/parsers/LocalDayParser.js
var LocalDayParser = class extends Parser2 {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "E",
      "i",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2, options) {
    const valueCallback = (value) => {
      const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
      return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
    };
    switch (token) {
      case "e":
      case "ee":
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
      case "eo":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "day"
          }),
          valueCallback
        );
      case "eee":
        return match2.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
      case "eeeee":
        return match2.day(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
      case "eeee":
      default:
        return match2.day(dateString, { width: "wide", context: "formatting" }) || match2.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 6;
  }
  set(date, _flags, value, options) {
    date = setDay(date, value, options);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/parse/_lib/parsers/StandAloneLocalDayParser.js
var StandAloneLocalDayParser = class extends Parser2 {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "E",
      "i",
      "e",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2, options) {
    const valueCallback = (value) => {
      const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
      return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
    };
    switch (token) {
      case "c":
      case "cc":
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
      case "co":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "day"
          }),
          valueCallback
        );
      case "ccc":
        return match2.day(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.day(dateString, { width: "short", context: "standalone" }) || match2.day(dateString, { width: "narrow", context: "standalone" });
      case "ccccc":
        return match2.day(dateString, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return match2.day(dateString, { width: "short", context: "standalone" }) || match2.day(dateString, { width: "narrow", context: "standalone" });
      case "cccc":
      default:
        return match2.day(dateString, { width: "wide", context: "standalone" }) || match2.day(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.day(dateString, { width: "short", context: "standalone" }) || match2.day(dateString, { width: "narrow", context: "standalone" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 6;
  }
  set(date, _flags, value, options) {
    date = setDay(date, value, options);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/setISODay.js
function setISODay(date, day, options) {
  const date_ = toDate(date, options == null ? void 0 : options.in);
  const currentDay = getISODay(date_, options);
  const diff = day - currentDay;
  return addDays(date_, diff, options);
}

// node_modules/@strapi/plugin-seo/node_modules/date-fns/parse/_lib/parsers/ISODayParser.js
var ISODayParser = class extends Parser2 {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "incompatibleTokens", [
      "y",
      "Y",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "E",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    const valueCallback = (value) => {
      if (value === 0) {
        return 7;
      }
      return value;
    };
    switch (token) {
      case "i":
      case "ii":
        return parseNDigits(token.length, dateString);
      case "io":
        return match2.ordinalNumber(dateString, { unit: "day" });
      case "iii":
        return mapValue(
          match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
      case "iiiii":
        return mapValue(
          match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
      case "iiiiii":
        return mapValue(
          match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
      case "iiii":
      default:
        return mapValue(
          match2.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 7;
  }
  set(date, _flags, value) {
    date = setISODay(date, value);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/parse/_lib/parsers/AMPMParser.js
var AMPMParser = class extends Parser2 {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 80);
    __publicField(this, "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "a":
      case "aa":
      case "aaa":
        return match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaaa":
        return match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return match2.dayPeriod(dateString, {
          width: "wide",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(date, _flags, value) {
    date.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
    return date;
  }
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/parse/_lib/parsers/AMPMMidnightParser.js
var AMPMMidnightParser = class extends Parser2 {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 80);
    __publicField(this, "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "b":
      case "bb":
      case "bbb":
        return match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbbb":
        return match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return match2.dayPeriod(dateString, {
          width: "wide",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(date, _flags, value) {
    date.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
    return date;
  }
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/parse/_lib/parsers/DayPeriodParser.js
var DayPeriodParser = class extends Parser2 {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 80);
    __publicField(this, "incompatibleTokens", ["a", "b", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBBB":
        return match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return match2.dayPeriod(dateString, {
          width: "wide",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(date, _flags, value) {
    date.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
    return date;
  }
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/parse/_lib/parsers/Hour1to12Parser.js
var Hour1to12Parser = class extends Parser2 {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 70);
    __publicField(this, "incompatibleTokens", ["H", "K", "k", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "h":
        return parseNumericPattern(numericPatterns.hour12h, dateString);
      case "ho":
        return match2.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 12;
  }
  set(date, _flags, value) {
    const isPM = date.getHours() >= 12;
    if (isPM && value < 12) {
      date.setHours(value + 12, 0, 0, 0);
    } else if (!isPM && value === 12) {
      date.setHours(0, 0, 0, 0);
    } else {
      date.setHours(value, 0, 0, 0);
    }
    return date;
  }
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/parse/_lib/parsers/Hour0to23Parser.js
var Hour0to23Parser = class extends Parser2 {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 70);
    __publicField(this, "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "H":
        return parseNumericPattern(numericPatterns.hour23h, dateString);
      case "Ho":
        return match2.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 23;
  }
  set(date, _flags, value) {
    date.setHours(value, 0, 0, 0);
    return date;
  }
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/parse/_lib/parsers/Hour0To11Parser.js
var Hour0To11Parser = class extends Parser2 {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 70);
    __publicField(this, "incompatibleTokens", ["h", "H", "k", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "K":
        return parseNumericPattern(numericPatterns.hour11h, dateString);
      case "Ko":
        return match2.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 11;
  }
  set(date, _flags, value) {
    const isPM = date.getHours() >= 12;
    if (isPM && value < 12) {
      date.setHours(value + 12, 0, 0, 0);
    } else {
      date.setHours(value, 0, 0, 0);
    }
    return date;
  }
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/parse/_lib/parsers/Hour1To24Parser.js
var Hour1To24Parser = class extends Parser2 {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 70);
    __publicField(this, "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "k":
        return parseNumericPattern(numericPatterns.hour24h, dateString);
      case "ko":
        return match2.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 24;
  }
  set(date, _flags, value) {
    const hours = value <= 24 ? value % 24 : value;
    date.setHours(hours, 0, 0, 0);
    return date;
  }
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/parse/_lib/parsers/MinuteParser.js
var MinuteParser = class extends Parser2 {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 60);
    __publicField(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "m":
        return parseNumericPattern(numericPatterns.minute, dateString);
      case "mo":
        return match2.ordinalNumber(dateString, { unit: "minute" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 59;
  }
  set(date, _flags, value) {
    date.setMinutes(value, 0, 0);
    return date;
  }
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/parse/_lib/parsers/SecondParser.js
var SecondParser = class extends Parser2 {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 50);
    __publicField(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "s":
        return parseNumericPattern(numericPatterns.second, dateString);
      case "so":
        return match2.ordinalNumber(dateString, { unit: "second" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 59;
  }
  set(date, _flags, value) {
    date.setSeconds(value, 0);
    return date;
  }
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/parse/_lib/parsers/FractionOfSecondParser.js
var FractionOfSecondParser = class extends Parser2 {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 30);
    __publicField(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(dateString, token) {
    const valueCallback = (value) => Math.trunc(value * Math.pow(10, -token.length + 3));
    return mapValue(parseNDigits(token.length, dateString), valueCallback);
  }
  set(date, _flags, value) {
    date.setMilliseconds(value);
    return date;
  }
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/parse/_lib/parsers/ISOTimezoneWithZParser.js
var ISOTimezoneWithZParser = class extends Parser2 {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 10);
    __publicField(this, "incompatibleTokens", ["t", "T", "x"]);
  }
  parse(dateString, token) {
    switch (token) {
      case "X":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalMinutes,
          dateString
        );
      case "XX":
        return parseTimezonePattern(timezonePatterns.basic, dateString);
      case "XXXX":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalSeconds,
          dateString
        );
      case "XXXXX":
        return parseTimezonePattern(
          timezonePatterns.extendedOptionalSeconds,
          dateString
        );
      case "XXX":
      default:
        return parseTimezonePattern(timezonePatterns.extended, dateString);
    }
  }
  set(date, flags, value) {
    if (flags.timestampIsSet) return date;
    return constructFrom(
      date,
      date.getTime() - getTimezoneOffsetInMilliseconds(date) - value
    );
  }
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/parse/_lib/parsers/ISOTimezoneParser.js
var ISOTimezoneParser = class extends Parser2 {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 10);
    __publicField(this, "incompatibleTokens", ["t", "T", "X"]);
  }
  parse(dateString, token) {
    switch (token) {
      case "x":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalMinutes,
          dateString
        );
      case "xx":
        return parseTimezonePattern(timezonePatterns.basic, dateString);
      case "xxxx":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalSeconds,
          dateString
        );
      case "xxxxx":
        return parseTimezonePattern(
          timezonePatterns.extendedOptionalSeconds,
          dateString
        );
      case "xxx":
      default:
        return parseTimezonePattern(timezonePatterns.extended, dateString);
    }
  }
  set(date, flags, value) {
    if (flags.timestampIsSet) return date;
    return constructFrom(
      date,
      date.getTime() - getTimezoneOffsetInMilliseconds(date) - value
    );
  }
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/parse/_lib/parsers/TimestampSecondsParser.js
var TimestampSecondsParser = class extends Parser2 {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 40);
    __publicField(this, "incompatibleTokens", "*");
  }
  parse(dateString) {
    return parseAnyDigitsSigned(dateString);
  }
  set(date, _flags, value) {
    return [constructFrom(date, value * 1e3), { timestampIsSet: true }];
  }
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/parse/_lib/parsers/TimestampMillisecondsParser.js
var TimestampMillisecondsParser = class extends Parser2 {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 20);
    __publicField(this, "incompatibleTokens", "*");
  }
  parse(dateString) {
    return parseAnyDigitsSigned(dateString);
  }
  set(date, _flags, value) {
    return [constructFrom(date, value), { timestampIsSet: true }];
  }
};

// node_modules/@strapi/plugin-seo/node_modules/date-fns/parse/_lib/parsers.js
var parsers = {
  G: new EraParser(),
  y: new YearParser(),
  Y: new LocalWeekYearParser(),
  R: new ISOWeekYearParser(),
  u: new ExtendedYearParser(),
  Q: new QuarterParser(),
  q: new StandAloneQuarterParser(),
  M: new MonthParser(),
  L: new StandAloneMonthParser(),
  w: new LocalWeekParser(),
  I: new ISOWeekParser(),
  d: new DateParser(),
  D: new DayOfYearParser(),
  E: new DayParser(),
  e: new LocalDayParser(),
  c: new StandAloneLocalDayParser(),
  i: new ISODayParser(),
  a: new AMPMParser(),
  b: new AMPMMidnightParser(),
  B: new DayPeriodParser(),
  h: new Hour1to12Parser(),
  H: new Hour0to23Parser(),
  K: new Hour0To11Parser(),
  k: new Hour1To24Parser(),
  m: new MinuteParser(),
  s: new SecondParser(),
  S: new FractionOfSecondParser(),
  X: new ISOTimezoneWithZParser(),
  x: new ISOTimezoneParser(),
  t: new TimestampSecondsParser(),
  T: new TimestampMillisecondsParser()
};

// node_modules/@strapi/plugin-seo/dist/_chunks/index-DoK7BakP.mjs
var import_isArray = __toESM(require_isArray(), 1);
var import_showdown = __toESM(require_showdown(), 1);
var import_last = __toESM(require_last(), 1);
var import_pull = __toESM(require_pull(), 1);
var __variableDynamicImportRuntimeHelper = (glob, path) => {
  const v = glob[path];
  if (v) {
    return typeof v === "function" ? v() : Promise.resolve(v);
  }
  return new Promise((_, reject) => {
    (typeof queueMicrotask === "function" ? queueMicrotask : setTimeout)(reject.bind(null, new Error("Unknown variable dynamic import: " + path)));
  });
};
var name$1 = "@strapi/plugin-seo";
var version = "2.0.7";
var description = "Make your Strapi content SEO friendly.";
var keywords = [];
var type = "commonjs";
var exports = {
  "./package.json": "./package.json",
  "./strapi-admin": {
    source: "./admin/src/index.js",
    "import": "./dist/admin/index.mjs",
    require: "./dist/admin/index.js",
    "default": "./dist/admin/index.js"
  },
  "./strapi-server": {
    source: "./server/src/index.js",
    "import": "./dist/server/index.mjs",
    require: "./dist/server/index.js",
    "default": "./dist/server/index.js"
  }
};
var files = [
  "dist"
];
var scripts = {
  build: "strapi-plugin build",
  verify: "strapi-plugin verify",
  watch: "strapi-plugin watch",
  "watch:link": "strapi-plugin watch:link"
};
var dependencies = {
  "@strapi/design-system": "^2.0.0-rc.10",
  "@strapi/icons": "^2.0.0-rc.10",
  "date-fns": "^4.1.0",
  lodash: "^4.17.21",
  prettier: "^3.3.3",
  react: "^18.0.0",
  "react-dom": "^18.0.0",
  "react-intl": "^6.6.8",
  "react-router-dom": "^6.0.0",
  showdown: "^2.1.0",
  "styled-components": "^6.0.0"
};
var devDependencies = {
  "@strapi/sdk-plugin": "5.2.6",
  "@strapi/strapi": "^5.0.6"
};
var peerDependencies = {
  "@strapi/strapi": "^5.0.6"
};
var repository = {
  type: "git",
  url: "https://github.com/strapi/strapi-plugin-seo.git"
};
var resolutions = {
  yargs: "^17.2.1",
  prettier: "3.3.3"
};
var author = {
  name: "Strapi Solutions SAS",
  email: "hi@strapi.io",
  url: "https://strapi.io"
};
var maintainers = [
  {
    name: "Strapi Solutions SAS",
    email: "hi@strapi.io",
    url: "https://strapi.io"
  }
];
var strapi = {
  name: "seo",
  displayName: "SEO",
  description: "Make your Strapi content SEO friendly.",
  kind: "plugin"
};
var pluginPkg = {
  name: name$1,
  version,
  description,
  keywords,
  type,
  exports,
  files,
  scripts,
  dependencies,
  devDependencies,
  peerDependencies,
  repository,
  resolutions,
  author,
  maintainers,
  strapi
};
var pluginId = pluginPkg.name.replace(/^@strapi\/plugin-/i, "");
var Initializer = ({ setPlugin }) => {
  const ref = React11.useRef(void 0);
  ref.current = setPlugin;
  React11.useEffect(() => {
    if (ref.current) {
      ref.current(pluginId);
    }
  }, []);
  return null;
};
function reducer(state, action) {
  var _a2, _b;
  switch (action.type) {
    case "UPDATE_PONCTUAL":
      return {
        ...state,
        [action.value.entity]: {
          qualityVerdict: (_a2 = action.value) == null ? void 0 : _a2.qualityVerdict,
          message: (_b = action.value) == null ? void 0 : _b.message
        }
      };
    case "UPDATE_FOR_PREVIEW":
      return action.value;
    default:
      throw new Error();
  }
}
var Illo = () => (0, import_jsx_runtime.jsxs)("svg", { width: "159", height: "88", viewBox: "0 0 159 88", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
  (0, import_jsx_runtime.jsx)(
    "path",
    {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M134.933 17.417C137.768 17.417 140.067 19.7153 140.067 22.5503C140.067 25.3854 137.768 27.6837 134.933 27.6837H105.6C108.435 27.6837 110.733 29.9819 110.733 32.817C110.733 35.6521 108.435 37.9503 105.6 37.9503H121.733C124.568 37.9503 126.867 40.2486 126.867 43.0837C126.867 45.9187 124.568 48.217 121.733 48.217H114.272C110.698 48.217 107.8 50.5153 107.8 53.3503C107.8 55.2404 109.267 56.9515 112.2 58.4837C115.035 58.4837 117.333 60.7819 117.333 63.617C117.333 66.4521 115.035 68.7503 112.2 68.7503H51.3333C48.4982 68.7503 46.2 66.4521 46.2 63.617C46.2 60.7819 48.4982 58.4837 51.3333 58.4837H22.7333C19.8982 58.4837 17.6 56.1854 17.6 53.3503C17.6 50.5153 19.8982 48.217 22.7333 48.217H52.0666C54.9017 48.217 57.2 45.9187 57.2 43.0837C57.2 40.2486 54.9017 37.9503 52.0666 37.9503H33.7333C30.8982 37.9503 28.6 35.6521 28.6 32.817C28.6 29.9819 30.8982 27.6837 33.7333 27.6837H63.0666C60.2316 27.6837 57.9333 25.3854 57.9333 22.5503C57.9333 19.7153 60.2316 17.417 63.0666 17.417H134.933ZM134.933 37.9503C137.768 37.9503 140.067 40.2486 140.067 43.0837C140.067 45.9187 137.768 48.217 134.933 48.217C132.098 48.217 129.8 45.9187 129.8 43.0837C129.8 40.2486 132.098 37.9503 134.933 37.9503Z",
      fill: "#DBDBFA"
    }
  ),
  (0, import_jsx_runtime.jsx)(
    "path",
    {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M95.826 16.6834L102.647 66.4348L103.26 71.4261C103.458 73.034 102.314 74.4976 100.706 74.695L57.7621 79.9679C56.1542 80.1653 54.6906 79.0219 54.4932 77.4139L47.8816 23.5671C47.7829 22.7631 48.3546 22.0313 49.1586 21.9326C49.1637 21.932 49.1688 21.9313 49.1739 21.9307L52.7367 21.5311L95.826 16.6834ZM55.6176 21.208L58.9814 20.8306Z",
      fill: "white"
    }
  ),
  (0, import_jsx_runtime.jsx)(
    "path",
    {
      d: "M55.6176 21.208L58.9814 20.8306M95.826 16.6834L102.647 66.4348L103.26 71.4261C103.458 73.034 102.314 74.4976 100.706 74.695L57.7621 79.9679C56.1542 80.1653 54.6906 79.0219 54.4932 77.4139L47.8816 23.5671C47.7829 22.7631 48.3546 22.0313 49.1586 21.9326C49.1637 21.932 49.1688 21.9313 49.1739 21.9307L52.7367 21.5311L95.826 16.6834Z",
      stroke: "#7E7BF6",
      strokeWidth: "2.5"
    }
  ),
  (0, import_jsx_runtime.jsx)(
    "path",
    {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M93.9695 19.8144L100.144 64.9025L100.699 69.4258C100.878 70.8831 99.8559 72.2077 98.416 72.3845L59.9585 77.1065C58.5185 77.2833 57.2062 76.2453 57.0272 74.7881L51.0506 26.112C50.9519 25.308 51.5236 24.5762 52.3276 24.4775L57.0851 23.8934",
      fill: "#F0F0FF"
    }
  ),
  (0, import_jsx_runtime.jsx)(
    "path",
    {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M97.701 7.33301H64.2927C63.7358 7.33301 63.2316 7.55873 62.8667 7.92368C62.5017 8.28862 62.276 8.79279 62.276 9.34967V65.083C62.276 65.6399 62.5017 66.1441 62.8667 66.509C63.2316 66.874 63.7358 67.0997 64.2927 67.0997H107.559C108.116 67.0997 108.62 66.874 108.985 66.509C109.35 66.1441 109.576 65.6399 109.576 65.083V19.202C109.576 18.6669 109.363 18.1537 108.985 17.7755L99.1265 7.92324C98.7484 7.54531 98.2356 7.33301 97.701 7.33301Z",
      fill: "white",
      stroke: "#7F7CFA",
      strokeWidth: "2.5"
    }
  ),
  (0, import_jsx_runtime.jsx)(
    "path",
    {
      d: "M98.026 8.17871V16.6833C98.026 17.8983 99.011 18.8833 100.226 18.8833H106.044",
      stroke: "#807EFA",
      strokeWidth: "2.5",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }
  ),
  (0, import_jsx_runtime.jsx)(
    "path",
    {
      d: "M70.1594 56.2838H89.2261M70.1594 18.8838H89.2261H70.1594ZM70.1594 27.6838H101.693H70.1594ZM70.1594 37.2171H101.693H70.1594ZM70.1594 46.7505H101.693H70.1594Z",
      stroke: "#817FFA",
      strokeWidth: "2.5",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }
  )
] });
var qualityVerdict = {
  good: "good",
  improvements: "improvements",
  bad: "bad"
};
var getMetaTitleCheckPreview = (modifiedData) => {
  const metaTitle = (0, import_get.default)(modifiedData, "seo.metaTitle");
  let status = {
    message: "",
    qualityVerdict: qualityVerdict.good
  };
  if ((0, import_isNull.default)(metaTitle) || (0, import_isEmpty.default)(metaTitle)) {
    status = {
      message: "",
      qualityVerdict: qualityVerdict.improvements
    };
  } else if (metaTitle.length > 60) {
    status = {
      message: "",
      qualityVerdict: qualityVerdict.bad
    };
  }
  return status;
};
var getMetaDescriptionPreview = (modifiedData) => {
  const metaDescription = (0, import_get.default)(modifiedData, "seo.metaDescription");
  let status = {
    message: "",
    qualityVerdict: qualityVerdict.good
  };
  if ((0, import_isNull.default)(metaDescription) || (0, import_isEmpty.default)(metaDescription)) {
    status = {
      message: "",
      qualityVerdict: qualityVerdict.improvements
    };
  } else if (metaDescription.length > 160) {
    status = {
      message: "",
      qualityVerdict: qualityVerdict.bad
    };
  } else if (metaDescription.length < 50) {
    status = {
      message: "",
      qualityVerdict: qualityVerdict.bad
    };
  }
  return status;
};
var getAlternativeTextPreview = (emptyAltCount) => {
  const intersections = (0, import_get.default)(emptyAltCount, "intersections", null);
  const richTextAlts = (0, import_get.default)(emptyAltCount, "richTextAlts", null);
  const altTexts = (0, import_get.default)(emptyAltCount, "altTexts", null);
  let status = {
    message: "",
    qualityVerdict: qualityVerdict.good
  };
  const missingRichTextAlt = richTextAlts.filter((x) => x.occurences != 0).length;
  if (intersections === 0) {
    status = {
      message: "",
      qualityVerdict: qualityVerdict.bad
    };
  } else if (altTexts.includes("")) {
    status = {
      message: "",
      qualityVerdict: qualityVerdict.improvements
    };
  } else if (missingRichTextAlt >= 1) {
    status = {
      message: "",
      qualityVerdict: qualityVerdict.improvements
    };
  }
  return status;
};
var getWordCountPreview = (wordCount) => {
  let status = {
    message: "",
    qualityVerdict: qualityVerdict.good
  };
  if ((0, import_isNull.default)(wordCount)) {
    status = {
      message: "",
      qualityVerdict: qualityVerdict.improvements
    };
    return;
  } else if (wordCount < 300) {
    status = {
      message: "",
      qualityVerdict: qualityVerdict.improvements
    };
  }
  return status;
};
var getKeywordDensityPreview = (keywordsDensity) => {
  let status = {
    message: "",
    qualityVerdict: qualityVerdict.good
  };
  if ((0, import_isEmpty.default)(keywordsDensity)) {
    status = {
      message: "",
      qualityVerdict: qualityVerdict.improvements
    };
    return status;
  }
  Object.keys(keywordsDensity).map((keyword) => {
    if ((0, import_get.default)(keywordsDensity[keyword], "count", 0) === 0) {
      status = {
        message: "",
        qualityVerdict: qualityVerdict.improvements
      };
    } else if ((0, import_get.default)(keywordsDensity[keyword], "count", 0) <= 1) {
      status = {
        message: "",
        qualityVerdict: qualityVerdict.bad
      };
    }
  });
  return status;
};
var canonicalUrlPreview = (modifiedData) => {
  const canonicalUrl = (0, import_get.default)(modifiedData, "seo.canonicalURL");
  let status = {
    message: "",
    qualityVerdict: qualityVerdict.good
  };
  if ((0, import_isNull.default)(canonicalUrl)) {
    status = {
      message: "",
      qualityVerdict: qualityVerdict.bad
    };
  }
  return status;
};
var lastUpdatedAtPreview = (modifiedData) => {
  const updatedAt = (0, import_get.default)(modifiedData, "updatedAt");
  let status = {
    message: "",
    qualityVerdict: qualityVerdict.improvements
  };
  if ((0, import_isNull.default)(updatedAt)) {
    status = {
      message: "",
      qualityVerdict: qualityVerdict.bad
    };
  } else {
    const oneYearAgo = Date.parse(new Date((/* @__PURE__ */ new Date()).setFullYear((/* @__PURE__ */ new Date()).getFullYear() - 1)));
    if (Date.parse(updatedAt) >= oneYearAgo) {
      status = {
        message: "",
        qualityVerdict: qualityVerdict.good
      };
    }
  }
  return status;
};
var metaRobotPreview = (modifiedData) => {
  const metaRobots = (0, import_get.default)(modifiedData, "seo.metaRobots");
  let status = {
    message: "",
    qualityVerdict: qualityVerdict.good
  };
  if ((0, import_isNull.default)(metaRobots) || (0, import_isEmpty.default)(metaRobots)) {
    status = {
      message: "",
      qualityVerdict: qualityVerdict.good
    };
  }
  return status;
};
var openGraphPreview = (modifiedData) => {
  const openGraph = (0, import_get.default)(modifiedData, "seo.openGraph");
  let status = {
    message: "",
    qualityVerdict: qualityVerdict.good
  };
  if ((0, import_isNull.default)(openGraph) || openGraph === void 0) {
    status = {
      message: "",
      qualityVerdict: qualityVerdict.bad
    };
    return status;
  } else if (!openGraph["ogTitle"] || !openGraph["ogDescription"] || !openGraph["ogImage"]) {
    status = {
      message: "",
      qualityVerdict: qualityVerdict.improvements
    };
  }
  return status;
};
var structuredDataPreview = (modifiedData) => {
  const structuredData = (0, import_get.default)(modifiedData, "seo.structuredData");
  let status = {
    message: "",
    qualityVerdict: qualityVerdict.good
  };
  if ((0, import_isEmpty.default)(structuredData)) {
    status = {
      message: "",
      qualityVerdict: qualityVerdict.bad
    };
  }
  return status;
};
var SEOAccordion = ({ title, status, component, label }) => {
  const getIcon = () => {
    switch (status == null ? void 0 : status.qualityVerdict) {
      case qualityVerdict.good:
        return ForwardRef$4L;
      case qualityVerdict.improvements:
        return ForwardRef$5;
      case qualityVerdict.bad:
        return ForwardRef$4b;
      default:
        return ForwardRef$5;
    }
  };
  return (0, import_jsx_runtime.jsx)(Accordion.Root, { children: (0, import_jsx_runtime.jsxs)(Accordion.Item, { value: "acc-01", children: [
    (0, import_jsx_runtime.jsxs)(Accordion.Header, { children: [
      (0, import_jsx_runtime.jsx)(Accordion.Trigger, { icon: getIcon(), children: title }),
      (0, import_jsx_runtime.jsx)(Accordion.Actions, { children: (0, import_jsx_runtime.jsx)(IconButton, { label, children: (0, import_jsx_runtime.jsx)(ForwardRef$2H, {}) }) })
    ] }),
    (0, import_jsx_runtime.jsxs)(Accordion.Content, { children: [
      (0, import_jsx_runtime.jsx)(Box, { paddingTop: 4, paddingLeft: 4, paddingBottom: 4, children: (0, import_jsx_runtime.jsx)(Typography, { variant: "omega", children: status == null ? void 0 : status.message }) }),
      component && component
    ] })
  ] }) });
};
var getTrad = (id) => `${pluginId}.${id}`;
var robotTags = [
  { name: "noindex", message: "Search engines will index this page." },
  {
    name: "nofollow",
    message: "Search engines will follow links from this page"
  },
  { name: "noarchive", message: "Search engines will cache your page." },
  {
    name: "nosnippet",
    message: "Search engines will show a snippet of this page in search results."
  },
  {
    name: "noimageindex",
    message: "Google will index the images on this page."
  },
  {
    name: "nositelinkssearchbox",
    message: "Google will show the search box in search results."
  }
];
var MetaRobotCheck = ({ metaRobots, checks }) => {
  const { formatMessage: formatMessage3 } = useIntl();
  const dispatch = React11.useContext(SeoCheckerContext);
  let status = {
    message: formatMessage3({
      id: getTrad("SEOChecks.metaRobotsCheck.default"),
      defaultMessage: "Robot meta tags have been found!"
    }),
    qualityVerdict: qualityVerdict.good
  };
  const [tags, setTags] = React11.useState([]);
  React11.useEffect(() => {
    if ((0, import_isNull.default)(metaRobots) || (0, import_isEmpty.default)(metaRobots)) {
      status = {
        message: formatMessage3({
          id: getTrad("SEOChecks.metaRobotsCheck.not-found"),
          defaultMessage: "No Robot meta tags have been found."
        }),
        qualityVerdict: qualityVerdict.good
      };
    } else {
      setTags(metaRobots.split(","));
    }
    if (!(0, import_isEqual.default)(status, checks.metaRobots))
      dispatch({
        type: "UPDATE_PONCTUAL",
        value: { ...status, entity: "metaRobots" }
      });
  }, []);
  return (0, import_jsx_runtime.jsx)(
    SEOAccordion,
    {
      title: formatMessage3({
        id: getTrad("SEOModal.summary-title.meta-robots"),
        defaultMessage: "Meta Robots"
      }),
      status: checks.metaRobots,
      label: formatMessage3({
        id: getTrad("SEOChecks.metaRobotsCheck.label"),
        defaultMessage: "The robots meta tag informs search engines which pages on your site should be indexed and more."
      }),
      component: (0, import_jsx_runtime.jsxs)(Box, { padding: 2, background: "neutral100", children: [
        robotTags.map((tag, index2) => (0, import_jsx_runtime.jsxs)(Flex, { spacing: 2, horizontal: true, padding: 2, children: [
          tags.find((x) => x.trim() === tag.name) ? (0, import_jsx_runtime.jsx)(ForwardRef$4L, { "aria-hidden": true, fill: `success600` }) : (0, import_jsx_runtime.jsx)(ForwardRef$5, { "aria-hidden": true, fill: `warning600` }),
          (0, import_jsx_runtime.jsx)(Typography, { paddingLeft: 1, children: tags.find((x) => x.trim() === tag.name) ? `${tag.name} is activated:
          ${tag.message.replace("will", "will not")}` : `${tag.name} is disabled: ${tag.message}` })
        ] }, index2)),
        (0, import_jsx_runtime.jsx)(Flex, { spacing: 2, paddingTop: 4, paddingLeft: 2, paddingRight: 2, paddingBottom: 4, children: (0, import_jsx_runtime.jsx)(Status, { variant: "secondary", showBullet: false, children: (0, import_jsx_runtime.jsxs)(Typography, { children: [
          (0, import_jsx_runtime.jsx)(Typography, { fontWeight: "bold", children: "Notice: " }),
          "In order to not index your entry and no follow, your MetaRobots field should contain the following:",
          (0, import_jsx_runtime.jsx)(Typography, { fontWeight: "bold", children: " noindex, nofollow " }),
          '. The rest should be handled by your front-end code logic. "If the field contains noindex, then you need to create the corresponding meta tag etc..."'
        ] }) }) })
      ] })
    }
  );
};
var WordCountCheck = ({ wordCount, checks }) => {
  const { formatMessage: formatMessage3 } = useIntl();
  const dispatch = React11.useContext(SeoCheckerContext);
  let status = {
    message: formatMessage3({
      id: getTrad("SEOChecks.wordCountCheck.default"),
      defaultMessage: "You have more than 300 words. The word counter is not a direct ranking factor. But your content should be as high quality as possible, with relevant and unique information. To meet these conditions, your content requires a minimum of paragraphs, and therefore of words."
    }),
    qualityVerdict: qualityVerdict.good
  };
  React11.useEffect(() => {
    if ((0, import_isNull.default)(wordCount)) {
      status = {
        message: formatMessage3({
          id: getTrad("SEOChecks.wordCountCheck.not-found"),
          defaultMessage: "No Richtext content have been found."
        }),
        qualityVerdict: qualityVerdict.improvements
      };
      return;
    } else if (wordCount < 300) {
      status = {
        message: formatMessage3({
          id: getTrad("SEOChecks.wordCountCheck.300"),
          defaultMessage: "Your 1st level Richtext contents have less than 300 words."
        }),
        qualityVerdict: qualityVerdict.improvements
      };
    }
    if (!(0, import_isEqual.default)(status, checks.wordCount))
      dispatch({
        type: "UPDATE_PONCTUAL",
        value: { ...status, entity: "wordCount" }
      });
  }, []);
  return (0, import_jsx_runtime.jsx)(
    SEOAccordion,
    {
      title: formatMessage3({
        id: getTrad("SEOModal.summary-title.word-counter"),
        defaultMessage: "Word Counter"
      }),
      status: checks.wordCount,
      label: formatMessage3({
        id: getTrad("SEOChecks.wordCountCheck.label"),
        defaultMessage: "Your content should be as high quality as possible, with relevant and unique information. You entry requires a minimum of paragraphs, and therefore of words."
      }),
      component: (0, import_isNumber.default)(wordCount) && (0, import_jsx_runtime.jsx)(Box, { padding: 4, background: "neutral100", children: (0, import_jsx_runtime.jsxs)(Typography, { variant: "omega", fontWeight: "bold", children: [
        formatMessage3({
          id: getTrad("SEOChecks.wordCountCheck.words"),
          defaultMessage: "Words:"
        }),
        " ",
        wordCount
      ] }) })
    }
  );
};
var MetaTitleCheck = ({ metaTitle, checks }) => {
  const { formatMessage: formatMessage3 } = useIntl();
  const dispatch = React11.useContext(SeoCheckerContext);
  const maxLength = 60;
  let status = {
    message: formatMessage3({
      id: getTrad("SEOChecks.metaTitleCheck.default"),
      defaultMessage: "A Meta Title has been found!"
    }),
    qualityVerdict: qualityVerdict.good
  };
  React11.useEffect(() => {
    if ((0, import_isNull.default)(metaTitle) || (0, import_isEmpty.default)(metaTitle)) {
      status = {
        message: formatMessage3({
          id: getTrad("SEOChecks.metaTitleCheck.not-found"),
          defaultMessage: "No Meta Title has been found."
        }),
        qualityVerdict: qualityVerdict.improvements
      };
    } else if (metaTitle.length > maxLength) {
      status = {
        message: formatMessage3({
          id: getTrad("Title-settings.metaTitle-too-long"),
          defaultMessage: "Meta Title is too long"
        }),
        qualityVerdict: qualityVerdict.bad
      };
    }
    if (!(0, import_isEqual.default)(status, checks.metaTitle))
      dispatch({
        type: "UPDATE_PONCTUAL",
        value: { ...status, entity: "metaTitle" }
      });
  }, []);
  return (0, import_jsx_runtime.jsx)(
    SEOAccordion,
    {
      title: formatMessage3({
        id: getTrad("SEOModal.summary-title.meta-title"),
        defaultMessage: "Meta title"
      }),
      status: checks.metaTitle,
      label: formatMessage3({
        id: getTrad("Title-settings.metaTitle-tooltip"),
        defaultMessage: "The title tag is the clickable title of a webpage that appears with the result on the SERP (search engine page results page).\n You should aim to make your SEO titles around 60 characters long. Clear title tags will go a long way towards making your website easy to read and understand."
      }),
      component: metaTitle && (0, import_jsx_runtime.jsxs)(Box, { padding: 4, background: "neutral100", children: [
        (0, import_jsx_runtime.jsx)(Typography, { variant: "omega", fontWeight: "semiBold", children: metaTitle }),
        (0, import_jsx_runtime.jsx)(Box, { paddingTop: 2, children: (0, import_jsx_runtime.jsxs)(Flex, { horizontal: true, spacing: 2, children: [
          (0, import_jsx_runtime.jsx)(
            ProgressBar,
            {
              size: "M",
              value: metaTitle.length * 100 / maxLength > 100 ? 100 : metaTitle.length * 100 / maxLength
            }
          ),
          (0, import_jsx_runtime.jsxs)(Typography, { variant: "pi", padding: 2, children: [
            "(",
            metaTitle.length,
            "/",
            maxLength,
            ")"
          ] })
        ] }) })
      ] })
    }
  );
};
var OpenGraphCheck = ({ openGraph, checks }) => {
  const { formatMessage: formatMessage3 } = useIntl();
  const dispatch = React11.useContext(SeoCheckerContext);
  let status = {
    message: "",
    qualityVerdict: qualityVerdict.good
  };
  React11.useEffect(() => {
    if ((0, import_isNull.default)(openGraph) || openGraph === void 0) {
      status = {
        message: formatMessage3({
          id: getTrad("SEOChecks.openGraphCheck.not-found"),
          defaultMessage: "No OpenGraph tags have been found."
        }),
        qualityVerdict: qualityVerdict.bad
      };
    } else if (!openGraph["ogTitle"] || !openGraph["ogDescription"] || !openGraph["ogImage"]) {
      status = {
        message: formatMessage3({
          id: getTrad("SEOChecks.openGraphCheck.not-configured"),
          defaultMessage: "OpenGraph minimum required tags are not configured."
        }),
        qualityVerdict: qualityVerdict.improvements
      };
    } else {
      status = {
        message: `${formatMessage3({
          id: getTrad("SEOChecks.openGraphCheck.configured"),
          defaultMessage: "OpenGraph tags are configured"
        })}`,
        qualityVerdict: qualityVerdict.good
      };
    }
    if (!(0, import_isEqual.default)(status, checks.openGraph))
      dispatch({
        type: "UPDATE_PONCTUAL",
        value: { ...status, entity: "openGraph" }
      });
  }, []);
  return (0, import_jsx_runtime.jsx)(
    SEOAccordion,
    {
      title: formatMessage3({
        id: getTrad("SEOModal.summary-title.meta-social"),
        defaultMessage: "OpenGraph Tags"
      }),
      status: checks.openGraph,
      label: formatMessage3({
        id: getTrad("SEOChecks.openGraphCheck.label"),
        defaultMessage: "OpenGraph tags allow you to manage the title, description & image of your posts."
      })
    }
  );
};
var CanonicalUrlCheck = ({ canonicalUrl, checks }) => {
  const { formatMessage: formatMessage3 } = useIntl();
  const dispatch = React11.useContext(SeoCheckerContext);
  let status = {
    message: formatMessage3({
      id: getTrad("SEOChecks.canonicalUrlCheck.found"),
      defaultMessage: "A canonical URL has been found."
    }),
    qualityVerdict: qualityVerdict.good
  };
  React11.useEffect(() => {
    if ((0, import_isNull.default)(canonicalUrl)) {
      status = {
        message: formatMessage3({
          id: getTrad("SEOChecks.canonicalUrlCheck.default"),
          defaultMessage: "No Canonical URL has been found."
        }),
        qualityVerdict: qualityVerdict.bad
      };
    }
    if (!(0, import_isEqual.default)(status, checks.canonicalUrl))
      dispatch({
        type: "UPDATE_PONCTUAL",
        value: { ...status, entity: "canonicalUrl" }
      });
  }, []);
  return (0, import_jsx_runtime.jsx)(
    SEOAccordion,
    {
      title: formatMessage3({
        id: getTrad("SEOModal.summary-title.canonical-url"),
        defaultMessage: "Canonical URL"
      }),
      status: checks.canonicalUrl,
      label: formatMessage3({
        id: getTrad("SEOChecks.canonicalUrlCheck.label"),
        defaultMessage: "This will check if you have a canonical URL."
      }),
      component: (0, import_jsx_runtime.jsx)(Box, { padding: canonicalUrl ? 4 : 0, background: "neutral100", children: canonicalUrl && (0, import_jsx_runtime.jsx)(Typography, { variant: "omega", fontWeight: "bold", children: canonicalUrl }) })
    }
  );
};
var LastUpdatedAtCheck = ({ updatedAt, checks }) => {
  const { formatMessage: formatMessage3 } = useIntl();
  const dispatch = React11.useContext(SeoCheckerContext);
  let status = {
    message: formatMessage3({
      id: getTrad("SSEOChecks.lastUpdatedAtCheck.default"),
      defaultMessage: "This content was modified over a year ago! Search engines love fresh content."
    }),
    qualityVerdict: qualityVerdict.improvements
  };
  React11.useEffect(() => {
    if ((0, import_isNull.default)(updatedAt)) {
      status = {
        message: formatMessage3({
          id: getTrad("SEOChecks.lastUpdatedAtCheck.save-content"),
          defaultMessage: "You must save this entry first."
        }),
        qualityVerdict: qualityVerdict.bad
      };
    } else {
      const oneYearAgo = Date.parse(new Date((/* @__PURE__ */ new Date()).setFullYear((/* @__PURE__ */ new Date()).getFullYear() - 1)));
      if (Date.parse(updatedAt) >= oneYearAgo) {
        status = {
          message: formatMessage3({
            id: getTrad("SEOChecks.lastUpdatedAtCheck.success"),
            defaultMessage: "Awesome! This content was last modified in less than an year ago!"
          }),
          qualityVerdict: qualityVerdict.good
        };
      }
    }
    if (!(0, import_isEqual.default)(status, checks.lastUpdatedAt))
      dispatch({
        type: "UPDATE_PONCTUAL",
        value: { ...status, entity: "lastUpdatedAt" }
      });
  }, []);
  return (0, import_jsx_runtime.jsx)(
    SEOAccordion,
    {
      title: formatMessage3({
        id: getTrad("SEOModal.summary-title.last-updated-at"),
        defaultMessage: "Last updated at"
      }),
      label: formatMessage3({
        id: getTrad("SEOChecks.lastUpdatedAtCheck.label"),
        defaultMessage: "Search engines love fresh content. This will check if your entry was last modified in less than an year ago."
      }),
      status: checks.lastUpdatedAt,
      component: updatedAt && (0, import_jsx_runtime.jsx)(Box, { padding: 4, background: "neutral100", children: (0, import_jsx_runtime.jsxs)(Typography, { variant: "omega", children: [
        formatMessage3({
          id: getTrad('SEOChecks.lastUpdatedAtCheck.last"'),
          defaultMessage: "Last updated at:"
        }),
        " ",
        (0, import_jsx_runtime.jsxs)(Typography, { variant: "omega", fontWeight: "bold", children: [
          " ",
          formatDistance2(new Date(updatedAt), /* @__PURE__ */ new Date(), {
            addSuffix: true
          })
        ] })
      ] }) })
    }
  );
};
var KeywordDensityCheck = ({ keywordsDensity, checks }) => {
  const { formatMessage: formatMessage3 } = useIntl();
  const dispatch = React11.useContext(SeoCheckerContext);
  let status = {
    message: formatMessage3({
      id: getTrad("SEOChecks.keywordsDensityCheck.default"),
      defaultMessage: "Every keywords are used more than 2 times."
    }),
    qualityVerdict: qualityVerdict.good
  };
  React11.useEffect(() => {
    if ((0, import_isEmpty.default)(keywordsDensity)) {
      status = {
        message: formatMessage3({
          id: getTrad("SEOChecks.keywordsDensityCheck.no-keywords"),
          defaultMessage: "No keywords were found in your SEO component."
        }),
        qualityVerdict: qualityVerdict.improvements
      };
    } else {
      Object.keys(keywordsDensity).map((keyword) => {
        if ((0, import_get.default)(keywordsDensity[keyword], "count", 0) === 0) {
          status = {
            message: formatMessage3({
              id: getTrad("SEOChecks.keywordsDensityCheck.one-not-used"),
              defaultMessage: "One keyword is not being used in your content."
            }),
            qualityVerdict: qualityVerdict.improvements
          };
        } else if ((0, import_get.default)(keywordsDensity[keyword], "count", 0) <= 1) {
          status = {
            message: formatMessage3({
              id: getTrad("SEOChecks.keywordsDensityCheck.one-used-once"),
              defaultMessage: "One keyword is only used once in your content."
            }),
            qualityVerdict: qualityVerdict.bad
          };
        }
      });
    }
    if (!(0, import_isEqual.default)(status, checks.keywordsDensity))
      dispatch({
        type: "UPDATE_PONCTUAL",
        value: { ...status, entity: "keywordsDensity" }
      });
  }, []);
  return (0, import_jsx_runtime.jsx)(
    SEOAccordion,
    {
      title: formatMessage3({
        id: getTrad("SEOModal.summary-title.word-densisty"),
        defaultMessage: "Keyword Density"
      }),
      status: checks.keywordsDensity,
      label: formatMessage3({
        id: getTrad("SEOChecks.keywordsDensityCheck.label"),
        defaultMessage: "Define keywords you want to rank for in your SEO component. This will analyse the density of your keywords in your 1st level richtext editors."
      }),
      component: keywordsDensity && !(0, import_isEmpty.default)(keywordsDensity) && (0, import_jsx_runtime.jsx)(Box, { padding: 2, background: "neutral100", children: (0, import_jsx_runtime.jsx)(Flex, { wrap: "wrap", children: Object.keys(keywordsDensity).map((keyword) => (0, import_jsx_runtime.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime.jsx)(Badge, { children: `${keyword}:
                      ${(0, import_get.default)(keywordsDensity[keyword], "count", 0).toString()}` }) }, keyword)) }) })
    }
  );
};
var StructuredDataCheck = ({ structuredData, checks }) => {
  const { formatMessage: formatMessage3 } = useIntl();
  const dispatch = React11.useContext(SeoCheckerContext);
  let status = {
    message: formatMessage3({
      id: getTrad("SEOChecks.structuredDataCheck.default"),
      defaultMessage: "A Structured Data json has been found! However we can validate the accuracy of its content."
    }),
    qualityVerdict: qualityVerdict.good
  };
  React11.useEffect(() => {
    if ((0, import_isEmpty.default)(structuredData)) {
      status = {
        message: formatMessage3({
          id: getTrad("SEOChecks.structuredDataCheck.not-found"),
          defaultMessage: "No Structured Data json has been found."
        }),
        qualityVerdict: qualityVerdict.bad
      };
    }
    if (!(0, import_isEqual.default)(status, checks.structuredData))
      dispatch({
        type: "UPDATE_PONCTUAL",
        value: { ...status, entity: "structuredData" }
      });
  }, []);
  return (0, import_jsx_runtime.jsx)(
    SEOAccordion,
    {
      title: formatMessage3({
        id: getTrad("SEOModal.summary-title.structured-data"),
        defaultMessage: "JSON Structured Data"
      }),
      status: checks.structuredData,
      label: formatMessage3({
        id: getTrad("SEOChecks.structuredDataCheck.label"),
        defaultMessage: "Structured data is a standardized format for providing information about a page and classifying the page content."
      })
    }
  );
};
var MetaDescriptionCheck = ({ metaDescription, checks }) => {
  const { formatMessage: formatMessage3 } = useIntl();
  const dispatch = React11.useContext(SeoCheckerContext);
  const maxLength = 160;
  const minimumLength = 50;
  let status = {
    message: formatMessage3({
      id: getTrad("SEOChecks.metaDescriptionCheck.default"),
      defaultMessage: "A Meta Description has been found!"
    }),
    qualityVerdict: qualityVerdict.good
  };
  React11.useEffect(() => {
    if ((0, import_isNull.default)(metaDescription) || (0, import_isEmpty.default)(metaDescription)) {
      status = {
        message: formatMessage3({
          id: getTrad("SEOChecks.metaDescriptionCheck.not-found"),
          defaultMessage: "No Meta Description has been found."
        }),
        qualityVerdict: qualityVerdict.improvements
      };
    } else if (metaDescription.length > maxLength) {
      status = {
        message: formatMessage3({
          id: getTrad("Title-settings.metaDescription-too-long"),
          defaultMessage: "Meta Description is too long"
        }),
        qualityVerdict: qualityVerdict.bad
      };
    } else if (metaDescription.length < minimumLength) {
      status = {
        message: formatMessage3({
          id: getTrad("Title-settings.metaDescription-too-short"),
          defaultMessage: "Meta Description is too short"
        }),
        qualityVerdict: qualityVerdict.bad
      };
    }
    if (!(0, import_isEqual.default)(status, checks.metaDescription))
      dispatch({
        type: "UPDATE_PONCTUAL",
        value: { ...status, entity: "metaDescription" }
      });
  }, []);
  return (0, import_jsx_runtime.jsx)(
    SEOAccordion,
    {
      title: formatMessage3({
        id: getTrad("SEOModal.summary-title.meta-description"),
        defaultMessage: "Meta description"
      }),
      status: checks.metaDescription,
      label: formatMessage3({
        id: getTrad("Title-settings.metaDescription-tooltip"),
        defaultMessage: `A meta description is an HTML tag used to describe the content of a web page.
 This description appears below the title and URL of your page as it appears in search engine results.
 For it to remain visible in Google, it must not exceed 140-${maxLength} characters.`
      }),
      component: metaDescription && (0, import_jsx_runtime.jsxs)(Box, { padding: 4, background: "neutral100", children: [
        (0, import_jsx_runtime.jsx)(Typography, { variant: "omega", fontWeight: "semiBold", children: metaDescription }),
        (0, import_jsx_runtime.jsx)(Box, { paddingTop: 2, children: (0, import_jsx_runtime.jsxs)(Flex, { horizontal: true, spacing: 2, children: [
          (0, import_jsx_runtime.jsx)(
            ProgressBar,
            {
              value: metaDescription.length * 100 / maxLength > 100 ? 100 : metaDescription.length * 100 / maxLength
            }
          ),
          (0, import_jsx_runtime.jsxs)(Typography, { variant: "pi", padding: 2, children: [
            "(",
            metaDescription.length,
            "/",
            maxLength,
            ")"
          ] })
        ] }) })
      ] })
    }
  );
};
var AlternativeTextCheck = ({ intersections, richTextAlts, altTexts, checks }) => {
  const { formatMessage: formatMessage3 } = useIntl();
  const dispatch = React11.useContext(SeoCheckerContext);
  let status = {
    message: formatMessage3({
      id: getTrad("SEOChecks.alternativeTextCheck.default"),
      defaultMessage: "All your images contain an alt attribute! Congrats!"
    }),
    qualityVerdict: qualityVerdict.good
  };
  React11.useEffect(() => {
    const missingRichTextAlt = richTextAlts.filter((x) => x.occurences != 0).length;
    if (intersections === 0) {
      status = {
        message: formatMessage3({
          id: getTrad("SEOChecks.alternativeTextCheck.intersection-zero"),
          defaultMessage: "The name and the alternative text of your images are all the same. Strapi automatically generate the alt attribute from the name by default if the field was empty during the media upload. Having alt attribute clearly describing images is a very good practice."
        }),
        qualityVerdict: qualityVerdict.bad
      };
    } else if (altTexts.includes("")) {
      const count = Math.abs(intersections);
      status = {
        message: `${count} ${formatMessage3({
          id: getTrad("SEOChecks.alternativeTextCheck.intersection-negative"),
          defaultMessage: "Some images from a media field are missing an alt attribute."
        })}`,
        qualityVerdict: qualityVerdict.improvements
      };
    } else if (missingRichTextAlt >= 1) {
      status = {
        message: formatMessage3({
          id: getTrad("SEOChecks.alternativeTextCheck.richtext-missing-one"),
          defaultMessage: "At least one image in any 1st level richtext editor is missing an alt attribute."
        }),
        qualityVerdict: qualityVerdict.improvements
      };
    }
    if (!(0, import_isEqual.default)(status, checks.alternativeText))
      dispatch({
        type: "UPDATE_PONCTUAL",
        value: { ...status, entity: "alternativeText" }
      });
  }, []);
  return (0, import_jsx_runtime.jsx)(
    SEOAccordion,
    {
      title: formatMessage3({
        id: getTrad("SEOModal.summary-title.alt-attributes"),
        defaultMessage: "Alternative Text"
      }),
      status: checks.alternativeText,
      label: formatMessage3({
        id: getTrad("SEOChecks.alternativeTextCheck.label"),
        defaultMessage: "This will check if you have any missing alternative text for your images (media fields) and in your 1st level richtext editors."
      }),
      component: (0, import_jsx_runtime.jsxs)(Box, { padding: 2, background: "neutral100", children: [
        (0, import_jsx_runtime.jsxs)(Flex, { spacing: 2, horizontal: true, padding: 2, children: [
          (0, import_jsx_runtime.jsx)(ForwardRef$5, { "aria-hidden": true, fill: `warning600` }),
          (0, import_jsx_runtime.jsxs)(Typography, { paddingLeft: 1, children: [
            (0, import_jsx_runtime.jsxs)(Typography, { fontWeight: "bold", children: [
              altTexts.filter((item) => item === "").length,
              " "
            ] }),
            formatMessage3({
              id: getTrad("SEOChecks.alternativeTextCheck.missing-image"),
              defaultMessage: "missing on first level image fields or inside a component."
            })
          ] })
        ] }),
        richTextAlts.map((alt, index2) => (0, import_jsx_runtime.jsx)(Flex, { spacing: 2, horizontal: true, padding: 2, children: alt.occurences > 0 && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
          (0, import_jsx_runtime.jsx)(ForwardRef$5, { "aria-hidden": true, fill: `warning600` }),
          (0, import_jsx_runtime.jsxs)(Typography, { paddingLeft: 1, children: [
            (0, import_jsx_runtime.jsxs)(Typography, { fontWeight: "bold", children: [
              alt.occurences,
              " "
            ] }),
            formatMessage3({
              id: getTrad("SEOChecks.alternativeTextCheck.missing-text"),
              defaultMessage: "missing alt in the following richtext field:"
            }),
            (0, import_jsx_runtime.jsxs)(Typography, { fontWeight: "bold", children: [
              " ",
              alt.field
            ] })
          ] })
        ] }) }, index2)),
        (0, import_jsx_runtime.jsx)(Flex, { spacing: 2, paddingTop: 4, paddingLeft: 2, paddingRight: 2, paddingBottom: 4, children: (0, import_jsx_runtime.jsx)(Status, { variant: "secondary", showBullet: false, children: (0, import_jsx_runtime.jsxs)(Typography, { children: [
          (0, import_jsx_runtime.jsx)(Typography, { fontWeight: "bold", children: "Tip: " }),
          "Implement a rule in your front-end code that uses the name of your images if the",
          (0, import_jsx_runtime.jsx)(Typography, { fontWeight: "bold", children: " alternativeText " }),
          "field is empty to further reduce the risk of an empty alt attribute on your website."
        ] }) }) })
      ] })
    }
  );
};
var collectFieldsByType = (contentType, components, fieldType) => {
  let fields = [];
  Object.entries(contentType.attributes).forEach(([field, fieldProperties]) => {
    if (fieldProperties.type === fieldType) {
      fields.push({ name: field, field: null });
    } else if (fieldProperties.type === "component") {
      Object.entries(components[fieldProperties.component].attributes).forEach(
        ([field2, fieldProperties2]) => {
          if (fieldProperties2.type === fieldType) {
            fields.push({ name: field, field: field2 });
          }
        }
      );
    }
  });
  Object.entries(components).forEach(([componentName, componentData]) => {
    Object.entries(componentData.attributes).forEach(([field, fieldProperties]) => {
      if (fieldProperties.type === fieldType) {
        fields.push({ name: componentName, field });
      }
    });
  });
  return fields;
};
var getRichTextAndBlocksFields = (contentType, components, modifiedData) => {
  let dynamicZones = [];
  Object.entries(modifiedData).forEach(([fieldName, fieldValue]) => {
    if ((0, import_isArray.default)(fieldValue)) {
      const isComponentField = fieldValue.some((subField) => "__component" in subField);
      if (isComponentField)
        dynamicZones.push(fieldName);
    }
  });
  let richTextFields = collectFieldsByType(contentType, components, "richtext");
  let blockFields = collectFieldsByType(contentType, components, "blocks");
  const filterFields = (fields) => {
    dynamicZones.forEach((dz) => {
      const dynamicZoneData = (0, import_get.default)(modifiedData, dz, []);
      fields.forEach((field, index2) => {
        const componentExistsInDZ = dynamicZoneData.filter((x) => x.__component === field.name);
        if (!(0, import_isEmpty.default)(componentExistsInDZ) && !field.inDz && dynamicZoneData.find((x) => x.hasOwnProperty(field.field))) {
          fields[index2] = { ...field, inDz: dz };
        }
        if ((0, import_isEmpty.default)(componentExistsInDZ) && field.inDz) {
          (0, import_pull.default)(fields, field);
        }
      });
    });
  };
  filterFields(richTextFields);
  filterFields(blockFields);
  return { richTextFields, blockFields };
};
var recursiveSearch = (obj, keyword, relations, results = [], allImageNames = []) => {
  const alternativeTexts = results;
  const imageNames = allImageNames;
  Object.keys(obj).forEach((key) => {
    const value = obj[key];
    if (key === keyword && typeof value !== "object") {
      alternativeTexts.push(value);
      imageNames.push(obj["name"]);
    } else if (typeof value === "object" && !relations.includes(key) && !(0, import_isNull.default)(value)) {
      recursiveSearch(value, keyword, relations, alternativeTexts, imageNames);
    }
  });
  return { alternativeTexts, imageNames };
};
var getRegularImageAltTexts = (contentType, modifiedData) => {
  const relations = ["localizations"];
  Object.keys(contentType.attributes).forEach((field) => {
    if (contentType.attributes[field].type === "relation") {
      relations.push(field);
    }
  });
  const { alternativeTexts, imageNames } = recursiveSearch(
    modifiedData,
    "alternativeText",
    relations
  );
  const alternativeTextCount = alternativeTexts.length;
  const intersections = alternativeTexts.filter((altText) => imageNames.includes(altText)).length - alternativeTextCount;
  return { intersections, altTexts: alternativeTexts };
};
var converter = new import_showdown.default.Converter();
var extractTextFromBlocks = (blocks) => {
  let textContent = "";
  blocks.forEach((block) => {
    if (block.type === "text" && block.text) {
      textContent += `${block.text} `;
    } else if (block.children && (0, import_isArray.default)(block.children)) {
      textContent += extractTextFromBlocks(block.children);
    }
  });
  return textContent.trim();
};
var getEmptyAltCount = (richtext, field, name2, isBlock = false) => {
  let htmlOccurrences = 0;
  let markdownOccurrences = 0;
  let blockOccurences = 0;
  if (isBlock && richtext) {
    richtext.forEach((element) => {
      if (element.type === "image" && element.image) {
        if (!element.image.alternativeText) {
          blockOccurences += 1;
        }
      }
    });
  } else if (richtext) {
    markdownOccurrences = richtext.split("\n").filter((entry) => entry.includes("![](")).length;
    const htmlImages = richtext.match(/<img[^>]*\/?>/g) || [];
    htmlOccurrences = htmlImages.filter((image) => !image.includes("alt=")).length;
  }
  if (name2) {
    if (name2.includes(".")) {
      return {
        field: `[dynamic-zone].${name2.split(".").pop()}.${field}`,
        occurences: markdownOccurrences + htmlOccurrences + blockOccurences
      };
    }
    return {
      field: `${name2}.${field}`,
      occurences: markdownOccurrences + htmlOccurrences + blockOccurences
    };
  }
  return { field, occurences: 0 };
};
var increaseCounter = (base, field, isBlock = false, name2 = null) => {
  let richtext = "";
  let emptyAlts = {};
  if (isBlock) {
    richtext = extractTextFromBlocks((base == null ? void 0 : base[field]) ?? []);
    emptyAlts = getEmptyAltCount(base == null ? void 0 : base[field], field, name2, true);
  } else {
    richtext = (base == null ? void 0 : base[field]) ?? "";
    emptyAlts = getEmptyAltCount(richtext, field, name2);
  }
  if (richtext) {
    const html = isBlock ? richtext : converter.makeHtml(richtext);
    const words = html.replace(/<\/?[^>]+(>|$)/g, "").replace("\n", " ").toLowerCase().split(" ").filter((entry) => entry !== "" && entry !== "\n");
    return { words, length: words.length, emptyAlts };
  }
  return { words: [], length: 0, emptyAlts };
};
var buildKeywordDensityObject = (keywords2, words, keywordsDensity) => {
  let tempKeywordsDensity = { ...keywordsDensity };
  keywords2.forEach((keyword) => {
    if (!(0, import_isEmpty.default)(keyword)) {
      const trimmedKeyword = keyword.trim();
      const regex = new RegExp(trimmedKeyword.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g");
      const count = (words.join(" ").match(regex) || []).length;
      if (!tempKeywordsDensity.hasOwnProperty(trimmedKeyword)) {
        tempKeywordsDensity[trimmedKeyword] = { count };
      } else {
        tempKeywordsDensity[trimmedKeyword].count += count;
      }
    }
  });
  return tempKeywordsDensity;
};
var adjustIntersections = (data2) => {
  const { emptyAltCount } = data2;
  let occurrences = 0;
  emptyAltCount.richTextAlts.forEach((alt) => {
    occurrences += alt.occurences;
  });
  emptyAltCount.blockTextAlts.forEach((alt) => {
    occurrences += alt.occurences;
  });
  emptyAltCount.intersections -= occurrences;
  return data2;
};
var getRichTextData = (modifiedData, components, contentType) => {
  var _a2;
  const { richTextFields, blockFields } = getRichTextAndBlocksFields(
    contentType,
    components,
    modifiedData
  );
  const { intersections, altTexts } = getRegularImageAltTexts(contentType, modifiedData);
  let emptyAltCount = { intersections, richTextAlts: [], blockTextAlts: [], altTexts };
  let wordCount = 0;
  let keywords2 = [];
  let keywordsDensity = {};
  const seoKeywords = ((_a2 = modifiedData == null ? void 0 : modifiedData.seo) == null ? void 0 : _a2.keywords) ?? "";
  if (seoKeywords) {
    keywords2 = seoKeywords.toLowerCase().split(",");
  }
  richTextFields.forEach((data2) => {
    if ((0, import_isNull.default)(data2.field)) {
      const { words, length, emptyAlts } = increaseCounter(modifiedData, data2.name);
      wordCount += length;
      emptyAltCount.richTextAlts.push(emptyAlts);
      keywordsDensity = buildKeywordDensityObject(keywords2, words, keywordsDensity);
    } else if (!data2.inDz) {
      const item = (0, import_get.default)(modifiedData, data2.name.split(".").pop(), "");
      if (item) {
        const isRepeatable = (0, import_isArray.default)(item);
        if (isRepeatable) {
          item.forEach((entry) => {
            const { words, length, emptyAlts } = increaseCounter(
              entry,
              data2.field,
              false,
              data2.name
            );
            wordCount += length;
            emptyAltCount.richTextAlts.push(emptyAlts);
            keywordsDensity = buildKeywordDensityObject(keywords2, words, keywordsDensity);
          });
        } else {
          const { words, length, emptyAlts } = increaseCounter(item, data2.field, false, data2.name);
          wordCount += length;
          emptyAltCount.richTextAlts.push(emptyAlts);
          keywordsDensity = buildKeywordDensityObject(keywords2, words, keywordsDensity);
        }
      }
    } else {
      const components2 = (0, import_get.default)(modifiedData, data2.inDz, []);
      if (!(0, import_isEmpty.default)(components2)) {
        const richTextComponents = components2.filter((x) => x.__component === data2.name);
        richTextComponents.forEach((component) => {
          const item = (0, import_get.default)(component, data2.field, []);
          const isRepeatable = (0, import_isArray.default)(item);
          if (isRepeatable) {
            item.forEach((entry) => {
              const { words, length, emptyAlts } = increaseCounter(
                entry,
                data2.field,
                false,
                data2.name
              );
              wordCount += length;
              emptyAltCount.richTextAlts.push(emptyAlts);
              keywordsDensity = buildKeywordDensityObject(keywords2, words, keywordsDensity);
            });
          } else {
            const { words, length, emptyAlts } = increaseCounter(
              component,
              data2.field,
              false,
              data2.name
            );
            wordCount += length;
            emptyAltCount.richTextAlts.push(emptyAlts);
            keywordsDensity = buildKeywordDensityObject(keywords2, words, keywordsDensity);
          }
        });
      }
    }
  });
  blockFields.forEach((data2) => {
    if ((0, import_isNull.default)(data2.field)) {
      const { words, length, emptyAlts } = increaseCounter(modifiedData, data2.name, true);
      wordCount += length;
      emptyAltCount.blockTextAlts.push(emptyAlts);
      keywordsDensity = buildKeywordDensityObject(keywords2, words, keywordsDensity);
    } else if (!data2.inDz) {
      const item = (0, import_get.default)(modifiedData, data2.name.split(".").pop(), "");
      if (item) {
        const isRepeatable = (0, import_isArray.default)(item);
        if (isRepeatable) {
          item.forEach((entry) => {
            const { words, length, emptyAlts } = increaseCounter(
              entry,
              data2.field,
              true,
              data2.name
            );
            wordCount += length;
            emptyAltCount.blockTextAlts.push(emptyAlts);
            keywordsDensity = buildKeywordDensityObject(keywords2, words, keywordsDensity);
          });
        } else {
          const { words, length, emptyAlts } = increaseCounter(item, data2.field, true, data2.name);
          wordCount += length;
          emptyAltCount.blockTextAlts.push(emptyAlts);
          keywordsDensity = buildKeywordDensityObject(keywords2, words, keywordsDensity);
        }
      }
    } else {
      const components2 = (0, import_get.default)(modifiedData, data2.inDz, []);
      if (!(0, import_isEmpty.default)(components2)) {
        const blockComponents = components2.filter((x) => x.__component === data2.name);
        blockComponents.forEach((component) => {
          const item = (0, import_get.default)(component, data2.field, []);
          const isRepeatable = (0, import_isArray.default)(item);
          if (isRepeatable) {
            item.forEach((entry) => {
              const { words, length, emptyAlts } = increaseCounter(
                entry,
                data2.field,
                true,
                data2.name
              );
              wordCount += length;
              emptyAltCount.blockTextAlts.push(emptyAlts);
              keywordsDensity = buildKeywordDensityObject(keywords2, words, keywordsDensity);
            });
          } else {
            const { words, length, emptyAlts } = increaseCounter(
              component,
              data2.field,
              true,
              data2.name
            );
            wordCount += length;
            emptyAltCount.blockTextAlts.push(emptyAlts);
            keywordsDensity = buildKeywordDensityObject(keywords2, words, keywordsDensity);
          }
        });
      }
    }
  });
  return adjustIntersections({
    wordCount,
    keywordsDensity,
    emptyAltCount
  });
};
var SeoChecks = ({ updatedAt, modifiedData, components, contentType, checks }) => {
  const { formatMessage: formatMessage3 } = useIntl();
  const { wordCount, keywordsDensity, emptyAltCount } = getRichTextData(
    modifiedData,
    components,
    contentType
  );
  const seo = (modifiedData == null ? void 0 : modifiedData.seo) ?? null;
  const hasSeo = seo && Object.keys(seo).length > 0;
  return (0, import_jsx_runtime.jsxs)(Modal.Content, { labelledBy: "title", children: [
    (0, import_jsx_runtime.jsx)(Modal.Header, { children: (0, import_jsx_runtime.jsx)(Typography, { fontWeight: "bold", textColor: "neutral800", as: "h2", id: "title", children: formatMessage3({
      id: getTrad("Button.seo-analyze"),
      defaultMessage: "SEO Analyze"
    }) }) }),
    (0, import_jsx_runtime.jsx)(Modal.Body, { children: hasSeo ? (0, import_jsx_runtime.jsxs)(Box, { children: [
      (checks == null ? void 0 : checks.metaTitle) && (0, import_jsx_runtime.jsx)(MetaTitleCheck, { metaTitle: (seo == null ? void 0 : seo.metaTitle) ?? null, checks }),
      (checks == null ? void 0 : checks.metaDescription) && (0, import_jsx_runtime.jsx)(
        MetaDescriptionCheck,
        {
          metaDescription: (seo == null ? void 0 : seo.metaDescription) ?? null,
          checks
        }
      ),
      (checks == null ? void 0 : checks.wordCount) && (0, import_jsx_runtime.jsx)(WordCountCheck, { wordCount, checks }),
      (checks == null ? void 0 : checks.keywordsDensity) && (0, import_jsx_runtime.jsx)(KeywordDensityCheck, { keywordsDensity, checks }),
      (checks == null ? void 0 : checks.openGraph) && (0, import_jsx_runtime.jsx)(OpenGraphCheck, { openGraph: (seo == null ? void 0 : seo.openGraph) ?? null, checks }),
      (checks == null ? void 0 : checks.canonicalUrl) && (0, import_jsx_runtime.jsx)(CanonicalUrlCheck, { canonicalUrl: (seo == null ? void 0 : seo.canonicalURL) ?? null, checks }),
      (checks == null ? void 0 : checks.structuredData) && (0, import_jsx_runtime.jsx)(StructuredDataCheck, { structuredData: (seo == null ? void 0 : seo.structuredData) ?? null, checks }),
      (checks == null ? void 0 : checks.metaRobots) && (0, import_jsx_runtime.jsx)(MetaRobotCheck, { metaRobots: (seo == null ? void 0 : seo.metaRobots) ?? null, checks }),
      (checks == null ? void 0 : checks.alternativeText) && (0, import_jsx_runtime.jsx)(
        AlternativeTextCheck,
        {
          intersections: (emptyAltCount == null ? void 0 : emptyAltCount.intersections) ?? null,
          richTextAlts: (emptyAltCount == null ? void 0 : emptyAltCount.richTextAlts) ?? null,
          altTexts: (emptyAltCount == null ? void 0 : emptyAltCount.altTexts) ?? null,
          checks
        }
      ),
      (checks == null ? void 0 : checks.lastUpdatedAt) && (0, import_jsx_runtime.jsx)(LastUpdatedAtCheck, { updatedAt, checks })
    ] }) : (0, import_jsx_runtime.jsx)(Box, { paddingLeft: 4, children: (0, import_jsx_runtime.jsx)(
      EmptyStateLayout,
      {
        icon: (0, import_jsx_runtime.jsx)(Illo, {}),
        content: formatMessage3({
          id: getTrad("Modal.seo-component-empty"),
          defaultMessage: "Your SEO component is empty..."
        })
      }
    ) }) })
  ] });
};
var PreviewChecks = ({ checks }) => {
  const { formatMessage: formatMessage3 } = useIntl();
  const good = Object.values(checks).filter(
    (check) => check.qualityVerdict === qualityVerdict.good
  ).length;
  const improvements = Object.values(checks).filter(
    (check) => check.qualityVerdict === qualityVerdict.improvements
  ).length;
  const bad = Object.values(checks).filter(
    (check) => check.qualityVerdict === qualityVerdict.bad
  ).length;
  return (0, import_jsx_runtime.jsxs)(Box, { paddingTop: 2, children: [
    (0, import_jsx_runtime.jsxs)(Flex, { gap: 2, children: [
      (0, import_jsx_runtime.jsx)(ForwardRef$4L, { "aria-hidden": true, fill: `success600` }),
      (0, import_jsx_runtime.jsxs)(Typography, { children: [
        formatMessage3({
          id: getTrad("Good"),
          defaultMessage: "Good"
        }),
        `: ${good}`
      ] })
    ] }, qualityVerdict.good),
    (0, import_jsx_runtime.jsxs)(Flex, { gap: 2, children: [
      (0, import_jsx_runtime.jsx)(ForwardRef$5, { "aria-hidden": true, fill: `warning600` }),
      (0, import_jsx_runtime.jsxs)(Typography, { children: [
        formatMessage3({
          id: getTrad("Improvements"),
          defaultMessage: "Improvements"
        }),
        `: ${improvements}`
      ] })
    ] }, qualityVerdict.improvements),
    (0, import_jsx_runtime.jsxs)(Flex, { gap: 2, children: [
      (0, import_jsx_runtime.jsx)(ForwardRef$4b, { "aria-hidden": true, fill: `danger600` }),
      (0, import_jsx_runtime.jsxs)(Typography, { children: [
        formatMessage3({
          id: getTrad("Bad"),
          defaultMessage: "Bad"
        }),
        `: ${bad}`
      ] })
    ] }, qualityVerdict.bad)
  ] });
};
var Serp = ({ metaTitle, metaDescription }) => {
  const metaTitleToDisplay = metaTitle.length > 60 ? `${metaTitle.substring(0, 56)} ...` : metaTitle;
  const metaDescriptionToDisplay = metaDescription.length > 160 ? `${metaDescription.substring(0, 156)} ...` : metaDescription;
  return (0, import_jsx_runtime.jsxs)(Box, { padding: 4, background: "neutral100", width: "580px", children: [
    (0, import_jsx_runtime.jsx)(Typography, { variant: "beta", textColor: "primary600", children: metaTitleToDisplay }),
    (0, import_jsx_runtime.jsx)(Flex, { marginTop: 1, children: (0, import_jsx_runtime.jsx)(Typography, { variant: "pi", textColor: "neutral600", children: metaDescriptionToDisplay }) })
  ] });
};
var MetaChecks = ({ item, max: max2, label, minLimit = false }) => {
  const getIcon = () => {
    if (item.length >= max2 || label === "title" && item.length === 0 || minLimit && label === "description" && item.length <= 50) {
      return (0, import_jsx_runtime.jsx)(ForwardRef$5, { "aria-hidden": true, fill: `warning600` });
    } else {
      return (0, import_jsx_runtime.jsx)(ForwardRef$4L, { "aria-hidden": true, fill: `success600` });
    }
  };
  return (0, import_jsx_runtime.jsxs)(Flex, { spacing: 1, horizontal: true, children: [
    getIcon(),
    (0, import_jsx_runtime.jsx)(Typography, { children: `Your ${label} is ${item.length || 0} characters long (max ${max2})` })
  ] });
};
var KeywordCheck = ({ item, keywords: keywords2, label }) => {
  const _keywords = keywords2.split(",");
  const matches = _keywords.filter((x) => item.toLowerCase().includes(x.toLowerCase().trim()));
  const getIcon = () => {
    if (matches.length === 0) {
      return (0, import_jsx_runtime.jsx)(ForwardRef$5, { "aria-hidden": true, fill: `warning600` });
    } else {
      return (0, import_jsx_runtime.jsx)(ForwardRef$4L, { "aria-hidden": true, fill: `success600` });
    }
  };
  return (0, import_jsx_runtime.jsxs)(Flex, { spacing: 1, horizontal: true, children: [
    getIcon(),
    (0, import_jsx_runtime.jsx)(Typography, { children: `You use ${matches.length} keyword${matches.length > 1 ? "s" : ""} in your ${label} (${matches.join(", ").trim()})` })
  ] });
};
var BrowserPreview = ({ modifiedData }) => {
  const { formatMessage: formatMessage3 } = useIntl();
  const seo = (0, import_get.default)(modifiedData, "seo", null);
  const metaTitle = (0, import_get.default)(seo, "metaTitle", null);
  const metaDescription = (0, import_get.default)(seo, "metaDescription", null);
  const keywords2 = (0, import_get.default)(seo, "keywords", null);
  return (0, import_jsx_runtime.jsxs)(Modal.Content, { labelledBy: "title", children: [
    (0, import_jsx_runtime.jsx)(Modal.Header, { children: (0, import_jsx_runtime.jsx)(Typography, { fontWeight: "bold", textColor: "neutral800", as: "h2", id: "title", children: formatMessage3({
      id: getTrad("Button.browser-preview"),
      defaultMessage: "Browser Preview"
    }) }) }),
    (0, import_jsx_runtime.jsx)(Modal.Body, { children: seo ? (0, import_jsx_runtime.jsxs)(Flex, { direction: "column", gap: 2, alignItems: "flex-start", children: [
      metaTitle && metaDescription && (0, import_jsx_runtime.jsx)(Box, { paddingBottom: 6, children: (0, import_jsx_runtime.jsx)(Serp, { metaTitle, metaDescription }) }),
      (0, import_jsx_runtime.jsx)(Divider, { marginBottom: 4, width: "100%" }),
      metaTitle && (0, import_jsx_runtime.jsx)(MetaChecks, { item: metaTitle, max: 60, label: "title" }),
      metaDescription && (0, import_jsx_runtime.jsx)(MetaChecks, { item: metaDescription, max: 160, label: "description", minLimit: true }),
      keywords2 && (0, import_jsx_runtime.jsxs)(React11.Fragment, { children: [
        metaTitle && (0, import_jsx_runtime.jsx)(KeywordCheck, { item: metaTitle, keywords: keywords2, label: "title" }),
        metaDescription && (0, import_jsx_runtime.jsx)(KeywordCheck, { item: metaDescription, keywords: keywords2, label: "description" })
      ] })
    ] }) : (0, import_jsx_runtime.jsx)(Box, { paddingLeft: 4, children: (0, import_jsx_runtime.jsx)(
      EmptyStateLayout,
      {
        icon: (0, import_jsx_runtime.jsx)(Illo, {}),
        content: formatMessage3({
          id: getTrad("Modal.seo-component-empty"),
          defaultMessage: "Your SEO component is empty..."
        })
      }
    ) }) })
  ] });
};
var FacebookOGPreview = ({ image, title, description: description2 }) => {
  return (0, import_jsx_runtime.jsxs)(
    "div",
    {
      style: {
        width: "500px",
        border: "1px solid #dadde1",
        fontFamily: "Helvetica, Arial, sans-serif",
        cursor: "pointer",
        margin: "auto",
        marginBottom: "40px"
      },
      children: [
        (0, import_jsx_runtime.jsx)(
          "div",
          {
            style: {
              borderBottom: "1px solid #dadde1",
              backgroundSize: "cover",
              backgroundPosition: "center"
            },
            children: (0, import_jsx_runtime.jsx)("div", { style: { width: "100%", position: "relative", paddingTop: "52.5%" }, children: (0, import_jsx_runtime.jsx)(
              "img",
              {
                src: image.url,
                alt: title,
                style: {
                  position: "absolute",
                  top: 0,
                  left: 0,
                  width: "100%",
                  height: "100%",
                  objectFit: "cover"
                }
              }
            ) })
          }
        ),
        (0, import_jsx_runtime.jsxs)("div", { style: { backgroundColor: "#f2f3f5", padding: "12px 10px", lineHeight: "1.4" }, children: [
          (0, import_jsx_runtime.jsx)(
            "div",
            {
              style: {
                fontSize: "12px",
                textTransform: "uppercase",
                color: "#606770",
                marginBottom: "4px",
                whiteSpace: "nowrap",
                overflow: "hidden",
                textOverflow: "ellipsis"
              },
              children: "your-site.io"
            }
          ),
          (0, import_jsx_runtime.jsx)(
            "div",
            {
              style: {
                fontSize: "16px",
                fontWeight: "bold",
                color: "#1d2129",
                marginBottom: "4px",
                overflow: "hidden",
                textOverflow: "ellipsis",
                whiteSpace: "nowrap"
              },
              children: title.substring(0, 65)
            }
          ),
          (0, import_jsx_runtime.jsx)(
            "div",
            {
              style: {
                fontSize: "14px",
                color: "#606770",
                maxHeight: "40px",
                overflow: "hidden",
                textOverflow: "ellipsis",
                WebkitLineClamp: 2,
                WebkitBoxOrient: "vertical",
                display: "-webkit-box"
              },
              children: description2.substring(0, 150)
            }
          )
        ] })
      ]
    }
  );
};
var TwitterOGPreview = ({ image, title, description: description2 }) => {
  return (0, import_jsx_runtime.jsxs)(
    "div",
    {
      style: {
        width: "100%",
        maxWidth: "500px",
        border: "1px solid #e1e8ed",
        fontFamily: "Arial, sans-serif",
        borderRadius: "8px",
        overflow: "hidden",
        cursor: "pointer",
        margin: "auto",
        marginBottom: "40px"
      },
      children: [
        (0, import_jsx_runtime.jsx)(
          "div",
          {
            style: {
              backgroundSize: "cover",
              backgroundPosition: "center",
              backgroundRepeat: "no-repeat"
            },
            children: (0, import_jsx_runtime.jsx)("div", { style: { width: "100%", position: "relative", paddingTop: "52.5%" }, children: (0, import_jsx_runtime.jsx)(
              "img",
              {
                src: image.url,
                alt: title,
                style: {
                  position: "absolute",
                  top: 0,
                  left: 0,
                  width: "100%",
                  height: "100%",
                  objectFit: "cover"
                }
              }
            ) })
          }
        ),
        (0, import_jsx_runtime.jsxs)(
          "div",
          {
            style: {
              backgroundColor: "#ffffff",
              padding: "12px 10px",
              lineHeight: "1.4",
              borderTop: "1px solid #e1e8ed"
            },
            children: [
              (0, import_jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    fontSize: "12px",
                    color: "#657786",
                    marginBottom: "4px",
                    whiteSpace: "nowrap",
                    overflow: "hidden",
                    textOverflow: "ellipsis"
                  },
                  children: "your-site.io"
                }
              ),
              (0, import_jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    fontSize: "16px",
                    fontWeight: "bold",
                    color: "#14171A",
                    marginBottom: "4px",
                    overflow: "hidden",
                    textOverflow: "ellipsis",
                    whiteSpace: "nowrap"
                  },
                  children: title.substring(0, 70)
                }
              ),
              (0, import_jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    fontSize: "14px",
                    color: "#657786",
                    maxHeight: "40px",
                    overflow: "hidden",
                    textOverflow: "ellipsis",
                    WebkitLineClamp: 2,
                    WebkitBoxOrient: "vertical",
                    display: "-webkit-box"
                  },
                  children: description2.substring(0, 200)
                }
              )
            ]
          }
        )
      ]
    }
  );
};
var LinkedInOGPreview = ({ image, title, description: description2 }) => {
  return (0, import_jsx_runtime.jsxs)(
    "div",
    {
      style: {
        width: "100%",
        maxWidth: "500px",
        borderRadius: "2px",
        boxShadow: "0 0 0 1px rgba(0,0,0,.15),0 2px 3px rgba(0,0,0,.2)",
        fontFamily: "Arial, sans-serif",
        overflow: "hidden",
        cursor: "pointer",
        margin: "auto",
        marginBottom: "40px"
      },
      children: [
        (0, import_jsx_runtime.jsx)(
          "div",
          {
            style: {
              backgroundSize: "cover",
              backgroundPosition: "center",
              backgroundRepeat: "no-repeat"
            },
            children: (0, import_jsx_runtime.jsx)("div", { style: { width: "100%", position: "relative", paddingTop: "52.5%" }, children: (0, import_jsx_runtime.jsx)(
              "img",
              {
                src: image.url,
                alt: title,
                style: {
                  position: "absolute",
                  top: 0,
                  left: 0,
                  width: "100%",
                  height: "100%",
                  objectFit: "cover"
                }
              }
            ) })
          }
        ),
        (0, import_jsx_runtime.jsxs)(
          "div",
          {
            style: {
              backgroundColor: "#ffffff",
              padding: "12px 16px",
              lineHeight: "1.5",
              borderTop: "1px solid #ccd0d5"
            },
            children: [
              (0, import_jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    fontSize: "18px",
                    fontWeight: "bold",
                    color: "#333333",
                    marginBottom: "2px",
                    overflow: "hidden",
                    textOverflow: "ellipsis",
                    whiteSpace: "nowrap"
                  },
                  children: title.substring(0, 70)
                }
              ),
              (0, import_jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    fontSize: "12px",
                    color: "#666666",
                    marginBottom: "4px",
                    whiteSpace: "nowrap",
                    overflow: "hidden",
                    textOverflow: "ellipsis"
                  },
                  children: "your-site.io"
                }
              )
            ]
          }
        )
      ]
    }
  );
};
var OpenGraphPreview = ({ modifiedData }) => {
  const { formatMessage: formatMessage3 } = useIntl();
  const { openGraph } = modifiedData == null ? void 0 : modifiedData.seo;
  return (0, import_jsx_runtime.jsxs)(Modal.Content, { labelledBy: "title", children: [
    (0, import_jsx_runtime.jsx)(Modal.Header, { children: (0, import_jsx_runtime.jsx)(Typography, { fontWeight: "bold", textColor: "neutral800", as: "h2", id: "title", children: formatMessage3({
      id: getTrad("Button.open-graph-preview"),
      defaultMessage: "Open Graph Preview"
    }) }) }),
    (0, import_jsx_runtime.jsx)(Modal.Body, { children: openGraph["ogTitle"] && openGraph["ogDescription"] && openGraph["ogImage"] ? (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
      (0, import_jsx_runtime.jsx)(Flex, { alignItems: "left", direction: "column", gap: 2, children: (0, import_jsx_runtime.jsx)(Flex, { gap: 1, children: (0, import_jsx_runtime.jsx)(Badge, { backgroundColor: "neutral150", textColor: "neutral600", children: "Facebook" }) }) }),
      (0, import_jsx_runtime.jsx)(
        FacebookOGPreview,
        {
          title: openGraph["ogTitle"],
          description: openGraph["ogDescription"],
          image: openGraph["ogImage"]
        }
      ),
      (0, import_jsx_runtime.jsx)(Flex, { alignItems: "left", direction: "column", gap: 2, children: (0, import_jsx_runtime.jsx)(Flex, { gap: 1, children: (0, import_jsx_runtime.jsx)(Badge, { backgroundColor: "neutral150", textColor: "neutral600", children: "X (Twitter)" }) }) }),
      (0, import_jsx_runtime.jsx)(
        TwitterOGPreview,
        {
          title: openGraph["ogTitle"],
          description: openGraph["ogDescription"],
          image: openGraph["ogImage"]
        }
      ),
      (0, import_jsx_runtime.jsx)(Flex, { alignItems: "left", direction: "column", gap: 2, children: (0, import_jsx_runtime.jsx)(Flex, { gap: 1, children: (0, import_jsx_runtime.jsx)(Badge, { backgroundColor: "neutral150", textColor: "neutral600", children: "LinkedIn" }) }) }),
      (0, import_jsx_runtime.jsx)(
        LinkedInOGPreview,
        {
          title: openGraph["ogTitle"],
          description: openGraph["ogDescription"],
          image: openGraph["ogImage"]
        }
      )
    ] }) : (0, import_jsx_runtime.jsx)(Box, { paddingLeft: 4, children: (0, import_jsx_runtime.jsx)(
      EmptyStateLayout,
      {
        icon: (0, import_jsx_runtime.jsx)(Illo, {}),
        content: formatMessage3({
          id: getTrad("Modal.seo-component-empty-open-graph"),
          defaultMessage: "The Open Graph metadata is empty..."
        })
      }
    ) }) })
  ] });
};
var useSettingsApi = () => {
  const { get: get2, post } = useFetchClient();
  const getSettings = async () => {
    const resultData = await get2("/seo/settings");
    return resultData;
  };
  const setSettings = async (data2) => {
    const resultData = await post("/seo/settings", data2);
    return resultData;
  };
  return { getSettings, setSettings };
};
var initialState = {
  preview: true
};
var SeoCheckerContext = React11.createContext(null);
var Summary = () => {
  const { formatMessage: formatMessage3 } = useIntl();
  const { getSettings } = useSettingsApi();
  const [isLoading, setIsLoading] = React11.useState(true);
  const [localChecks, setLocalChecks] = React11.useState({});
  const [checks, dispatch] = React11.useReducer(reducer, initialState);
  const { model, collectionType, id, form, contentType, components } = useContentManagerContext();
  const { values: modifiedData } = form;
  const { metaTitle, metaDescription, openGraph } = modifiedData.seo;
  const { document } = useDocument({
    model,
    collectionType,
    documentId: id
  });
  const getAllChecks = async (modifiedData2, components2, contentType2) => {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t;
    const { data: defaultSettings } = await getSettings();
    const { wordCount, keywordsDensity, emptyAltCount } = getRichTextData(
      modifiedData2,
      components2,
      contentType2
    );
    let result = {
      ...((_b = (_a2 = defaultSettings[contentType2 == null ? void 0 : contentType2.uid]) == null ? void 0 : _a2.seoChecks) == null ? void 0 : _b.metaTitle) && {
        metaTitle: getMetaTitleCheckPreview(modifiedData2)
      },
      ...((_d = (_c = defaultSettings[contentType2 == null ? void 0 : contentType2.uid]) == null ? void 0 : _c.seoChecks) == null ? void 0 : _d.wordCount) && {
        wordCount: getWordCountPreview(wordCount)
      },
      ...((_f = (_e = defaultSettings[contentType2 == null ? void 0 : contentType2.uid]) == null ? void 0 : _e.seoChecks) == null ? void 0 : _f.metaRobots) && {
        metaRobots: metaRobotPreview(modifiedData2)
      },
      ...((_h = (_g = defaultSettings[contentType2 == null ? void 0 : contentType2.uid]) == null ? void 0 : _g.seoChecks) == null ? void 0 : _h.openGraph) && {
        openGraph: openGraphPreview(modifiedData2)
      },
      ...((_j = (_i = defaultSettings[contentType2 == null ? void 0 : contentType2.uid]) == null ? void 0 : _i.seoChecks) == null ? void 0 : _j.canonicalUrl) && {
        canonicalUrl: canonicalUrlPreview(modifiedData2)
      },
      ...((_l = (_k = defaultSettings[contentType2 == null ? void 0 : contentType2.uid]) == null ? void 0 : _k.seoChecks) == null ? void 0 : _l.lastUpdatedAt) && {
        lastUpdatedAt: lastUpdatedAtPreview(modifiedData2)
      },
      ...((_n = (_m = defaultSettings[contentType2 == null ? void 0 : contentType2.uid]) == null ? void 0 : _m.seoChecks) == null ? void 0 : _n.structuredData) && {
        structuredData: structuredDataPreview(modifiedData2)
      },
      ...((_p = (_o = defaultSettings[contentType2 == null ? void 0 : contentType2.uid]) == null ? void 0 : _o.seoChecks) == null ? void 0 : _p.metaDescription) && {
        metaDescription: getMetaDescriptionPreview(modifiedData2)
      },
      ...((_r = (_q = defaultSettings[contentType2 == null ? void 0 : contentType2.uid]) == null ? void 0 : _q.seoChecks) == null ? void 0 : _r.alternativeText) && {
        alternativeText: getAlternativeTextPreview(emptyAltCount)
      },
      ...((_t = (_s = defaultSettings[contentType2 == null ? void 0 : contentType2.uid]) == null ? void 0 : _s.seoChecks) == null ? void 0 : _t.keywordDensity) && {
        keywordsDensity: getKeywordDensityPreview(keywordsDensity)
      }
    };
    return result;
  };
  React11.useEffect(() => {
    const fetchChecks = async () => {
      if (!(JSON.stringify(localChecks) === JSON.stringify(checks))) {
        if (checks == null ? void 0 : checks.preview) {
          const status = await getAllChecks(modifiedData, components, contentType);
          dispatch({
            type: "UPDATE_FOR_PREVIEW",
            value: status
          });
        } else
          dispatch({
            type: "UPDATE_FOR_PREVIEW",
            value: checks
          });
        setLocalChecks(checks);
      }
    };
    fetchChecks().then(() => {
      setIsLoading(false);
    });
  }, [checks]);
  return (0, import_jsx_runtime.jsx)(SeoCheckerContext.Provider, { value: dispatch, children: (0, import_jsx_runtime.jsxs)(Box, { paddingTop: 4, width: "100%", children: [
    (0, import_jsx_runtime.jsx)(Typography, { tag: "h2", variant: "sigma", textTransform: "uppercase", textColor: "neutral600", children: formatMessage3({
      id: getTrad("Plugin.name"),
      defaultMessage: "SEO Plugin"
    }) }),
    metaTitle && metaDescription && (0, import_jsx_runtime.jsxs)(Modal.Root, { children: [
      (0, import_jsx_runtime.jsx)(Modal.Trigger, { children: (0, import_jsx_runtime.jsx)(Box, { paddingTop: 1, children: (0, import_jsx_runtime.jsx)(Button, { fullWidth: true, variant: "secondary", startIcon: (0, import_jsx_runtime.jsx)(ForwardRef$3L, {}), children: formatMessage3({
        id: getTrad("Button.browser-preview"),
        defaultMessage: "Browser Preview"
      }) }) }) }),
      (0, import_jsx_runtime.jsx)(BrowserPreview, { modifiedData })
    ] }),
    openGraph && (0, import_jsx_runtime.jsxs)(Modal.Root, { children: [
      (0, import_jsx_runtime.jsx)(Modal.Trigger, { children: (0, import_jsx_runtime.jsx)(Box, { paddingTop: 2, children: (0, import_jsx_runtime.jsx)(Button, { fullWidth: true, variant: "secondary", startIcon: (0, import_jsx_runtime.jsx)(ForwardRef$3L, {}), children: formatMessage3({
        id: getTrad("Button.open-graph-preview"),
        defaultMessage: "Open Graph Preview"
      }) }) }) }),
      (0, import_jsx_runtime.jsx)(OpenGraphPreview, { modifiedData })
    ] }),
    !isLoading && (0, import_jsx_runtime.jsx)(PreviewChecks, { checks }),
    (0, import_jsx_runtime.jsxs)(Modal.Root, { children: [
      (0, import_jsx_runtime.jsx)(Modal.Trigger, { children: (0, import_jsx_runtime.jsx)(Box, { paddingTop: 4, children: (0, import_jsx_runtime.jsx)(TextButton, { startIcon: (0, import_jsx_runtime.jsx)(ForwardRef$5l, {}), children: formatMessage3({
        id: getTrad("Button.see-details"),
        defaultMessage: "SEE DETAILS"
      }) }) }) }),
      (0, import_jsx_runtime.jsx)(
        SeoChecks,
        {
          updatedAt: (document == null ? void 0 : document.updatedAt) ?? null,
          modifiedData,
          components,
          contentType,
          checks
        }
      )
    ] })
  ] }) });
};
var SeoChecker = () => {
  const {
    form: { values }
  } = useContentManagerContext();
  if (values == null ? void 0 : values.seo) {
    return (0, import_jsx_runtime.jsx)(Summary, {});
  }
  return (0, import_jsx_runtime.jsx)(React11.Fragment, {});
};
var pluginPermissions = {
  // This permission regards the main component (App) and is used to tell
  // If the plugin link should be displayed in the menu
  // And also if the plugin is accessible. This use case is found when a user types the url of the
  // plugin directly in the browser
  main: [{ action: "plugin::seo.read", subject: null }]
};
var prefixPluginTranslations = (trad, pluginId2) => {
  if (!pluginId2) {
    throw new TypeError("pluginId can't be empty");
  }
  return Object.keys(trad).reduce((acc, current) => {
    acc[`${pluginId2}.${current}`] = trad[current];
    return acc;
  }, {});
};
var name = pluginPkg.strapi.name;
var index = {
  register(app) {
    app.addMenuLink({
      to: `${pluginId}`,
      icon: ForwardRef$$,
      permissions: pluginPermissions.main,
      intlLabel: {
        id: `${pluginId}.plugin.name`,
        defaultMessage: "SEO"
      },
      Component: () => import("./index-BxZP8eN4-QPBRYWHE.js")
    });
    app.registerPlugin({
      id: pluginId,
      initializer: Initializer,
      isReady: false,
      name
    });
  },
  bootstrap(app) {
    app.getPlugin("content-manager").injectComponent("editView", "right-links", {
      name: "SeoChecker",
      Component: SeoChecker
    });
  },
  async registerTrads(app) {
    const { locales } = app;
    const importedTrads = await Promise.all(
      locales.map((locale) => {
        return __variableDynamicImportRuntimeHelper(Object.assign({ "./translations/en.json": () => import("./en-D_923Zjg-MNTAIXFC.js"), "./translations/fr.json": () => import("./fr-4GniPx7g-27OXG5H3.js"), "./translations/pt-BR.json": () => import("./pt-BR-Coahg9yn-XAALRTHH.js") }), `./translations/${locale}.json`).then(({ default: data2 }) => {
          return {
            data: prefixPluginTranslations(data2, pluginId),
            locale
          };
        }).catch(() => {
          return {
            data: {},
            locale
          };
        });
      })
    );
    return Promise.resolve(importedTrads);
  }
};

export {
  useIntl,
  pluginId,
  Illo,
  getTrad,
  useSettingsApi,
  pluginPermissions,
  index
};
/*! Bundled license information:

showdown/dist/showdown.js:
  (*! showdown v 2.1.0 - 21-04-2022 *)
*/
//# sourceMappingURL=chunk-QTDGEJMA.js.map
